fun basisv_of_bits b v = match (b,v) .
                         + (0b0,0b0) . |0> 
                         + (0b0,0b1) . |1> 
                         + (0b1,0b0) . |+> 
                         + (0b1,0b1) . |-> 

(* send encoded (bit, value) pairs down channel qc *)
proc SendQbits (bvs,qc,sent) =   
    match bvs .
    + []         . sent!() . _0
    + (b,v)::bvs . (newq q = basisv_of_bits b v)
                     qc!q    .
                     SendQbits (bvs,qc,sent)

(* receive qbits on channel qc, measure them, return the results 
   when you see a tagged message on channel bsc
 *)
proc ReceiveQBits (bvs, qc, bsc, result) =
  + qc?(q)                   . 
        (let b = randbit ())
        q-/-[if b=0b1 then H else I](v) .
        ReceiveQBits((b,v)::bvs,qc,bsc,result)
  + bsc?(message)            . 
        result!(bvs,message) . 
        _0

(* Read qbits from qA, measure them in a random basis, send the measured bits on qB. 
   Stop when you see a message on bsA, and return measurements, tag and message.
 *)
proc CopyQBits (bvs, qA, qB, bsA, results) =
    + qA?(q)            . (let b = randbit ())
                          q-/-[if b=0b1 then H else I](v) . 
                          (newq q = basisv_of_bits b v) 
                          qB!q                              . 
                          CopyQBits ((b,v)::bvs, qA, qB, bsA, results)
    + bsA?(tag,bits)    . (let bs, vs = unzip (rev bvs))
                          results!bs                        . 
                          results!vs                        .
                          results!tag                       .
                          results!bits                      .
                          _0

(* filter out masked bits *)
fun mask_filter (m:''a) (mask:[''a]) (vs:['b]) : ['b]
   = vs where _, vs = unzip mvs
        where mvs = filter (lam (me,_) . me=m) (zip mask vs)

fun xor_mask code message 
  = map (lam (b1,b2) . if b1=b2 then 0b0 else 0b1) (zip code message)

(* pick out the bits that are in the same bases *)
fun reconcile b1s b2s vs = mask_filter 0b0 (xor_mask b1s b2s) vs
    
(* select check bits randomly. Use 1/4 probability because it's easy *)
fun cb_choose _ = if (randbit(),randbit()) = (0b1,0b1) then 0b1 else 0b0

fun split_codebits M w codebits =
  if 5*w+length M <= length codebits then (take (5*w) codebits, drop (5*w) codebits)
                                     else ([]                 , codebits           )
  
fun bit2bool b = b=0b1
fun bool2bit b = if b then 0b1 else 0b0 

fun compose (f : 'b -> 'a) (g : 'c -> 'b) (v : 'c) : 'a = f (g v)

fun semicolon (g : 'c -> 'b) (f : 'b -> 'a) : ('c -> 'a) = compose f g

fun read_min_int m s
  = k where k = if j>=m then j 
                else semicolon (lam _ . print_strings ["pardon? at least "; show m; "\n"])
                               (lam _ . read_min_int m s)
                               ()
      where j = read_num s
    
fun int_sqrt n = i_s 0 n
                   where i_s k n = if k*k>=n then k else i_s (k+1) n 
  
fun histo buckets ns
  = match ns .
    + []   . rev buckets
    + n::_ . histo ((n,length pre)::buckets) post
                  where pre = takewhile sameas ns
                  where post = dropwhile sameas ns
                  where sameas = lam k . k=n (* this is (=n). I need that mechanism, whose name temporarily escapes me *)

fun histogram ns = histo [] (sort compare ns)

(* this is a histogram of evasions: see SystemAEB.qtp *)

fun histo2 buckets nes
  = match nes .
    + []       . rev buckets
    + (n,e)::_ . histo2 ((n,length es)::buckets) post
                 where es = filter (lam (_,e) . e) pre
                 where pre = takewhile sameas nes
                 where post = dropwhile sameas nes
                 where sameas = lam (k,_) . k=n

fun h2comp (n,e) (n',e') = compare n n'

fun histogram2 nes = histo2 [] (sort h2comp nes)

fun listsum ns = foldl (lam sum n . sum+n) 0 ns

fun listmin ns = foldl (lam sofar n . min sofar n) (hd ns) (tl ns)

fun packets rs (size:num) (bits:[bit]) : [[bit]]
  = match bits .
    + [] . rs
    + _  . packets (take size bits::rs) size (drop size bits)

fun hwc message keys i w : [bit] 
  = if w=0 || message=[] then [0b0] else
      hwc1 message
        where hwc1 bits = 
                match hps .
                + [hash] . hash
                + ps     . hwc1 (concat hps)
                  where hps = map (lam p . num2bits (bitand mask (key*bits2num p))) ps
                  where ps = packets [] size bits
        where key = nth keys i
        where size = 2*s
        where mask = bits2num (tabulate s (const 0b1)) (* 2^s-1 *)
        where s = ceiling ((w+1)/3*4+1)     (* odd, at least, and bigger than w *)
  
fun tagged keys i w message = (hwc message keys i w, message)
  
fun checkhash hks w (i,(h,m)) = hwc m hks i w = h
