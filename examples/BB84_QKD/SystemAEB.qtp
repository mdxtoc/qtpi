proc Experiment (M, w, hksAE, hksEB, cMin, nSigma, logA, logAE, logEB, logB) = 
  (new qcAE,qcEB,bscAE,bscEB,againAE,againEB)
  | Alice (M, w, hksAE, cMin, nSigma,qcAE,bscAE,againAE,logA) 
  | Eve   (w, hksAE, hksEB, qcAE,qcEB,bscAE,bscEB,againAE,againEB,logAE,logEB) 
  | Bob   (w, hksEB, qcEB,bscEB,againEB,logB)

proc System() = (let n = read_min_int 1 "length of message")
                (let w = read_min_int 0 "length of a hash key")
                (let cMin = read_min_int 0 "minimum number of checkbits")
                (let nSigma = read_min_int 0 "number of sigmas")
                (let k = read_min_int 1 "number of trials")
                (let verbose = read_bool "with commentary" "y" "n")
                Run (k, verbose, n, w, cMin, nSigma)
           
proc Run (k, verbose, n, w, cMin, nSigma) = 
  (let hks = tabulate 5 (lam _ . bits2num (randbits w)))
  Logger (k, 0, verbose, 0,  0, 
                         0,  0, 
                         [], [],
                         n, w, hks, hks, cMin, nSigma)

proc Logger (k, i, verbose, nAlice, nEve, 
                            nRepsA, nRepsB, 
                            ncAs, ncBs,
                            n, w, hksAE, hksEB, cMin, nSigma) =
  if i<k then out!if k<>1 then ["trial number "; show (i+1); 
                                if verbose then "\n" else " " fi]
                       else [] fi .
              out!if verbose then ["hash keys are (A<->E) "; show hksAE; 
                                              " (E<->B) "; show hksEB;
                                              "\n"] else [] fi .
              (let M = randbits n)
              out!if verbose then ["message is "; show M; "\n"] else [] fi .
              (new logA,logAE,logEB,logB,doneA,doneB,doneE)
              | Experiment (M, w, hksAE, hksEB, cMin, nSigma, logA, logAE, logEB, logB) 
              | LogAlice (0, verbose, logA, doneA)
              | LogBob (0, verbose, logB, doneB)
              | LogEve (verbose, logAE, logEB, doneE)
              | doneA?(q_intfseen, nbA, ncA, c_intfseenA, hkbsA, repsA)     .
                doneB?(ncB, messageB, c_intfseenB, hkbsB, repsB)           .
                doneE?(hkbsAE, (decodeE, messageE, _, hkbsEB, _))        .
                (let intfseen = q_intfseen || c_intfseenA || c_intfseenB)
                if not intfseen && hkbsA<>hkbsAE && hkbsAE<>[]
                then out!["whoops! different new hash keys A<->E ";
                                    show (packets [] w hkbsA); " ";
                                    show (packets [] w hkbsAE)
                                   ] . _0
                elif not intfseen && hkbsB<>hkbsEB && hkbsEB<>[]
                then out!["whoops! different new hash keys E<->B ";
                                    show (packets [] w hkbsEB); " ";
                                    show (packets [] w hkbsB)
                                   ] . _0
                else
                  (let evewins = decodeE && not intfseen && messageB=messageE && messageE=M)
                  out!if evewins then ["Eve wins -- "; show ncA; " check bits E->A; "; show ncB; " check bits B->E\n"]
                                            else []
                                 fi .
                  out!if i+1=k then [show nbA; " qbits"; if k=1 then "\n" else " per trial\n" fi]
                               else [] fi .
                  (let nAlice, nEve = if   intfseen then nAlice+1, nEve     (* Alice spotted Eve *)
                                      elif evewins  then nAlice  , nEve+1   (* Alice didn't spot Eve, and Eve saw the message *)
                                      else               nAlice  , nEve     (* somehow Eve was missed, but she didn't see the message *)
                                      fi
                  )
                  (let hkbsAE, hkbsEB = if intfseen || hkbsA=[] || hkbsB=[]
                                        then k, k where k = randbits (5*w)
                                        else hkbsA, hkbsB
                                        fi
                  )
                  (let hksAE, hksEB = map bits2num (packets [] w hkbsAE),
                                      map bits2num (packets [] w hkbsEB)
                  )
                  Logger (k, i+1, verbose, nAlice, nEve, 
                                           nRepsA+repsA, nRepsB+repsB, 
                                           ncA::ncAs, ncB::ncBs,
                                           n, w, hksAE, hksEB, cMin, nSigma)
                fi
         else (let nCorrupt = k-nAlice-nEve)
              out!["all done: "; 
                   show nEve;                " Eve's; ";
                   show nAlice;              " Alice's; ";
                   show nCorrupt;            " undetected corrupt messages; ";
                   show nRepsA;              " repetitions (Alice-Eve); ";
                   show nRepsB;              " repetitions (Eve-Bob); ";
                   "average check bits (Alice/Eve) "  ; show (listsum ncAs/k); 
                   "; minimum check bits (Alice/Eve) "; show (listmin ncAs); 
                   "; average check bits (Eve/Bob) "  ; show (listsum ncBs/k); 
                   "; minimum check bits (Eve/Bob) "  ; show (listmin ncBs); "\n";
                   "histogram of check-bit lengths (Alice/Eve) "; show (histogram ncAs); "\n";
                   "histogram of check-bit lengths (Eve/Bob) "; show (histogram ncBs); "\n"
                  ] . 
              _0 
  fi
