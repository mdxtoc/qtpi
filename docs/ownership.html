<h1>Static treatment of ownership of qbits -- Resource-checking a program</h1>
<p>My original inspiration was the ownership problem, triggered by a remark of Guillaume Poly's (he'd noticed that a treatment of qbit ownership was impossible in Microsoft's Q#). A process calculus like CQP seemed like it might provide a solution. Then I realised that the cloning problem is another side of the same coin, and therefore might also be treated at the same time.</p>
<p>The phrase <em>resource checking</em> harks back to my background in separation logic (I was there when ...). It was always something I wanted to do with heap programs, though I never knew how to do it accurately enough. (Others, of course, ...)</p>
<p>Qbits are the resource manipulated by quantum-protocol programs. Qtpi checks the correct use of those resources.</p>
<h2>The ownership problem</h2>
<p>Suppose <em>A</em> sends a qbit on a channel <em>c</em></p>
<pre><code>	A(c:^qbit) = (newq q) c!q. .. etc. A ..
</code></pre>
<p>and <em>B</em> receives it</p>
<pre><code>	B(c:^qbit) = c?(q1). .. etc. B ..
</code></pre>
<p>Suppose that we identify different named processes as happening on different machines in different places. Then surely in '<em>etc. A</em>', after it has sent the qbit elsewhere, <em>A</em> cannot do anything with <em>q</em>, like measure it, gate it or whatever. <em>B</em> in '<em>etc. B</em>', after it has received the qbit, clearly can play with <em>q1</em> exclusively: it <strong>owns</strong> it.</p>
<p>So it seems that it might be possible to use scoping to deal with ownership: in '<em>etc. A</em>', <em>q</em> could be treated as out of scope, whilst in '<em>etc. B</em>', <em>q1</em> is in scope. Bingo? You'd think so. Actually not: it's <strong>resourcing</strong>, not scoping, a dynamic property of a value, not a not a static property of a name.</p>
<p>But process calculus is so restricted -- e.g. only tail recursion -- that it is possible to run a symbolic execution of all paths through a process definition to check that qbits are handled properly. (There is a potential problem in qtpi since it allows conditional expressions and applications of library functions, but see below.)</p>
<h2>The cloning problem</h2>
<p>It is impossible to clone qbits. So a program should be incapable of making a copy of a qbit.</p>
<ol>
<li>
<p>How about splitting into two processes?</p>
<pre><code> 	A() = (newq q) (B(q) | C(q))

 	B(q1:qbit) = ...

 	C(q2:qbit) = ..
</code></pre>
<p>This has to be prohibited: <em>B</em> and <em>C</em> can't both exclusively inherit the same qbit.</p>
</li>
<li>
<p>How about going on as another process?</p>
<pre><code> 	A() = (newq q) B(q,q)

 	B(q1:qbit, q2:qbit) = ...
</code></pre>
<p><em>B</em> doesn't own two separate qbits.</p>
</li>
<li>
<p>How about sending the same qbit twice?</p>
<pre><code> 	A(c:^qbit*qbit) = (newq q) c!q,q . ...
 
 	B(c:^qbit*qbit) = c?(q1,q2). ...
</code></pre>
<p><em>B</em> only owns one qbit, not two.</p>
</li>
<li>
<p>How about a <em>let</em> binding?</p>
<pre><code> 	A() = (newq q) (let q'=q) ...
</code></pre>
<p><em>A</em> only creates one qbit to own.</p>
</li>
</ol>
<h2>Accounting problems</h2>
<p>If we want to check ownership we have to account for the use of qbits. This throws up some obvious problems.</p>
<ol>
<li>
<p>A conditional send?</p>
<pre><code> 	A(q1:qbit, q2:qbit, c:^qbit) = ... c!(if ... then q1 else q2 fi). ...
</code></pre>
<p>Which qbit has been sent away, and which does <em>A</em> own after the send?</p>
<p>(I 'solve' this problem by prohibiting it: see below.)</p>
</li>
<li>
<p>Values containing qbits?</p>
<pre><code> 	(newq q) (let n = q,q) ...
 	(newq q) (let qs = [q;q]) ... 
</code></pre>
<p>In the first example a single qbit has three names: <em>q</em>, <em>fst n</em> and <em>snd n</em>. In the second we have three names as well: <em>q</em>, <em>hd qs</em> and <em>hd (tl qs)</em>. But in each case only one qbit.</p>
<p>(This problem is easily handled: see below.)</p>
</li>
<li>
<p>Conditional cloning?</p>
<pre><code> 	a?(x) ... stuff using q1 and q2 ... 
 	+ 
 	b?(y) ... stuff using q2 and q3 ..
</code></pre>
<p>This program uses <em>q1</em>, <em>q2</em> and <em>q3</em>, and there's no cloning issue because only one of the arms is executed. But then</p>
<pre><code> 	(a?(x) ... stuff using q1 and q2... 
 	 + 
 	 b?(y) ... stuff using q2 and q3 ..
 	) 
 	| 
 	(if condition then ... stuff using q3 ... else ... stuff using q4 ... fi)
</code></pre>
<p>There <em>might</em> be a cloning violation, or there might be good reason that the <code>b?(y)</code> arm of the guarded sum never actually executes when <em>condition</em> is true.</p>
<p>(I don't suppose I can solve this problem. My algorithm will object to this program.)</p>
</li>
</ol>
<h2>Restrictions</h2>
<p>Qbits are big fragile things. They are measured, sent through gates, transmitted through channels. If a program makes, for example, a tuple of qbits it is actually making a tuple of qbit <em>indices</em>, an index being the way that an implementation identifies the qbits it manipulates.</p>
<ul>
<li>
<p><strong>No comparison of qbits, or values containing qbits</strong></p>
<p>Qbits aren't things you can compare. But you could compare indices ...</p>
<p>A qbit's index is private information for the implementation. In Qtpi it's currently a global integer. So if you ask whether two qbits are the same -- e.g.</p>
<pre><code>	if q1=q2 then ..
</code></pre>
<p>you either asking for something impossible (compare the actual qbits) or doing something naughty (exploiting the implementation of the language). Not allowed, either way. It just feels wrong.</p>
</li>
<li>
<p><strong>A channel is either <code>^qbit</code> or <code>^classical</code></strong></p>
<p>Protocol descriptions talk of processes sending qbits to each other and separately communicating information like basis and value over classical channels. So I require that a channel either carries single qbits, or it carries values which don't include qbits. Easy to check.</p>
</li>
<li>
<p><strong>Function applications can't deliver qbits, or values containing qbits</strong></p>
<p>You and I know what we mean by <em>hd</em> and <em>tl</em>, by <em>fst</em> and <em>snd</em>. But these are library functions: the interpreter doesn't understand them. Even though it knows from type information that given  <em>qs: qbit list</em>, <em>hd qs</em> will deliver a qbit, it doesn't know which one of the list it will get. And even we don't know much about <em>hd (rev qs)</em>.</p>
<p>Pattern matching softens the blow of this restriction.</p>
</li>
<li>
<p><strong>Match expressions can't take apart argument lists of qbits</strong></p>
<p>This is a stunner. A process can take an argument which is a list of qbits (or a list of values containing qbits, same difference). Match <em>processes</em> can look at the list and branch according to its contents,and that's a nice tree-shaped execution structure, so that's ok. Match <em>expressions</em> cause too many problems, especially if you try to match against a match expression ... (etc.), because you get a dag-shaped execution diagram.</p>
</li>
</ul>
<p>The first two restrictions make the resource-checking algorithm simpler. The third is essential.I haven't imposed a restriction which entirely prevents tuples and lists containing qbits since it appears to be unnecessary and would be very restrictive.</p>
<p>It might seem reasonable to ban qbit-valued conditional and match expressions: they decrease the accuracy of resource-checking and can cause spurious cloning errors. A ban remains a possibility. Some uses are outlawed, such as</p>
<pre><code>	c ! if a=0 then q1 else q2 fi
</code></pre>
<p>Others are harmless, such as</p>
<pre><code>	if a=0 then q1 else q2 fi &gt;&gt; _H
</code></pre>
<p>Match expressions are equally problematic, but equally to be permitted (for the time being).</p>
<h2>A Resource-checking Algorithm</h2>
<p>Qbits in existence when a process starts can be delivered via its arguments. We assume (a non-cloning invariant) that distinct parameters name distinct bundles of resource. We number the qbits we can see in single qbit parameters or in tuples. We don't do much with lists of qbits, but we number them when they appear in match patterns.</p>
<p>When we read a qbit with <em>c</em>?(<em>q</em>) we know from the invariant that it is distinct from anything we own. So we give it a new number. It might be an old sent-away qbit coming back, but that's ok: treating it as new won't lead us astray.</p>
<p>Thus we can work out how names describe resource bundles. 'Let' bindings add to the fun, but don't create qbits. 'Newq' bindings do create named qbits, which we number. Reads add named qbits. Using a mapping from names to resource (an 'environment') we can calculate what resource an expression uses. We check that process Pars (<em>P</em>|<em>P</em>|...|<em>P</em>), process calls <em>N</em>(<em>E</em>,<em>E</em>,...,<em>E</em>) and writes <em>c</em>!<em>E</em>,<em>E</em>,...,<em>E</em> use disjoint resources in their components, preserving the non-cloning invariant.</p>
<p>To handle the ownership problem, a symbolic execution -- an abstract interpretation, I'm told -- keeps track, in a numerically-indexed 'state', of which qbits are sent away in writes.  If an expression uses a sent-away qbit then it's a resourcing error.</p>
<p>And that's it: one pass through a process definition gives us a comprehensive check on ownership and cloning.</p>
<p>When process definitions start to use parameterised types like <em>'a list</em>, we shall have to check their instantiations rather than their definitions. But that is for the future. It won't be a problem: we only have to make at most one process-check per call of a process.</p>
<h2>Hubris, Nemesis?</h2>
<p>No free lunch has arrived. A symbolic execution is not a perfect solution. But it appears to be sound -- if it says a program is ok, it is ok -- even though it is evidently incomplete -- there are valid programs to which it will object.</p>
<p>Inaccuracies arise with conditional expressions and guarded sums. Conditional expressions have been noted already: they are assessed as using the resources of both arms, though an execution uses only one arm at a time. They may not be a problem in principle, since every program using a qbit-valued conditional expression could be rewritten to use a conditional process.</p>
<p>There remains a problem. The resources used by a conditional process are assessed as the union of the resources used by each of its arms. The resources used by a guarded sum are assessed as the union of the resources of all its arms. Then a Process par (<em>P</em>|<em>P</em>|...|<em>P</em>) of guarded sums and/or conditional processes may seem cause more cloning objections than an actual execution could actually exploit. But this will be over-caution: incompleteness, not unsoundness.</p>
<p>There may be new problems when I allow pattern-matching and encounter programs that use lists of qbits (which some protocols may need). There will certainly be complications, but I doubt there will be novel incompleteness.</p>
<p>Quantum protocols are perhaps computationally rather simple. I have hope that a simple treatment will be useful, even though it sometimes complains when it shouldn't, provided it is always right when it approves.</p>
