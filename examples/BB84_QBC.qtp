
proc Alice(n:int, r:^bit, qB, vB, report) = 
    r?(basis) .
    (let vs = randbits n)
    report![basis] .
    report!vs .
    (new done) (  AliceSendBits (vs,basis,qB,done)
                | done?(_) . vB!basis,vs . _0
               )

(* send bits encoded in basis down channel qB *)
proc AliceSendBits (vs,basis,qB,done) =   
    match vs .
        []    . done!() . _0
    <+> v::vs . (newq q = match basis,v .
                              0b0,0b0 . |0> 
                          <+> 0b0,0b1 . |1> 
                          <+> 0b1,0b0 . |+> 
                          <+> 0b1,0b1 . |-> 
                          hctam
                )
                qB!q.
                AliceSendBits(vs,basis,qB,done)
    hctam

proc Bob(n:int, r:^bit, qA, vA, report) = 
  (new done,verified) 
  (  BobReceive(n,[],qA,r,done)
   | done?(bvs) . 
     report!(map fst bvs) .
     report!(map snd bvs) .
     r?(guess) .
     report![guess] .
     vA?(basis:bit, vs:bit list) .
     BobVerify (basis,vs,bvs,verified)
   | verified?(honest) .
     report![if honest then 0b1 else 0b0 fi] .
     _0
  )

(* receive qbits down qA, measure them, record the results *)
proc BobReceive(n,bvs,qA,r,done) =
    if n=0 then done!rev bvs . _0
    else qA?(q).
         r?(basis).
         q =?[if basis=0b1 then _H else _I fi] (value) .
         dispose!q .
         BobReceive(n-1,(basis,value)::bvs,qA,r,done)
    fi

(* verify Alice's story *)
proc BobVerify (basis,vs,bvs,done) =
  match vs, bvs .
      []   , []           . Honest (done)
  <+> []   , _            . Liar (done)
  <+> _    , []           . Liar (done)
  <+> v::vs, (b,v')::bvs  . if b=basis && v<>v' 
                              then Liar (done)
                              else BobVerify(basis,vs,bvs,done)
                            fi
  hctam
  
proc Liar   (done) = done!false . _0
proc Honest (done) = done!true  . _0

(* a source of random bits. A bit of a joke, but relatively harmless *)
proc Random(q:qbit, r:^bit) = q>>_H . q=?(v) . r!v . Random(q,r)

proc System() = (let k = read_int "number of trials")
           (let n = read_int "number of qbits")
           (let verbose = read_bool "with commentary" "y" "n")
           (new r)
           (   Report (k, verbose, n, r)
            | (newq q = |0>) Random(q,r)
           )
           
proc Report (k, verbose, n, r) = Control (k, 0, verbose, 0, 0, 0, n, r)

proc Control (k, i, verbose, nA, nB, nH, n, r) =
  if k=i then 
    {print_strings ["\n\nAll over: "; string_of_value nA; " Alice; ";
                                      string_of_value nB; " Bob; ";
                                      string_of_value nH; " honest\n"
                   ]
    } . 
    _0
  else
    {print_strings ["trial number "; string_of_value (i+1);
                    if verbose then ": " else "\n" fi
                   ]
    } .
    (new qc, vc, reportA, reportB)
    (  Alice(n,r,qc,vc,reportA) 
     | Bob(n,r,qc,vc,reportB)
     | reportA?(bases) .
       (let basis = hd bases)
       reportA?(vs) .
       {if verbose then print_strings ["Alice chose basis "; string_of_value basis;
                                       " and values "; string_of_value vs; "\n"
                                      ]
        else ()
        fi
       } .
       reportB?(bs) .
       reportB?(vs) .
       (let bvs = zip bs vs)
       reportB?(guesses) .
       (let guess = hd guesses)
       {if verbose then print_strings ["Bob received "; string_of_value bvs;
                                       " and guessed "; string_of_value guess; "\n"
                                      ]
        else ()
        fi
       } .
       reportB?(honests) .
       (let honest = hd honests = 0b1)
       {print_strings ["Bob says Alice ";
                       if honest then "was honest" else "lied" fi;
                       "\n"
                      ]} .
       (let nH = if honest then nH+1 else nH fi)
       (let nA,nB = if guess=basis then nA,nB+1 else nA+1,nB fi)
       {print_string if guess=basis then "Bob wins\n"
                                    else "Alice wins\n"
                     fi
       } . 
       Control (k, i+1, verbose, nA, nB, nH, n, r)
    )
  fi
