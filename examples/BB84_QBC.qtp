
proc Alice(n:int, r:^bit, qB, vB, log) = 
    r?(basis) .
    (let vs = randbits n)
    log![basis] .
    log!vs .
    (new done) 
    | AliceSendBits (vs,basis,qB,done)
    | done?(_) . vB!basis,vs . _0

(* send values encoded in [basis] as qbits down channel [qB] *)
proc AliceSendBits (vs,basis,qB,done) =   
    match vs .
    + []    . done!() . _0
    + v::vs . (newq q = match basis,v .
                        + 0b0,0b0 . |0> 
                        + 0b0,0b1 . |1> 
                        + 0b1,0b0 . |+> 
                        + 0b1,0b1 . |->
              )
              qB!q.
              AliceSendBits(vs,basis,qB,done)

proc Bob(n:int, r:^bit, qA, vA, log) = 
  (new done,verified) 
  | BobReceive(n,[],qA,r,done)
  | done?(bvs) . 
    log!(map fst bvs) .
    log!(map snd bvs) .
    r?(guess) .
    log![guess] .
    vA?(basis:bit, vs:bit list) .
    BobVerify (basis,vs,bvs,verified)
  | verified?(honest) .
    log![if honest then 0b1 else 0b0 fi] .
    _0

(* receive qbits down qA, measure them, record the results *)
proc BobReceive(n,bvs,qA,r,done) =
    if n=0 then done!rev bvs . _0
    else qA?(q).
         r?(basis).
         q =?[if basis=0b1 then _H else _I fi] (value) .
         dispose!q .
         BobReceive(n-1,(basis,value)::bvs,qA,r,done)
    fi

(* verify Alice's story *)
proc BobVerify (basis,vs,bvs,done) =
  match vs, bvs .
  + []   , []           . Honest (done)
  + []   , _            . Liar (done)
  + _    , []           . Liar (done)
  + v::vs, (b,v')::bvs  . if b=basis && v<>v' 
                            then Liar (done)
                            else BobVerify(basis,vs,bvs,done)
                          fi
  
proc Liar   (done) = done!false . _0
proc Honest (done) = done!true  . _0

(* a source of random bits. A bit of a joke, but relatively harmless *)
proc Random(q:qbit, r:^bit) = q>>_H . q=?(v) . r!v . Random(q,r)

proc System() = (let k = read_int "number of trials")
           (let n = read_int "number of qbits")
           (let verbose = read_bool "with commentary" "y" "n")
           (new r)
           | Run (k, verbose, n, r)
           | (newq q = |0>) Random(q,r)
           
proc Run (k, verbose, n, r) = Control (k, 0, verbose, 0, 0, 0, n, r)

proc Control (k, i, verbose, nA, nB, nH, n, r) =
  if k=i then 
    {print_strings ["\n\nAll over: "; show nA; " Alice; ";
                                      show nB; " Bob; ";
                                      show nH; " honest\n"
                   ]
    } . 
    _0
  else
    {print_strings ["trial number "; show (i+1);
                    if verbose then ": " else "\n" fi
                   ]
    } .
    (new qc, vc, logA, logB)
    | Alice(n,r,qc,vc,logA) 
    | Bob(n,r,qc,vc,logB)
    | logA?(bases) .
      (let basis = hd bases)
      logA?(vs) .
      {if verbose then print_strings ["Alice chose basis "; show basis;
                                      " and values "; show vs; "\n"
                                     ]
       else ()
       fi
      } .
      logB?(bs) .
      logB?(vs) .
      (let bvs = zip bs vs)
      logB?(guesses) .
      (let guess = hd guesses)
      {if verbose then print_strings ["Bob received "; show bvs;
                                      " and guessed "; show guess; "\n"
                                     ]
       else ()
       fi
      } .
      logB?(honests) .
      (let honest = hd honests = 0b1)
      {print_strings ["Bob says Alice ";
                      if honest then "was honest" else "lied" fi;
                      "\n"
                     ]} .
      (let nH = if honest then nH+1 else nH fi)
      (let nA,nB = if guess=basis then nA,nB+1 else nA+1,nB fi)
      {print_string  if guess=basis then "Bob wins\n"
                                   else "Alice wins\n"
                    fi
      } . 
      Control (k, i+1, verbose, nA, nB, nH, n, r)
  fi
