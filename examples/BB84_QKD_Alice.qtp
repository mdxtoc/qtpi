proc Alice(n:int, qB, bsB, report) = 
  (new chosen) 
  (  Choose (n,[],chosen)
   | chosen?(bvs) . 
     report!map fst bvs .
     report!map snd bvs .
     (new sent)
     (  SendBits (bvs, qB, sent)
      | sent?(_) .
        Negotiate (bvs, bsB, report)
     )
  )
  
(* choose n basis,bit pairs -- this could all be done with Random *)
proc Choose(n, bvs, chosen) =
    (let bs = randbits n) (let vs = randbits n) chosen!zip bs vs . _0

(* send encoded bits down channel qB *)
proc SendBits (bvs,qB,sent) =   
    match bvs .
        []         . sent!() . _0
    <+> (b,v)::bvs . (newq q = match b,v .
                                   0b0,0b0 . |0> 
                               <+> 0b0,0b1 . |1> 
                               <+> 0b1,0b0 . |+> 
                               <+> 0b1,0b1 . |-> 
                               hctam
                     )
                     qB!q.
                     SendBits(bvs,qB,sent)
    hctam

proc Negotiate (bvs,bsB,report) =
    bsB!map fst bvs . (* send him my bases *)
    bsB?(bBs)       . (* receive his bases *)
    report!bBs      .
    (new reconciled) 
    (  Reconcile (bBs, bvs, [], reconciled)
     | reconciled?(rvs)  . (* rvs are the values we should agree upon *)
       report!rvs        . 
       bsB?(mask)        . (* A mask of rvs: 0b1 if sampled *)
       report!mask       .
       bsB?(sample)      . (* the corresponding bits from vs *)
       report!sample     .
       (let b = test_checkbits mask sample rvs)
       (new filtered)
       (let code = masked_filter mask rvs [])
       report!if b then 0b1 else 0b0 fi::code . 
       bsB?(codedvs)     .
       report!codedvs    .
       report!(xor_mask code codedvs) .
       _0
    )
