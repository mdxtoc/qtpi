(* given a random qbit (a|0>+b|1>), this may terminate with
   either a|0>+b|1> or a|0>-b|1>. Interesting, eh? Only 
   'really' works if the initial qbit is |0> 
   -- i.e. an unfair coin IMHO.
 *)

proc P(fromQ:^qbit, toQ:^qbit, report) =     fromQ?(y) . toQ!y .         report!() . _0
                                         <+> fromQ?(y) . y>>_X . 
                                             {print_string "with a flip; "}. 
                                             toQ!y .                     report!()  . _0
                     
proc Q(q: qbit, toP:^qbit, fromP:^qbit, report) = 
  {print_string "initially "} . {print_qbit q} . {print_string "; "} .
  q>>_H . toP!q . fromP?(q') . q'>>_H . 
  {print_string "finally "} . {print_qbit q'} . {print_string "\n"} .
  report!() . _0 

proc System() = (let k = read_int "number of trials")
                (let sb = read_string "initial state (0,1,+,-)")
                (let bv = match sb .
                      "0" . |0> 
                  <+> "1" . |1> 
                  <+> "+" . |+>
                  <+> "-" . |->
                  <+> _   . abandon "bad initial state"
                  hctam
                )
                (let verbose = match read_string "with commentary (y/n)" .
                                   "y" . true
                               <+> "n" . false
                               <+> _   . abandon "pardon?"
                               hctam
                )
           {print_string "See output for results -- can print but can't examine qbit state\n"} .
           Controller (k, bv, verbose)

proc Controller (k, bv, verbose) = Report (k, bv, verbose, 0)

proc Report (k, bv, verbose, i) = 
  if i=k then {print_strings [string_of_value i; " trials\n"]} . _0
  else
    (newq q = bv) 
    (new s:^qbit, r:^qbit)
    (new reportP, reportQ)
    (  P(s,r,reportP) 
     | Q(q,s,r,reportQ) 
     | reportP?(_) .
       reportQ?(_) .
       Report (k, bv, verbose, i+1)
    )
  fi
