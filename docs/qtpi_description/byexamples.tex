% !TEX root = ./qtpi_description.tex

\chapter{Some worked examples}
\chaplabel{byexamples}

\section{An example using gates and interaction}

\var{Cin,Sum,Cout}
\citep{quantumfulladderquantumdaily} is a web page showing how to build a quantum version of a single-bit slice of a hardware full-adder: something which takes two bits and a carry bit from the previous slice, and produces a single-bit sum plus a carry for the next slice. For each of the inputs and outputs \zero{} means the bit-value 0 and \one{} means 1, though of course, being qubits, they can be in superpositions of those values and they can be entangled (we'll come to that). \Figref{Cogginsfulladdercircuit} shows the quantum machinery. The original has an extra X gate, which isn't needed, and some measurement steps which I've omitted (but I'll get to measurement eventually).

\begin{figure}
\centering
\vspace{3pt}
\mbox{\Qcircuit @C=1em @R=.7em {
\lstick{A\ \ket{\alpha}}      & \ctrl{3}       & \qw            & \qw            & \ctrl{1} & \ctrl{2} & \qw      & \rstick{} 			  \qw \\
\lstick{B\ \ket{\beta}}       & \qw            & \ctrl{2}       & \qw            & \ctrl{3} & \qw      & \ctrl{1} & \rstick{}  			  \qw \\
\lstick{\<Cin>\ \ket{\gamma}} & \qw            & \qw            & \ctrl{1}       & \qw      & \ctrl{2} & \ctrl{2} & \rstick{} 			  \qw \\
\lstick{\<Sum>\ \ket{0}}      & \targ          & \targ          & \targ          & \qw      & \qw      & \qw      & \rstick{\ket{\phi}}   \qw \\
\lstick{\<Cout>\ \ket{0}}     & \qw            & \qw            & \qw	         & \targ    & \targ    & \targ    & \rstick{\ket{\psi}}   \qw
     }}
\vspace{3pt}
\caption{A quantum full adder, adapted from \citep{quantumfulladderquantumdaily}}
\figlabel{Cogginsfulladdercircuit}
\end{figure}
The diagram, read left-to-right, takes A, B and Cin, in states \bv{\alpha}, \bv{\beta} and \bv{\gamma}, as inputs. Sum and Cout each start in state \zero{} but finish in states \ket{\phi} and \ket{\psi}. Suppose for a moment that \bv{\alpha}, \bv{\beta} and \bv{\gamma} are each \zero{} or \one{}. The first three gates each combine one of the inputs with Sum using CNot which will flip Sum \zero{}$<->$\one{} if the input qubit (A, B or Cin) is \one{}, or leave it unchanged if the input is \zero{}. So Sum can be flipped zero, one, two or three times, becoming respectively \zero{} (meaning 0), \one{} (meaning 1), \zero{} or \one{} respectively. That's definitely what a half-adder should do. The next three gates are Toffoli gates: flip the target qubit (Cout) if \emph{both} inputs are \one{}. So again, supposing A, B and Cin are each \zero{} or \one{}, Cout gets flipped zero times if they are all \zero{}, once if there are two \one{}s, and three times if they are all \one{}, becoming respectively \zero{}, \one{} and \one{}. That's also what a full adder should do. And it leaves A, B and Cin unchanged whatever they were: that's what a full adder should do.

\mvb{\Cogginszerooneone}
proc System () =
  . (newq qA=|0>, qB=|1>, qCin=|1>) 
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  .
\end{myverbbox}
\begin{figure}
\centering
\Cogginszerooneone
\caption{A simulation of \figref{Cogginsfulladdercircuit}, with \bv{\alpha}=\zero{}, \bv{\beta}=\one{} and \bv{\gamma}=\one{}}
\figlabel{Cogginszerooneone}
\end{figure}

\Figref{Cogginszerooneone} is a Qtpi program that simulates the circuit from \figref{Cogginsfulladdercircuit} with a particular starting state for each of the input qubits, in each case either \zero{} or \one{}. In qtpi's process notation, following the pi calculus, declarations are bracketed and process steps -- such as quantum gating, quantum measurement, and message passing -- are separated by dots rather than semicolons. Qtpi lets you use extra dots if you wish, so I like to put a dot at the start of each line because it keeps things aligned and stops me forgetting to include a dot.  Processes are introduced in groups, starting with the word `proc'. Every qtpi program must have a start-up process called System which takes no arguments and sets up the simulation. In this example the set-up only has to create five qubits and define their initial states, and then simulates the calculations in the diagram. It doesn't produce any output yet. 

The first line of System, with a \verbtt{newq} declaration, creates three input qubits, in which each qubit name starts with a lower-case `q' because there's an informal qtpi convention that variables should start with a lower-case letter. The second line creates the qubits which are to be used for output. The next two lines are the six steps of the diagram: \verbtt{q,...,q>>G} puts qubit(s) \verbtt{q,...,q} through gate G; this program uses CNot and T (for Toffoli), which are gates from qtpi's library. The process terminates on its fifth line with a blank step.

We can put this program in a file called \verbtt{manualCoggins1.qtp}, and if we run it using the -trace switch
\begin{quote}
\verbtt{qtpi manualCoggins.qtp -trace}
\end{quote}
we can see what the program does. \Figref{Cogginszerooneonetrace} shows the trace. The first five lines record the setup of the qubits: qubit \#0 is qA, \#1 is qB, \#2 is qCin, \#3 is qSum, and \#4 is qCout. The fifth line is the first gating step, which doesn't flip qSum, because qA is \zero{}; the sixth and seventh each flip qSum because qB and qCin are each \one{}. The next two lines don't flip qCout, because qA and qB aren't both \one{}, and neither are qA and qCin; the last line does flip qCout because qB and qCin are both \one{}. So in classical terms, from inputs 0 and 1 with carry-in 1 it's produced sum 0 and carry-out 1, as a full adder should. 

\begin{mdframed}[style=exampledefault,frametitle={}] 
Note: tracing isn't part of the programming language, because you can't do it in real life. There is absolutely \emph{no way} to discover the state of a real-life qubit. The implementation of qtpi can peek, because it's a simulation, but you can't write a program that peeks. See also \secref{printingqubits} below.
\end{mdframed} 

\mvb{\Cogginszerooneonetrace}
System creates #0:|0⟩

System creates #1:|1⟩

System creates #2:|1⟩

System creates #3:|0⟩

System creates #4:|0⟩

System (#0:|0⟩,#3:|0⟩) >> Cnot; result (#0:|0⟩,#3:|0⟩)

System (#1:|1⟩,#3:|0⟩) >> Cnot; result (#1:|1⟩,#3:|1⟩)

System (#2:|1⟩,#3:|1⟩) >> Cnot; result (#2:|1⟩,#3:|0⟩)

System (#0:|0⟩,#1:|1⟩,#4:|0⟩) >> T; result (#0:|0⟩,#1:|1⟩,#4:|0⟩)

System (#0:|0⟩,#2:|1⟩,#4:|0⟩) >> T; result (#0:|0⟩,#2:|1⟩,#4:|0⟩)

System (#1:|1⟩,#2:|1⟩,#4:|0⟩) >> T; result (#1:|1⟩,#2:|1⟩,#4:|1⟩)
\end{myverbbox}%can't be a macro
\begin{figure}
\centering
\Cogginszerooneonetrace
\caption{Trace of the full adder, with starting qubits \zero, \one{} and \one{}}
\figlabel{Cogginszerooneonetrace}
\end{figure}

So far, so simple. But qtpi is a programming language, and you can use input functions to control what a program does (we'll come to output functions in just a moment). A more useful version of the full-adder program is shown in \figref{Cogginswithinput}. The istate function takes a prompt string and calls read\_alternative, which takes the prompt string plus a list of response/result pairs and delivers the result corresponding to the user's response; in this program it asks the user to type 0 or 1 and returns a ket which is correspondingly either \zero{} or \one{}. The three calls of istate in System initialise the three inputs, and the rest of the program is unchanged. That makes it easy to try out sample sums of classical values: \figref{Cogginszerooneonetrace} shows one example and you'll see, if you try it, that it always gets the right answers according to the trace. 

\mvb{\Cogginswithinput}
fun istate x = 
  read_alternative x "," [("0",|0>); ("1",|1>)]

proc System () =
  .(newq qA   = istate "qA", 
         qB   = istate "qB",
         qCin = istate "qCin").
  
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  . 
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinput
\caption{A full adder with user input, choosing classical-simulating values}
\figlabel{Cogginswithinput}
\end{figure}

\mvb{\Cogginswithinputresult}
qA (0,1)? 1
qB (0,1)? 1
qCin (0,1)? 1

Event Trace:

System creates #0:|1⟩

System creates #1:|1⟩

System creates #2:|1⟩

System creates #3:|0⟩

System creates #4:|0⟩

System (#0:|1⟩,#3:|0⟩) >> Cnot; result (#0:|1⟩,#3:|1⟩)

System (#1:|1⟩,#3:|1⟩) >> Cnot; result (#1:|1⟩,#3:|0⟩)

System (#2:|1⟩,#3:|0⟩) >> Cnot; result (#2:|1⟩,#3:|1⟩)

System (#0:|1⟩,#1:|1⟩,#4:|0⟩) >> T; result (#0:|1⟩,#1:|1⟩,#4:|1⟩)

System (#0:|1⟩,#2:|1⟩,#4:|1⟩) >> T; result (#0:|1⟩,#2:|1⟩,#4:|0⟩)

System (#1:|1⟩,#2:|1⟩,#4:|0⟩) >> T; result (#1:|1⟩,#2:|1⟩,#4:|1⟩)
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinputresult
\caption{Full-adder simulation trace with classical-simulating input}
\figlabel{Cogginswithinputresult}
\end{figure}

\subsection{Printing values, including qubit states}
\seclabel{printingqubits}

So far the examples have shown the effect of a simulation by generating a trace. But that's not always a good idea, especially with examples that generate a very long trace. If we could print out the final values of Sum and Cout, we could make a more compact output. But the solution is peculiar because real-world qubits are peculiar. 

First of all, output is by sending values down channels. There's a channel `out' which takes a list of strings, and prints them out one after the other. There's a special pseudo-function `show' which converts any classical value to a string, and that makes it easy to print classical stuff out.\footnote{`show' is borrowed from Miranda. It's a pseudo-function because its result depends on the type of its input. So, just as in Miranda, it can't be used without an argument.} But `show' for a qubit argument just gives ``\textless{}qubit\textgreater{}'' -- i.e. it doesn't peek at the value, like the trace does. That's unhelpful, but deliberately so.

%The next-to-last line of the program outputs the final states of the qCout and qSum qubits, down the channels out (which takes lists of strings) and outq (which takes the special `qstate' value that encodes the state of a qubit).\footnote{Qtpi has to be very careful about qubit values. You can send a classical value down the `out' channel to print it, and it's cloned just as it would be in a classical assignment: sending the value doesn't throw it away. But if a qubit is sent down a channel it will be lost: not what we intend. Qtpi's solution is to use the special function `qval' to peek at a qubit's value, and to output the result. Note first that `qval' has no real-world equivalent, because you can't ever ever ever tell what a qubit's value is. And because of \emph{that}, the result of `qval' can't be processed in a Qtpi program other than to send it down a channel.} The `\verbtt{ch!E}' step sends the value of the expression \verbtt{E} down the channel \verbtt{ch}. Channels are strongly typed: `\verbtt{out}' accepts lists of strings which it prints out; `\verbtt{outq}' accepts a single `\verbtt{qstate}' value and prints it out, and `\verbtt{qval q}' delivers such a value. So the `\verbtt{outq!qval q}' step prints out the state of a qubit without revealing it to the program because there's nothing a qtpi program can do to interrogate a \verbtt{qstate}. The last line terminates the process with a blank step. 
In the real world it is impossible to peek at the value of a qubit, and there is no way to compare the values of two qubits. Not `nobody knows how', but \emph{literally impossible} according to quantum mechanics. So qtpi doesn't allow a program to directly compare qubits, in order to keep simulations as real as possible. \emph{But}, if a simulation could peek at the value of qubit X and peek again at qubit Y it could do the impossible by comparing the peeks. That can't be allowed, and there are two possible solutions: either no peeking, or no comparing the peeks. Qtpi takes the second alternative: a simulation can peek, generating a special result of type `qstate', but it can do \emph{absolutely nothing} with a qstate value, except send it down the special `outq' channel to be printed out. 

\mvb{\Cogginswithouput}
fun istate x = 
  read_alternative x "," [("0",|0>); ("1",|1>)]

proc System () =
  .(newq qA   = istate "qA", 
         qB   = istate "qB",
         qCin = istate "qCin").
  
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  . out!["qSum="] . outq!showq qSum . out!["; qCout="] . outq!showq qCout .  out!["\n"] 

  . 
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithouput
\caption{A full adder with user input and output of results}
\figlabel{Cogginswithouput}
\end{figure}

\mvb{\Cogginswithoutputresult}
qA (0,1,+,-)? 1
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 1
qSum=#3:|1⟩; qCout=#4:|1⟩
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithoutputresult
\caption{Full-adder simulation with printed results}
\figlabel{Cogginswithoutputresult}
\end{figure}

\Figref{Cogginswithouput} shows the program with some output steps: otherwise it's unchanged from \figref{Cogginswithinput}. It prints the names of the result qubits, peeks at their values and prints them out. The output construction is peculiar, but that's because it has to be.

\subsection{Addition with non-classical inputs}

What's interesting about the full adder is that it can work with quantum superpositions as input. If we modify the read\_alternative call in the istate function to read
\mvb{\inputwithplusminus}
  read_alternative x "," [("0",|0>); ("1",|1>); ("+",|+>); ("-",|->)]
\end{myverbbox} %can't be a macro
\begin{quote}
\inputwithplusminus
\end{quote}
then we can deal with inputs which are well-known superpositions.

If we start, for example, with qA=$\plus{}=\frac{1}{\sqrt2}(\zero+\one)$, an equal-probability superposition of \zero{} and \one{}, but we make qB=\one{} and qCin=\zero{}, we discover that the outputs are not a simple classical-simulating \zero{} or \one{}, but instead a three-way entangled superposition, as shown in \figref{Cogginswithinputplusout}. The states of qSum and Cout are a multi-qubit state combining the states of \#0, \#3 and \#4 (qA, qSum, qCout). That state is an equal-probability superposition of \zeroonezero{} or \onezeroone{}, with probability $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$ in each case. 

Notice that you can read this superposition as a superposition of possible classical inputs and corresponding classical answers. If \#0 (qA) is \zero{}, then \#3 (qSum) has to be \one{} and \#4 (qCout) \zero{}; if \#0 is \one{}, then \#3 has to be \zero{} and \#4 \one{}. Given that qB is \one{}, those are the two possible correct answers.

If we turn tracing on we can see how all this arises in \figref{Cogginswithinputplustrace}\footnote{To produce this trace I used \verbtt{-trace -gatingsimplifies true} which asks for a trace but also asks that unnecessarily large multi-qubit states are simplified after each gating step. Qtpi doesn't do that sort of simplification by default.}. There's quite a lot in there: it will take some unpicking.
\mvb{\Cogginswithinputplusout}
qA (0,1,+,-)? +
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 0
qSum=#3:[#0;#3;#4]1/√2(|010⟩+|101⟩); qCout=#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinputplusout
\caption{Full-adder input superposition produces entangled outputs}
\figlabel{Cogginswithinputplusout}
\end{figure}
\mvb{\Cogginswithinputplustrace}
System creates #0:1/√2(|0⟩+|1⟩)

System creates #1:|1⟩

System creates #2:|0⟩

System creates #3:|0⟩

System creates #4:|0⟩

System (#0:1/√2(|0⟩+|1⟩),#3:|0⟩) >> Cnot;  
      result (#0:[#0;#3]1/√2(|00⟩+|11⟩),#3=#0)

System (#1:|1⟩,#3:[#0;#3]1/√2(|00⟩+|11⟩)) >> Cnot; 
      result (#1:|1⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩))

System (#2:|0⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩)) >> Cnot;  
      result (#2:|0⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩))

System (#0:[#0;#3]1/√2(|01⟩+|10⟩),#1:|1⟩,#4:|0⟩) >> T;  
      result (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#1:|1⟩,#4=#0)

System (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#2:|0⟩,#4=#0) >> T;  
      result (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#2:|0⟩,#4=#0)

System (#1:|1⟩,#2:|0⟩,#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)) >> T;  
      result (#1:|1⟩,#2:|0⟩,#4:[#0;#3;#4]1/√2(|010⟩+|101⟩))
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinputplustrace
\caption{How the full-adder entanglement happens}
\figlabel{Cogginswithinputplustrace}
\end{figure}

\subsection{Entanglement in the full-adder simulation}

The first CNot line in \figref{Cogginswithinputplustrace} entangles qubits \#0 and \#3 (qA and qSum). It's inevitable: the probability that qA is \zero{} is $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$, so with that probability both qubits are \zero{}; with the same probability qA is \one{}, qSum is flipped and both qubits are \one{}.\footnote{Whether or not that explanation matches physical reality, that's the way the matrix arithmetic works. It's possible that quantum reality is wierder than quantum computation says it is.} That entanglement, one of the famous Bell states, can't be separated unless one of the qubits is measured.

The second CNot line flips qSum, because qB in this example is \one{}; technically the result is a three-qubit state combining \#0, \#1 and \#3 as $\frac{1}{\sqrt2}(\zerooneone+\oneonezero)$, but because \#1 (qB) is \one{} in both the equal-probability alternatives it's reasonable to separate it out to give the result shown, \#1 listed separately from the entanglement of \#0 and \#3. The new entanglement, $\frac{1}{\sqrt2}(\zeroone+\onezero)$, is another of the Bell states, and also inseparable.

The third CNot line doesn't flip qSum, so no change.

The first Toffoli line involves qubit \#0, which is entangled with \#3, qubit \#2 and qubit \#4. With probability $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$ qubits 0 and 3 are \zeroone, which doesn't flip qubit \#4; with the same probability they are \onezero{}, which does. So we get the \#0, \#3, \#4 entanglement listed.

The second two Toffoli lines don't do any flips, so no change. 

\subsubsection{.. and its calculations}

The CNot gate is 4$\times$4: it operates on a 4-amplitude state, i.e. on two qubits. The second and third CNot lines in \figref{Cogginswithinputplustrace} ask it to operate on three qubits, which is an 8-amplitude state. Consider, for example, the second CNot step, taking qB \#1 as its source qubit and \#3 as its target. \#3 is entangled with \#0, which has nothing to do with the CNot, but has to be included nevertheless, so 3 bits to be processed. The standard quantum computation solution to this situation is as follows:
\begin{enumerate*}
\item combine the source qubit \#1 and the entanglement \#0 and \#3 with tensor multiplication, giving the combined state of qubits  \#1, \#0 and \#3 as $\frac{1}{\sqrt2}(\onezerozero+\oneoneone)$; 
\item manipulate that state to show the qubits in the order \#1, \#3, \#0 as $\frac{1}{\sqrt2}(\onezerozero+\oneoneone)$ (looks the same but isn't, because the qubits read differently);
\item put that state through $\<CNot>\otimes\<I>$: -- i.e. CNot for the first two qubits, I for the third. That gate is
\begin{equation*}
\qgatethree{1&0&0&0&0&0&0&0}
           {0&1&0&0&0&0&0&0}
           {0&0&1&0&0&0&0&0}
           {0&0&0&1&0&0&0&0}
           {0&0&0&0&0&0&1&0}
           {0&0&0&0&0&0&0&1}
           {0&0&0&0&1&0&0&0}
           {0&0&0&0&0&1&0&0}
\end{equation*}
which swaps \onezerozero{} with \oneonezero{}, \onezeroone{} with \oneoneone{}, and vice-versa. 
\item the resulting combined state  of \#1, \#3 and \#0 is $\frac{1}{\sqrt2}(\onezeroone+\oneonezero)$, in which qubit \#1 is \one{} in either superposed state, so it can be  separated out leaving $\frac{1}{\sqrt2}(\zeroone+\onezero)$ as an entanglement of \#3 and \#0;
\item manipulate that to make an entanglement of \#0 and \#3, $\frac{1}{\sqrt2}(\zeroone+\onezero)$ (again, looks the same but isn't).
\end{enumerate*}
Qtpi does that sort of calculation easily, without making mistakes. I used to find it hard to do it accurately with paper and pencil: hence qtpi.

\subsection{Measuring the full-adder result}

I haven't completely exhausted the lessons I can draw from the simulated full adder. Notice that the examples so far do any quantum measurement. Instead they use the `\verbtt{outq!showq q}' step to print out the state of a simulated qubit (or use -trace to show the same states). \Figref{Cogginswithinputandmeasurement} measures qSum and qCout using the `\verbtt{q⌢̸(b)}' step to measure a qubit q and call the result b; then it prints out what the measurements produced using the \verbtt{out} channel and prints the states of the input qubits. 

Measurement, which can be done in the real world and therefore can be simulated, isn't peeking. Measurement doesn't show the actual state of a qubit, merely one of its possible states given the probabilities in its quantum state. And measurement is destructive: afterwards, the qubit has the value that measurement reported. So this program doesn't always print the same result even though given the same inputs, because measurement can change the state of the measured qubit and unpick any entanglement it's involved in. One result of running this program, with the same inputs as before, is shown in \figref{Cogginswithinputandmeasurementoutput}. It says the sum is 0 and the carry out is 1. That comes from the second element of the entanglement: by measuring qSum, it forced the simulation to choose, and the simulation flipped a coin and chose \onezeroone{}. The measurement thus collapses the entanglement, choosing one of the superposed states, forcing qA and qCout each to be \one{}. That effect is shown in the measurement result of qCout (it's bound to be 1), and in the state of qA (it's \one{}, and not the superposition it started as). Run it again, with the same inputs, and you might get the other superposed state \zeroonezero{}, which would force qA to be \zero{}, qSum to be \one{}, and qCout to be \zero{}.
 
\mvb{\Cogginswithinputandmeasurement}
fun istate x = 
  read_alternative x "," [("0",|0>); ("1",|1>); ("+",|+>); ("-",|->)]

proc System () =
  .(newq qA   = istate "qA", 
         qB   = istate "qB",
         qCin = istate "qCin").
  
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  . out!["qSum="] . outq!showq qSum . out!["; qCout="] . outq!showq qCout .  out!["\n"] 
  
  . qSum⌢̸(sum) . qCout⌢̸(cout)
  
  . out!["qSum measured "; show sum; ", and qCout measured "; show cout; "\n"]
  . out!["now qA="] . outq!showq qA . out![", qB="] . outq!showq qB 
  . out![", and qCin="] . outq!showq qCin . out!["\n"]
  . 
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinputandmeasurement
\caption{The full adder with measurement of the result qubits}
\figlabel{Cogginswithinputandmeasurement}
\end{figure}
\mvb{\Cogginswithinputandmeasurementoutput}
qA (0,1,+,-)? +
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 0
qSum=#3:[#0;#3;#4]1/√2(|010⟩+|101⟩); qCout=#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)
qSum measured 0, and qCout measured 1
now qA=#0:|1⟩, qB=#1:|1⟩, and qCin=#2:|0⟩
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\Cogginswithinputandmeasurementoutput
\caption{a sample execution of \figref{Cogginswithinputandmeasurement}}
\figlabel{Cogginswithinputandmeasurementoutput}
\end{figure}

That's it for the full adder. Nothing so far on processes or protocol agents, and the only use of messages or channels was sending lists of strings down the \verbtt{out} channel, and special \verbtt{qstate} values down the \verbtt{outq} channel.
 
\section{An example using processes and messages}
\seclabel{cointossworkedexample}

In his story ``The Idyll of Miss Sarah Brown'', which was used as the plot of the musical ``Guys and Dolls'', Damon Runyon reports the advice received by Obadiah Masterson (The Sky) from his father:
\begin{quote}
\textit{``Son,'' the old guy says, ``no matter how far you travel, or how smart you get, always remember this: some day, somewhere,'' he says, ``a guy is going to come to you and show you a nice brand-new deck of cards on which the seal is never broken, and this guy is going to offer to bet you that the jack of spades will jump out of this deck and squirt cider in your ear. But, son,'' the old guy says, ``do not bet him, for as sure as you do you are going to get an ear full of cider.''}
\end{quote}
Meyer \citep{meyer1999quantumstrategies} describes the start of just such an encounter:
\begin{quote}
The starship \textit{Enterprise} is facing some imminent -- and apparently inescapable -- calamity when Q appears on the bridge and offers to help, provided Captain Picard can beat him at penny flipping: Picard is to place a penny heads up in a box, whereupon they will take turns (Q, then Picard, then Q) flipping the penny (or not), without being able to see it. Q wins if the penny is heads up when they open the box.
\end{quote}
Picard takes the bet. But he really shouldn't.

In the classical world there's no certain winning strategy for Q: if he flips once, he loses if Picard passes; if he flips twice or passes twice, he loses if Picard flips. So classically he has 50\% chance of winning. But Meyer is making a point about game theory in a quantum world: if the coin is a qubit, if `heads' is \zero{} and `tails' \one{}, if `flipping' is putting the qubit through an X gate which changes \zero{} to \one{} and vice-versa, then is there a way to cheat?

Yes, there is. The H gate changes \zero{} to $\plus{}=\frac{1}{\sqrt2}(\zero+\one)$ and vice-versa. and is certainly not `flipping' as Picard understands it. Picard's X-flips do nothing to \plus{}. Q does H first; then whether Picard X-flips or not the coin is still \plus{}; Q does H again, the coin will be \zero{}, and Q wins. An ear full of cider.

It is possible to read this as a simple example of a deep quantum property. Q puts the qubit into a state which is an equal-probability superposition of \zero{} and \one{}: amplitude $\frac{1}{\sqrt2}$ in each case, probabilities $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$. An X-flip by Picard, should he choose to do it, changes that into an equal-probability superposition of \one{} and \zero{} -- no change, no use to Picard, no problem for Q who just H-flips back to \zero{}. Q always wins because he's playing a quantum game and Picard isn't. Q's H-flip trick depends on starting with \zero{}, but there's a different matrix he could use instead if they started with \one{}. Picard should have read more Damon Runyon (and so should you: it's very witty). Even without that background he should have been suspicious, because Q gets two flips to his one: why is that?

Damon Runyon's story is witty and believable, but Meyer's isn't \emph{quite} a believable scenario, even if you believe in Star Wars. There's no way to see, just by looking, whether a qubit is \zero{} or \one{} or anything else: quantum measurement doesn't work that way. But hey! This is science fiction, so we can pretend. Let's pretend by simulating the swindle: I've done it using two processes to stand for Picard and Q as protocol agents, and I've made Picard measure the qubit, once the flipping is all done, to see if he gets 0 (Q wins) or 1 (Picard wins).

\mvb {\cointoss}
proc System() = . (new ch:^qubit) 
                . | Picard(ch) | Q(ch)  

     Picard(ch) = . (newq q=|0>) 
                  . ch!q
                  . ch?(r)
                  . r >> if randbool() then X else I
                  . ch!r 
                  . ch?(s)
                  . s⌢̸(b)
                  . out!["the qubit measured "; show b; 
                         if b=0b0 then ". Q wins.\n" else "! I win!\n"
                        ]
                  .

     Q(ch) = ch?(t) . t>>H . ch!t . ch?(u) . u>>H . ch!u .  
\end{myverbbox}
\begin{figure}
\centering
\cointoss
\caption{Q is set up to swindle Picard}
\figlabel{cointoss}
\end{figure}

The System process in \figref{cointoss} only has to create a channel and two processes, giving them each the channel so they can pass the penny/qubit between them, and then let them run. Its first line creates a channel with a \verbtt{new} declaration, and to emphasise that this is to be used to transmit a qubit, I've given the channel an explicit type. On the second line the process splits into two subprocesses with the `par' construct \verbtt{|...|}, and then turns one subprocess into an invocation of Picard and the other into an invocation of Q. Each invocation gets the channel as argument. The par completes the System process; the invocations complete the subprocesses; no need for any terminating blank steps.

The Picard process makes nine steps, if we count a declaration as a step, and we count termination also: 
\renewcommand{\labelenumi}{P\theenumi}
\begin{enumerate*}
\item \verbtt{(newq q=|0>)} creates a qubit in state \zero{} (heads) and names it q; 
\item \verbtt{ch!q} sends q down the channel ch; 
\item \verbtt{ch?(r)} receives a qubit from the ch channel and names it r; 
\item \verbtt{r >> if randbool() then X else I} puts qubit r through a gate, using a conditional expression to choose an X gate or an I gate at random (but, since r must be \plus{}, neither gate has any effect); 
\item \verbtt{ch!r} sends the gated r back down the ch channel; 
\item \verbtt{ch?(s)} receives a qubit from the ch channel and names it s;
\item \verbtt{s⌢̸(b)} measures s, naming the result b (b will be a classical bit, either 0b0 or 0b1);
\item \verbtt{out![...]} describes the measurement result by sending a list of strings down the \verbtt{out} channel;
\item terminates with an empty/blank step.
\end{enumerate*}

The Q process makes seven steps: 
\renewcommand{\labelenumi}{Q\theenumi}
\begin{enumerate*}
\item \verbtt{ch?(t)} receives a qubit from the ch channel, and names it t;
\item \verbtt{t>>H} puts t through an H gate (which, since t must be \zero{}, changes it to \plus{}); 
\item \verbtt{ch!t} sends t down the ch channel back to Picard; 
\item \verbtt{ch?(u)} receives a qubit from the ch channel (which must be \plus{}), and names it u;
\item \verbtt{u>>H} puts u through an H gate (which changes \plus{} to \zero{});
\item \verbtt{ch!u} sends u (which must be \zero{}) down the ch channel; 
\item terminates with an empty/blank step
\end{enumerate*}
\renewcommand{\labelenumi}{\theenumi}

The two processes run in parallel, but in practice one is always waiting for the other: Q's \verbtt{ch?(t)} has to wait until Picard has reached \verbtt{ch!q}, and then Picard's \verbtt{ch?(r)} has to wait until Q reaches \verbtt{ch!t}; and so on. So in this example, as in many others, it's all interleaving.

%There is only one qubit when this program runs, created with \verbtt{newq q} and measured in \verbtt{s⌢̸(b)}, which the two processes pass between them. When one has the qubit it can gate it, while the other is waiting to get it back. It would be physically impossible in real life for two protocol agents to share access to a qubit and to gate or measure it both at the same time. Qtpi enforces this real-life property in part by insisting that once a qubit has been sent away it can't be used again. I've emphasised this by using three different names for the qubit in the Picard process, and two other names in Q, but it could have been q all the way through the program.
 
I can put this program in a file \verbtt{cointoss.qtp} and run \verbtt{qtpi cointoss.qtp}; the output (just as expected) is always 
\begin{quote}
\verbtt{the qubit measured 0. Q wins.}
\end{quote}
Running \verbtt{qtpi cointoss.qtp -trace} records quantum declarations and steps, and all messages, and prints it out when the program terminates. \Figref{cointoss_trace} shows a sample trace. The trace is almost identical if Picard uses the I gate. Obviously, Q always wins.

\mvb{\cointosstrace}
the qubit measured 0. Q wins.

Event Trace:

Picard creates #0:|0⟩

0: Picard -> Q Qubit #0

Q #0:|0⟩ >> H; result #0:1/√2(|0⟩+|1⟩)

0: Q -> Picard Qubit #0

Picard #0:1/√2(|0⟩+|1⟩) >> X; result #0:1/√2(|0⟩+|1⟩)

0: Picard -> Q Qubit #0

Q #0:1/√2(|0⟩+|1⟩) >> H; result #0:|0⟩

0: Q -> Picard Qubit #0

Picard: #0:|0⟩ ⌢̸ ; result 0
\end{myverbbox}
\begin{figure}
\centering
\cointosstrace
\caption{Despite X-flipping, Picard loses}
\figlabel{cointoss_trace}
\end{figure}

\section{A harder worked example}
\seclabel{teleportworkedexample}

Coin tossing doesn't really need two processes, but consider the famous quantum teleportation protocol \citep{bbcjp:93,teleportwiki}. I shan't try to explain everything about how or why the protocol works, but I shall show how to simulate it in qtpi. The protocol has two participant agents, conventionally called Alice and Bob. It's quite tricky, so I'll do in in stages.  This is the problem and its starting position:
\begin{quote}
Alice has a qubit whose state $\bv{\phi}=a\zero+b\one$ she doesn’t know. She wants to send the state of this qubit 
to Bob through classical channels. Alice and Bob each possess one qubit of an entangled pair in state $\bv{\psi}=\frac{1}{\sqrt{2}}(\zerozero+\oneone)$.
\end{quote}
Qtpi can simulate this rather well, using symbolic calculation with variables used to represent unknown amplitudes -- $a$ and $b$ in this description, $a_{2}$ and $b_{2}$ in the simulation, as we shall see.

\subsection{Creating an entanglement and an `unknown' qubit}

The System process in this example has to create an entangled pair and a couple of processes, connected with a channel. We've already seen how to create qubits and how to invoke processes and connect them. Entanglement we've seen in the full-adder example:
\begin{quote}
Take two qubits, one in state $\plus=\frac{1}{\sqrt{2}}(\zero+\one)$, the other in state $\zero$, and put them through a CNot gate.
\end{quote}
To create Alice's unknown qubit, she can use a \verbtt{newq} declaration which doesn't specify the state of the new qubit. The program that creates the starting position is in \figref{teleportinit}.

\mvb {\teleportinit}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch:^(bit,bit))
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        .  

     Bob(b:qubit, ch) = 
        . 
\end{myverbbox}
\begin{figure}
\centering
\teleportinit
\caption{Setting up Alice and Bob with a connecting channel, and acquiring Alice's unknown qubit}
\figlabel{teleportinit}
\end{figure}

System begins by creating the two qubits to be entangled\footnote{Sharp-eyed readers will notice that the order in which the qubits are declared in \figref{teleportinit} is b, then a. That's because it makes Alice's calculation easier to interpret, as shown in \secref{whatshappening}.} and then puts them through a CNot gate as the recipe requires. Then it declares a new channel, and just to emphasise how it's to be used, says via explicit typing that it carries pairs of (classical) bits. Then as in the coin-toss example it splits into two subprocesses, one invoking Alice with the `a' qubit and the channel, the other Bob with the `b' qubit and the channel.  

The trace of this program is shown in \figref{teleportinittrace}. The first two events create qubits \#0 and \#1 in states \plus{} and \zero{}. The third event entangles them. The fourth event creates qubit \#2, so far unentangled with either \#0 or \#1, whose amplitudes $a_{2}$ and $b_{2}$ are unspecified. This isn't quite how the starting position is described, but it's ok: qtpi uses a $_{2}$ suffix because it's describing qubit \#2 in the simulation. All that the qtpi calculator knows about the unknown amplitudes is that $|a_{2}|^{2}+|b_{2}|^{2}=1$. We have our starting position. 

\mvb {\teleportinittrace}
System creates #0:1/√2(|0⟩+|1⟩)

System creates #1:|0⟩

System (#0:1/√2(|0⟩+|1⟩),#1:|0⟩) >> Cnot; 
      result (#0:[#0;#1]1/√2(|00⟩+|11⟩),#1=#0)

Alice creates #2:(a2|0⟩+b2|1⟩)
\end{myverbbox}
\begin{figure}
\centering
\teleportinittrace
\caption{Trace of execution, up to the starting position}
\figlabel{teleportinittrace}
\end{figure}

\subsection{Alice gates and measures her qubits}

Alice only has access to qubits \verbtt{a} and \verbtt{c} (qubits \#1 and \#2 in the simulation), while Bob has control of \verbtt{b} (\#0). The protocol proceeds by Alice measuring her qubits in a way that entangles them with Bob's. The original paper requires measurement in a complicated four-dimensional basis, and qtpi is not (yet) set up to do that. The other technique, revealed in the Wikipedia page, is to put bits c and a through a sort of reverse entanglement -- Cnot for c and a, then H for c alone -- before measuring in the computational basis. Just why the measurement is useful is discussed in \secref{whatshappening}; before that we look at what the measurement does. 

\Figref{teleportmeasure} shows the program. Alice does the CNot, H steps and then measures a and c. The order of measurement doesn't matter. The classical-bit results are bound to names va and vc. Bob is still passive. \Figref{teleportmeasuretrace} shows the part of the trace that covers Alice's calculation and measurement steps.

\mvb {\teleportmeasure}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch:^(bit,bit))
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a⌢̸(va) . c⌢̸(vc)
        . 

     Bob(b:qubit, ch) = 
        . 
\end{myverbbox}
\begin{figure}
\centering
\teleportmeasure
\caption{Alice calculates and measures}
\figlabel{teleportmeasure}
\end{figure}

\mvb {\teleportmeasuretrace}
...
Alice (#2:(a2|0⟩+b2|1⟩),#1:[#0;#1]1/√2(|00⟩+|11⟩)) >> Cnot; 
      result (#2:[#0;#1;#2]1/√2(a2|000⟩+b2|011⟩+b2|101⟩+a2|110⟩),#1=#2)

Alice #2:[#0;#1;#2]1/√2(a2|000⟩+b2|011⟩+b2|101⟩+a2|110⟩) >> H; 
      result #2:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩
                             +b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩)

Alice: #1:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩
                       +b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩) ⌢̸ ; 
      result 0 and (#0:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩),#2=#0)

Alice: #2:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩) ⌢̸ ; 
      result 1 and #0:(a2|0⟩-b2|1⟩)
\end{myverbbox}
\begin{figure}
\centering
\teleportmeasuretrace
\caption{Trace of Alice's calculation and measurement}
\figlabel{teleportmeasuretrace}
\end{figure}

This looks terrifyingly complicated, but notice that in the fourth step everything is reduced to an almost recognisable single-qubit state: $a_{2}\zero-b_{2}\one{}$ is almost the same as the $a_{2}\zero+b_{2}\one{}$ state which Alice was given when she created qubit \#2. So what's going on?


\subsubsection{A glimpse of what's going on}
\seclabel{whatshappening}

(** I'm ashamed to say that I don't understand why the Cnot, H gating allows the measurement to happen in the \zero{}, \one{} basis. If anybody out there has the time to tell me, please do. **)

(This description may tell you more than you wish to know: the details are interesting only if you want to know how qtpi does it. If not, skip to the bit about measurement.)

To cause the first event in \figref{teleportmeasuretrace}, Alice executes \verbtt{c,a>>CNot}: put qubits 2 and 1 through a CNot gate. But qubit 1 is entangled with 0, so there are actually three bits to be considered. We've seen the solution to this problem: rearrange the state a little so it reads in the order \#2, \#1, \#0; put it through $\<CNot>⊗\<I>$, rearrange it again to read in the order \#0, \#1, \#2.

To cause the second event, Alice  puts qubit \#2 (c) through an H gate. That qubit is now entangled with the two others: rearrange the state into \#2, \#0, \#1 order; put that state through $\<H>⊗\<I>⊗\<I>$ (H for \#2, I for the others); rearrange it again to read in the order \#0, \#1, \#2. $\<H>⊗\<I>⊗\<I>$, by the way, is quite a pretty gate:
\newcommand{\h}[0]{\ensuremath{\frac{1}{\sqrt2}}}
\begin{equation*}
\qgatethree{\h&0&0&0&\h&0&0&0}
           {0&\h&0&0&0&\h&0&0}
           {0&0&\h&0&0&0&\h&0}
           {0&0&0&\h&0&0&0&\h}
           {\h&0&0&0&-\h&0&0&0}
           {0&\h&0&0&0&-\h&0&0}
           {0&0&\h&0&0&0&-\h&0}
           {0&0&0&\h&0&0&0&-\h}
\end{equation*}

The three-qubit state shown in the trace as the result of Alice's H-gating is an entanglement shown in \#0, \#1, \#2 order: qubits \#1 and \#2 (a and c) are listed last, and \#0 (b) is first.\footnote{The reason I declared the to-be-entangled qubits in b, a order in System was so that a would be \#1, c would be \#2, and they would appear next to each other in this entanglement.} We can rewrite the entanglement, keeping it in \#0, \#1, \#2 order, as
\begin{equation*}
\frac{1}{2}(a_{2}\zero\zerozero+a_{2}\zero\zeroone+b_{2}\zero\onezero-b_{2}\zero\oneone
		   +b_{2}\one\zerozero-b_{2}\one\zeroone+a_{2}\one\onezero+a_{2}\one\oneone)
\end{equation*}
Gathering the \#1, \#2 values together, we can rewrite this as 
\begin{equation*}
1/2((a_{2}\zero+b2\one)\zerozero+(a2\zero-b2\one)\zeroone+(b2\zero+a2\one)\onezero+(-b2\zero+a2\one)\oneone)
\end{equation*}

This is a four-way equal-probability superposition. It looks as if Alice's qubits were \zerozero, then Bob's would have to be $a_{2}\zero+b_{2}\one$; if Alice were to have \zeroone, then Bob would have $a_{2}\zero-b_{2}\one$; and so on. But Alice's qubits aren't necessarily in any of those states. Measurement in the classical \zero{}, \one{} basis, however, forces a qubit to be \zero{} or \one{}, collapsing the entanglement, as it delivers the classical result 0 or 1. In \figref{teleportmeasuretrace} Alice has measured 0 and 1, and qubit \#0 is indeed in the $a_{2}\zero-b_{2}\one$ state, as predicted. If you ran the program several times you would get different answers: Alice can measure any of the four possible bit combinations, and the simulation follows that faithfully.

When Alice reads her qubits she \emph{must} find a combination which matches one of \zerozero, \zeroone, \onezero{} or \oneone{} and then, \emph{even though she doesn't know what the secret amplitudes $a_{2}$ are $b_{2}$ are}, she will know what combination of those amplitudes and the vectors \zero{} and \one{} make up the state of Bob's qubit, \emph{even though she's never had access to it}. If she tells Bob what she found, he'll know the same (because he knows what the protocol is), and he'll be able to reconstruct the qustate $a_{2}\zero+b_{2}\one$ just by using the gates X and Z to move amplitudes around and change their sign as necessary. But he won't actually know what he's produced, because he also doesn't know what $a_{2}$ are $b_{2}$ are.

\subsection{Alice tells Bob, and Bob tidies up}

\Figref{teleportfinal} is the final program. Alice sends the pair of bits which are the result of her measurement -- classical bits, not qubits -- to Bob over their shared channel, Bob receives them and then puts his qubit through one of four gates using a \verbtt{match} construction. (Notice that for typechecking reasons qtpi's bit-constants have to be written as 0b0 and 0b1 rather than num-constants 0 and 1.) 

The gates that Bob uses can be justified as follows:

\begin{enumerate}
\item if Alice measured 0 and then 0, Bob's qubit is forced to be $a_{2}\zero+b_{2}\one$, and he has nothing to do -- an I gate does nothing; 
\item if Alice measured 0 and then 1, Bob's qubit is forced to be $a_{2}\zero-b_{2}\one$, and he has to change the sign of the \one{} amplitude -- a Z gate will do that;
\item if Alice measured 1 and then 0, Bob's qubit is forced to be $b_{2}\zero+a_{2}\one$, and he has to swap the amplitudes -- an X gate will do that;
\item if Alice measured 1 and then 1, Bob's qubit is forced to be $-b_{2}\zero+a_{2}\one$, and he has first to use X to swap the amplitudes and then Z to change the sign of the \one{} amplitude -- a Z*X gate does that. 
\end{enumerate}

\mvb{\teleportfinal}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch:^(bit,bit))
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a⌢̸(va) . c⌢̸(vc)
        . ch!(va,vc) .

     Bob(b:qubit, ch) = 
        . ch?(pair)
        . b >> match pair . + (0b0,0b0) . I
                            + (0b0,0b1) . Z
                            + (0b1,0b0) . X
                            + (0b1,0b1) . Z*X 
        .
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\teleportfinal
\caption{Alice sends to Bob, who tidies up}
\figlabel{teleportfinal}
\end{figure}

When the program is run and Alice measures 0 and 1, the trace ends as shown in \figref{teleportfinaltrace}. Bob \emph{always} gets the right answer, even though Alice doesn't always send the same message, as you can see if you run this program for yourself.
\mvb{\teleportfinaltrace}
Alice: #1:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩
      +b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩) ⌢̸ ; 
        result 0 and (#0:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩),#2=#0)

Alice: #2:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩) ⌢̸ ; 
      result 1 and #0:(a2|0⟩-b2|1⟩)

0: Alice -> Bob (0,1)

Bob #0:(a2|0⟩-b2|1⟩) >> Z; result #0:(a2|0⟩+b2|1⟩)
\end{myverbbox} %can't be a macro
\begin{figure}
\centering
\teleportfinaltrace
\caption{Trace of Alice's measurement in the (0,1) case, her message, and Bob's final step}
\figlabel{teleportfinaltrace}
\end{figure}
