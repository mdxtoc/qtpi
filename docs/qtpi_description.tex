%!TEX TS-program = pdflatexmk
\documentclass[11pt,a4paper]{book}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subfigure}
\usepackage[round]{natbib}
\usepackage[pagebackref]{hyperref}

\hoffset = 0mm
\voffset = 0mm
\textwidth = 165mm
\textheight = 229mm
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
%\headheight = 0.0 in
%\headsep = 0.0 in
\parskip = 3pt
\parindent = 0.0in

\makeatletter
\renewcommand{\@makefntext}[1]{\setlength{\parindent}{0pt}%
\begin{list}{}{\setlength{\labelwidth}{1em}%
  \setlength{\leftmargin}{\labelwidth}%
  \setlength{\labelsep}{3pt}\setlength{\itemsep}{0pt}%
  \setlength{\parsep}{0pt}\setlength{\topsep}{0pt}%
  \footnotesize}\item[\hfill\@makefnmark]#1%
\end{list}}
\makeatother

%\newcommand{\greyorcolour}[2]{#2} % #1 highlighting (etc.) for greyscale, #2 for colour
%\input{rbmacros}

\input{qmacros}

\makeatletter
\def\verbatim@font{\ttfamily\footnotesize}
\makeatother

\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{2297}{\ensuremath{\otimes}}
\DeclareUnicodeCharacter{2041}{\ensuremath{{/}\mspace{-9.1mu}}\raisebox{-0.47ex}{\ensuremath{{\wedge}}}}
\DeclareUnicodeCharacter{03BB}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{2190}{\ensuremath{\leftarrow}}
\DeclareUnicodeCharacter{2192}{\ensuremath{\rightarrow}}
\DeclareUnicodeCharacter{2193}{\ensuremath{\downarrow}}
\DeclareUnicodeCharacter{1D106}{\ensuremath{|\mspace{-1mu}\!|\!\mspace{0.7mu}|\!\!:}}
\DeclareUnicodeCharacter{2322}{} % ignore frown
\DeclareUnicodeCharacter{20EB}{\ensuremath{\mspace{4mu}/\!\mspace{-1mu}/\mspace{-22mu}\frown}}
\DeclareUnicodeCharacter{0338}{\ensuremath{\mspace{6mu}/\mspace{-19mu}\frown}}
\DeclareUnicodeCharacter{221A}{\ensuremath{\sqrt{}}}
\DeclareUnicodeCharacter{1D745}{\ensuremath{\pi}}


\newcommand{\verbtt}[1]{\texttt{\small{}#1}}
\newcommand{\verbttf}[1]{\texttt{\footnotesize{}#1}}

\var{prog,pdef,fdef,pat,bpat,Pname[Pn],Fname[fn],E,P,Q,IO,T,TV[tv],Const}

\newcommand{\caret}[0]{\ensuremath{{}^{\wedge}}}

\title{The qtpi language}
\author{Richard Bornat \\ School of Science and Technology, Middlesex University, London, UK \\ R.Bornat@mdx.ac.uk, richard@bornat.me.uk}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\chapter{An introduction to qtpi}

Qtpi is a symbolic calculator controlled by a programming language, designed to simulate quantum computation, especially computation in quantum security protocols. The language is also called qtpi.
I designed and built it simply because I found it hard, using pencil and paper, to check the calculations that underpin famous quantum protocols and other famous quantum programs. The calculator is precise, using no approximations such as floating-point numbers. The language wasn't novel: Raja Nangarajan was a colleague who was encouraging me to work on quantum stuff, and he was one of the authors of CQP \citep{GaySJ:comqp}, a development of the pi calculus \citep{DBLP:journals/iandc/MilnerPW92a} which could describe Communicating Quantum Protocols. I made some changes from CQP which I thought would make qtpi more useful, but it remains obviously a CQP and pi calculus descendant. Protocol agents are processes, communication is via channels, there are quantum computation operations, qubits can be sent in messages, classical calculation is possible. 

\section{A worked example}

Consider, for example, the famous quantum teleportation protocol \citep{bbcjp:93,teleportwiki}. I shan't try to explain how or why the protocol works, but I shall explain how to simulate it in qtpi. The protocol has two participant agents, conventionally called Alice and Bob, and this is the starting position:
\begin{quote}Alice has a qubit whose state $\bv{\phi}=a\zero+b\one$ she doesn‚Äôt know. She wants to send the state of this qubit 
to Bob through classical channels. Alice and Bob each possess one qubit of an entangled pair in state $\bv{\psi}=\frac{1}{\sqrt{2}}(\zerozero+\oneone)$.
\end{quote}
Qtpi can simulate this rather well, using symbolic calculation with variables used to represent unknown amplitudes -- $a$ and $b$ in this description, $a_{2}$ and $b_{2}$ as we shall see.

\subsection{Setting up an entanglement}

Every qtpi program has to have a startup process called System. It has to initiate any other processes that are needed, giving them the arguments they need, and usually creating channels to connect them. It may have to create qubits or do calculations, and it will often ask the user for instructions about what to do. In our case no instructions are necessary, but it does certainly have to create an entangled pair and a couple of processes. Luckily there's a well-known recipe for the entanglement:
\begin{quote}Take two qubits, one in state $\plus=\frac{1}{\sqrt{2}}(\zero+\one)$, the other in state $\zero$, and put them through a CNot gate.\end{quote}

\begin{figure}
\begin{verbatim}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . 
\end{verbatim}
\caption{Initialising an entanglement}
\figlabel{teleportinit}
\end{figure}
\begin{figure}[t]
\begin{verbatim}System creates #0:1/‚àö2(|0‚ü©+|1‚ü©)

System creates #1:|0‚ü©

System (#0:1/‚àö2(|0‚ü©+|1‚ü©),#1:|0‚ü©) >> Cnot; result (#0:[#0;#1]1/‚àö2(|00‚ü©+|11‚ü©),#1=#0)
\end{verbatim}
\caption{trace of entanglement}
\figlabel{teleportinit_trace}
\end{figure}

Qtpi creates qubits with the \verbtt{newq q=ket} declaration, and the \verbtt{q,..,q>>G} operation puts one or more qubits through a gate. \Figref{teleportinit} shows a very simple program -- just a System process -- which follows the entanglement recipe. Declarations are bracketed, as in the pi calculus; steps are separated with dots, as in the pi calculus (but qtpi lets you put extra dots in the program if you wish\footnote{I find it helps to put a dot at the start of each line, because then I can keep everything lined up, and I never have too few dots.}); an empty step terminates a process. 
%\footnote{There is more than one way to spell CNot/Cnot/... in qtpi.} 

\Figref{teleportinit_trace} shows what happens when we put this program in a file called \verbtt{teleport.qtp} and run \verbtt{qtpi teleport.qtp -trace}. The trace records important events: qubit creation, gating and measuring, and messages between processes. Here we see creation of two qubits, called b and a in the program but numbered 0 and 1 in the trace,\footnote{Sharp-eyed readers will notice that the order in which the qubits are declared in \figref{teleportinit} is b, then a. That's because it makes Alice's calculation easier to interpret, as you will see in \secref{whatshappening}. The entanglement is unaffected by the order of declaration: it's always $\frac{1}{\sqrt{2}}(\zerozero+\oneone)$ whether a or b is listed first.} and a gating of the same two with a Cnot\footnote{CNot? Cnot? I can never remember, so qtpi lets you spell it several different ways.} gate: it's plain that the effect is to create an entanglement.

\subsection{Completing the starting state}

To complete the simulation of the starting position, the program must create Alice and Bob processes to do the jobs of the two protocol agents, connect them through a channel, and give Alice a qubit whose state she doesn't know. The System process in \figref{teleportinit2} creates a channel \verbtt{ch} with a \verbtt{new ch} declaration. To emphasise that this channel is to carry only classical information, we give it an explicit type -- it carries a pair of classical bits. Then the process splits into two parallel subprocesses with the \verbtt{|..|} construction; one of the subprocesses turns into Alice, the other into Bob, each given one of the entangled qubits plus the channel. Once she starts, Alice completes the starting position by creating a qubit with a \verbtt{newq} declaration that doesn't say what state the new qubit should be in. Bob doesn't have to do anything yet. By the normal rules of programming scope, only Alice can see qubit c and she has no means -- because her channel only carries pairs of classical bits -- to send it to Bob or to System. 

\begin{figure}
\begin{verbatim}
proc System () = 
        . (newq a=|+>, b=|0>)  
        . a,b>>CNot 
        . (new ch:^(bit,bit))
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        .  

     Bob(b:qubit, ch) = 
        . 
\end{verbatim}
\caption{Setting up Alice and Bob with a connecting channel, and acquiring Alice's unknown qubit}
\figlabel{teleportinit2}
\end{figure}

The trace of this program is shown in \figref{teleportinit2_trace}, and the last step certainly creates a qubit which is in an unspecified state: $a_{2}$ and $b_{2}$ are unspecified amplitudes (the $_{2}$ suffix comes from the fact that the qubit is number 2 in the simulation), and all the qtpi calculator knows about those amplitudes is that $|a_{2}|^{2}+|b_{2}|^{2}=1$. We have our starting position. 

\begin{figure}
\begin{verbatim}
System creates #0:1/‚àö2(|0‚ü©+|1‚ü©)

System creates #1:|0‚ü©

System (#0:1/‚àö2(|0‚ü©+|1‚ü©),#1:|0‚ü©) >> Cnot; result (#0:[#0;#1]1/‚àö2(|00‚ü©+|11‚ü©),#1=#0)

Alice creates #2:(a2|0‚ü©+b2|1‚ü©)
\end{verbatim}
\caption{Trace of execution, up to the starting position}
\figlabel{teleportinit2_trace}
\end{figure}

\subsection{Alice gates and measures her qubits}

Alice only has access to \verbtt{a} and \verbtt{c}, while Bob has control of \verbtt{b}. The protocol proceeds by Alice measuring her qubits and sending the result to Bob, but the measurement is quite subtle. The original description of the protocol required measurement in a complicated four-dimensional basis, and qtpi is not (yet) set up to do that. The other technique is to put bits c and a through a sort of reverse entanglement -- Cnot first, then H for c alone -- before measuring both in the computational basis. Just why the measurement is useful is discussed in \secref{whatshappening}. 

\Figref{teleportmeasure} shows the program -- the \verbtt{q‚å¢Ã∏(b)} step measures the state of qubit \verbtt{q} and binds the classical single-bit result to {b}. \Figref{teleportmeasure_trace} shows the trace of Alice's calculation and measurement steps.

\begin{figure}
\begin{verbatim}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch)
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a‚å¢Ã∏(va) . c‚å¢Ã∏(vc)
        . 

     Bob(b:qubit, ch) = 
        . 
\end{verbatim}
\caption{Alice's calculation and measurement}
\figlabel{teleportmeasure}
\end{figure}
\begin{figure}
\begin{verbatim}
...
Alice (#2:(a2|0‚ü©+b2|1‚ü©),#1:[#0;#1]1/‚àö2(|00‚ü©+|11‚ü©)) >> Cnot; 
      result (#2:[#0;#1;#2]1/‚àö2(a2|000‚ü©+b2|011‚ü©+b2|101‚ü©+a2|110‚ü©),#1=#2)

Alice #2:[#0;#1;#2]1/‚àö2(a2|000‚ü©+b2|011‚ü©+b2|101‚ü©+a2|110‚ü©) >> H; 
      result #2:[#0;#1;#2]1/2(a2|000‚ü©+a2|001‚ü©+b2|010‚ü©-b2|011‚ü©
                             +b2|100‚ü©-b2|101‚ü©+a2|110‚ü©+a2|111‚ü©)

Alice: #1:[#0;#1;#2]1/2(a2|000‚ü©+a2|001‚ü©+b2|010‚ü©-b2|011‚ü©+b2|100‚ü©-b2|101‚ü©+a2|110‚ü©+a2|111‚ü©) ‚å¢Ã∏ ; 
      result 0 and (#0:[#0;#2]1/‚àö2(a2|00‚ü©+a2|01‚ü©+b2|10‚ü©-b2|11‚ü©),#2=#0)

Alice: #2:[#0;#2]1/‚àö2(a2|00‚ü©+a2|01‚ü©+b2|10‚ü©-b2|11‚ü©) ‚å¢Ã∏ ; result 1 and #0:(a2|0‚ü©-b2|1‚ü©)
\end{verbatim}
\caption{Trace of Alice's calculation and measurement}
\figlabel{teleportmeasure_trace}
\end{figure}

\subsection{A glimpse of what's going on}
\seclabel{whatshappening}

(I'm afraid I'm not sophisticated enough to explain all of how the protocol works. In particular, I don't understand why the Cnot, H combination does what it does. If anybody out there has the time to tell me, please do.)

Qtpi, whilst it's simulating, doesn't know which process owns which qubit. If it did, it might notice that the three-qubit state after the H gating in \figref{teleportmeasure_trace} could be rewritten, separating out Bob's qubit  number 0 from Alice's number 1 and number 2:
\begin{verbatim}
[#0;#1;#2]1/2(a2|0‚ü©|00‚ü©+a2|0‚ü©|01‚ü©+b2|0‚ü©|10‚ü©-b2|0‚ü©|11‚ü©
             +b2|1‚ü©|00‚ü©-b2|1‚ü©|01‚ü©+a2|1‚ü©|10‚ü©+a2|1‚ü©|11‚ü©)
\end{verbatim}
 -- the square brackets tell us that this is the combined state of three qubits and the order they are listed in. Focusing on Alice's qubits' four possible combined states, this can be re-written as
 \begin{verbatim}
[#0;#1;#2]1/2((a2|0‚ü©+b2|1‚ü©)|00‚ü©+(a2|0‚ü©-b2|1‚ü©)|01‚ü©+(b2|0‚ü©+a2|1‚ü©)|10‚ü©+(-b2|0‚ü©+a2|1‚ü©)|11‚ü©)
\end{verbatim}

This can be read as a four-way choice: if Alice's qubits were \zerozero, then Bob's would have to be $a_{2}\zero+b_{2}\one$; if Alice were to have \zeroone, then Bob would have $a_{2}\zero-b_{2}\one$; and so on. In \figref{teleportmeasure_trace} Alice has measured 0 and 1, and qubit number 0 is indeed in the $a_{2}\zero-b_{2}\one$ state, as predicted. If you ran the program several times you would get different answers: Alice can measure any of the four possible bit combinations, and the simulation follows that faithfully.

When Alice reads her qubits she \emph{must} find a combination which matches one of \zerozero, \zeroone, \onezero{} or \oneone{} and then, although she doesn't know what the secret amplitudes $a_{2}$ are $b_{2}$ are, she will know what combination of those amplitudes and the vectors \zero{} and \one{} make up the state of Bob's qubit, \emph{even though she's never had access to it}. If she tells Bob what she found, he'll know the same (because he knows what the protocol is), and he'll be able to reconstruct the qustate $a_{2}\zero+b_{2}\one$ just by using the gates X and Z to move amplitudes around and change their sign as necessary. 

\subsection{Alice tells Bob, and Bob tidies up}

\Figref{teleportfinal} is the final program. Alice sends the pair of bits which are the result of her measurement -- classical bits, not qubits -- to Bob over their shared channel, Bob receives them and then puts his qubit into one of four gates using a \verbtt{match} construction. (Notice that for typechecking reasons bit-constants have to be written as 0b0 and 0b1 rather than num-constants 0 and 1.) 

The gates that Bob uses can be justified as follows:

\begin{enumerate}\item if Alice measured \zerozero, Bob has $a_{2}\zero+b_{2}\one$ already, and has nothing to do -- but an I gate does nothing; 
\item if Alice measured \zeroone, Bob has $a_{2}\zero-b_{2}\one$: he has to change the sign of the \one{} amplitude -- a Z gate will do that;
\item if Alice measured \onezero, Bob has $b_{2}\zero+a_{2}\one$: he has to swap the amplitudes -- an X gate will do that;
\item if Alice measured \oneone, Bob has $-b_{2}\zero+a_{2}\one$: he has to use X to swap the amplitudes and then Z to change the sign of the \one{} amplitude -- Z*X does that. \end{enumerate}

\begin{figure}
\begin{verbatim}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch)
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a‚å¢Ã∏(va) . c‚å¢Ã∏(vc)
        . ch!(va,vc) .

     Bob(b:qubit, ch) = 
        . ch?(pair)
        . b >> match pair . + (0b0,0b0) . I
                            + (0b0,0b1) . Z
                            + (0b1,0b0) . X
                            + (0b1,0b1) . Z*X 
        .
\end{verbatim}
\caption{Alice sends to Bob, who tidies up}
\figlabel{teleportfinal}
\end{figure}

When the program is run and Alice measures 0 and 1 the trace ends as shown in \figref{teleportfinal_trace}. Bob \emph{always} gets the right answer, as you can see if you run this program for yourself.
\begin{figure}
\begin{verbatim}Alice: #1:[#0;#1;#2]1/2(a2|000‚ü©+a2|001‚ü©+b2|010‚ü©-b2|011‚ü©+b2|100‚ü©-b2|101‚ü©+a2|110‚ü©+a2|111‚ü©) ‚å¢Ã∏ ; 
      result 0 and (#0:[#0;#2]1/‚àö2(a2|00‚ü©+a2|01‚ü©+b2|10‚ü©-b2|11‚ü©),#2=#0)

Alice: #2:[#0;#2]1/‚àö2(a2|00‚ü©+a2|01‚ü©+b2|10‚ü©-b2|11‚ü©) ‚å¢Ã∏ ; result 1 and #0:(a2|0‚ü©-b2|1‚ü©)

0: Alice -> Bob (0,1)

Bob #0:(a2|0‚ü©-b2|1‚ü©) >> Z; result #0:(a2|0‚ü©+b2|1‚ü©)
\end{verbatim}
\caption{Trace of Alice's measurement in the (0,1) case, her message, and Bob's final step}
\figlabel{teleportfinal_trace}
\end{figure}

\chapter{Core language}

The language described in this document is a mildly tweaked version of CQP. Separate chapters describe additions:  

\begin{description}
\item[logging sub-processes] allow you to attach output statements to a process without obscuring its content;  
\item[iterative sub-processes] can simplify the description of some algorithms;  
\item[qubit collections] allow you to simulate algorithms that deal with vectors of qubits.
\end{description}

\section{Minor points}
\subsection{Qubit or qbit?}
The world uses `qubit' for `quantum bit'. CQP used `qbit' for the simulated qubits a program manipulates, and at first qtpi did the same. Qbit actually would be a better name, because `qubit' looks as if it should be pronounced `quoobit'. But it's too late to change the world's mind, and qtpi now uses `qubit' (though it still accepts `qbit' in programs, because why not?).

\section{The offside parsing rule}

Most languages use lots of brackets in their syntax. You sometimes have to use brackets in OCaml, for example, around the clause which follows `then', when there is no `else' to bracket it, and likewise after the `else' because there's no bracket to match `if'.

When I began to implement Qtpi I thought that I'd do the Algol 68 thing and use `if .. then .. else .. fi'. When I added pattern matching, I introduced a construct which started `match' and ended `hctam'. It looked horrible, and I could never remember how to spell hcatm.

Landin's \emph{offside rule} -- no part of a construct should be to the left and below the first symbol of the construct -- often makes closing brackets unnecessary. In the expression $E$ where $E'$, `where' mustn't be left of $E$ and $E'$ mustn't be left of `where'. This disambiguates things like 

\begin{verbatim}
		hwc key message
		  where message = packets [] bits
		                    where bits = f message
		                    where f = g key
		  where key = ...
\end{verbatim}
	
-- the first \verbtt{where} affects only \verbtt{hwc key message}; the second and third affect only \verbtt{packets [] bits}; the fourth affects everything.

So far the offside parser applies to function definitions (expression to the right of '='), to `where' clauses, to `match'es in processes and expressions, to guarded sums, to parallel process compositions and to conditionals. In conditionals `fi' is optional (but offside parsing is not).

\subsection{Mostly-optional typing}

Qtpi has an automatic typechecker, so types are mostly optional. Mostly I omit explicit types when I'm writing a program, but of course it's a matter of taste, and sometimes types clarify a program. 

In order to permit matrix arithmetic, numerical arithmetic and trigonometric arithmetic, arithmetical operators are very highly overloaded. Explicit typing is sometimes necessary to resolve ambiguities.

\subsection{Syntax-description conventions}

\newcommand{\asep}[0]{\ \bigm{|} \ }
\newcommand{\optq}[1]{\ensuremath{\overline{\underline{[}}#1\overline{\underline{]}}}}
\newcommand{\optT}[0]{\;\optq{\!:\!T}}
In syntax descriptions, optional items are in decorated square brackets \optq{\;\; }. Repetition is represented by ellipsis: three dots for a non-empty sequence, two dots for possibly empty, with a bit of common-sense needed for separating symbols. So $\<pdef>\ ...\ \<pdef>$ is a non-empty sequence of \<pdef>s, for example, and $\<E>,\ ..\ ,E$ is a possibly-empty tuple of \<E>s, separated by commas

\subsection{Awful syntax error messages}

The parser, as currently implemented, can generate \emph{awful} error messages: `syntax error at line k character j' sort of thing. This is shameful and can prompt hair tearing. I'm sorry, I'm ashamed, and I really will fix it one day. I blame Donald Knuth and the automatic parser generators that he enabled.

\section{Program syntax}

\begin{figure}
\centering $$
\begin{array}{rcl}
\<prog> &::=& \verbtt{proc}\ \<pdef>\ ...\ \<pdef>\ \<prog> \\
	   &|&	  \verbtt{fun}\ \<fdef>\ ...\ \<fdef>\ \<prog> \\
	   &|&	  \verbtt{let}\ \<bpat>\ =\ E\ \<prog>\ \vspace{3pt} \\
\<pdef> &::=& \<Pname>(x\optT,\ ..\ ,z\optT) = P \vspace{3pt} \\
\<fdef> &::=& \<Fname>\ \<bpat>\ ...\ \<bpat> = E \\
\end{array} $$
\caption{Program syntax}
\figlabel{programsyntax}
\end{figure}

In \figref{programsyntax} a program is a sequence of process, function and variable definitions. Processes and functions are gathered into mutually-recursive groups.
\begin{itemize}
\item Process names \<Pname> start, by convention, with an upper-case letter; function names \<Fname> with a lower-case letter. (It's probably a silly convention because variable names $x$ can start with either case.) After the first letter, names continue with an alphanumeric sequence of characters.
\end{itemize}

\newcommand{\adot}{\;.\;}
\newcommand{\abar}{\;|\;}
\newcommand{\abang}{\;!\;}
\newcommand{\aquery}{\;?\;}
\var{alt,par,cond,decl}
\section{Process syntax (\setvar{P}, \setvar{IO}, \setvar{Q})}

Processes \<P> are where all the quantum stuff happens; expressions \<E> do classical calculations. Process syntax is detailed in \figref{processsyntax}: you can send and receive qubits in \<IO> steps, gate them or measure them in \<Q> steps. You can also send and receive classical values. But because qubits simulate strange quantum stuff, there are things you can't do with qubits, detailed in \secref{keepitreal}.

The notation is based on the pi calculus, enhanced with quantum steps and pattern matching. Steps are separated by dots rather than semicolons, and an empty step terminates a process. There are declarations, various ways of choosing between sub processes, parallel composition of sub processes, and a process can turn into another process. 
\begin{itemize}
\item $E!E,...,E$ sends a message: the first $E$ denotes the channel, and the non-empty tuple the values to be sent. The tuple doesn't need to be bracketed, as in the pi calculus. $E!()$ sends an empty tuple. 
\item $E ?(\<bpat>,..,\<bpat>)$ receives a message: the first $E$ denotes the channel, and the received values are bound to names in the bracketed tuple of \<bpat>s. $E?()$ receives an empty tuple. $E?(\_)$ accepts but ignores a message; $E?\_$ is allowed without the brackets.
\item $E,...,E>>E$ puts a non-empty tuple of qubits through the gate denoted by the final $E$. You are allowed to write conditional qubit-valued expressions in a gating step.
\item $q‚å¢Ã∏(\<bpat>)$ measures a single qubit, binding the single-bit result \verbtt{0b0} or \verbtt{0b1} with the bracketed pattern \<bpat>. The length of the qubit sequence must match the size of the gate it's put through -- e.g. X takes a single qubit, Cnot takes 2, Fredkin takes 3, and so on. Measurement takes place in the computational basis defined by \zero{} and \one. %If you have to measure several qubits, then at present you have to do it with a sequence of measurements: this is a deficiency in the language which doesn't really make a difference, so I haven't fixed it.
\item $q‚å¢Ã∏[E](\<bpat>)$ temporarily rotates the measurement basis with the gate denoted by E before measuring, and of course rotates it back afterwards. If the gate isn't some sort of rotation you won't be simulating reality. 
\begin{figure}
\centering \ensuremath{
\begin{array}{rcl}
\<IO>   &::=& E \abang E\ ,\ ...\ ,\ E \asep E \aquery (\<bpat>,\ ..\ ,\<bpat>) \asep E \aquery \_ \vspace{3pt} \\
Q       &::=& E, ... ,E \;>\!>\; E \asep q \;‚å¢Ã∏\; \optq{\;[E]\;}\;(\<bpat>) \vspace{3pt} \\
P       &::=& Q  \adot  P \asep \<IO>  \adot  P \asep \adot P \asep \<decl>\ P \asep \\
		&&    \<Pname>(E,\;..\;,E) \asep \<alt> \asep \<par> \asep \<cond> \asep (\ P\ )\ \asep  \vspace{3pt} \\
\<decl>	&::=& \verbtt{(new } x\optT,\; ...\; ,z\optT ) \asep
		      \verbtt{(newq } x\;\optq{=E}, \;...\; ,z\;\optq{=E} ) \asep 
		      \verbtt{(let}\ \<bpat>=E) \vspace{3pt} \\
\<cond>	&::=& \verbtt{if}\ E\ \verbtt{then}\ P\ \verbtt{else}\ P\ \optq{\verbtt{fi}} \asep
		      \verbtt{match}\ E\  \adot \ \optq{+}\;\<pat> \adot P\; +\; ... \;+\; \<pat> \adot P \vspace{3pt} \\
\<alt>	&::=& \optq{+}\; \<IO>  \adot  P \;+\; ... \;+\;\<IO>  \adot  P \vspace{3pt} \\
\<par>	&::=& \optq{\abar} P  \abar  ...  \abar  P 
\end{array}}
\caption{process syntax}
\figlabel{processsyntax}
\end{figure}
\item Dots separate process steps, and you can insert extra dots if you wish (I find it helps me with layout). A process can be bracketed. An empty process (really it's an empty \<alt>) means termination.
\item Declarations \<decl> -- \verbtt{new} for channels, \verbtt{newq} for qubits, \verbtt{let} for classical values -- are always bracketed. 
\item Nothing follows a process invocation, an \<alt>, a \<par>, a \<cond> or a bracketed process. That kind of austerity comes from the pi calculus, and makes it possible to run the checks described in \secref{keepitreal}.
\item A process invocation $\<Pname>(E,\;..\;,E)$ turns one process into another, an instantiation of the process \<Pname> with parameters $E,\;..\;,E$. It isn't a process \emph{call} because it never returns: it is possible, however, to mix process invocation, \<par>, and message passing so that the new process sends a message back to (part of) the old. Process names, by convention, start with a capital letter, but qtpi doesn't force other names to be lower case so it's a bit of a silly convention (sorry).
\item Conditionals \verbtt{if} and \verbtt{match} choose between processes depending on the value of the classical expression \<E>. The optional `\verbtt{+}' before the first alternative in \verbtt{match} makes offside parsing more effective.
\item Alternatives \<alt> choose between processes on the basis of messages sent or received. Each alternative starts with an \<IO> guard\footnote{Oh dear. Should send guards be allowed in an \<alt>? Probably unrealistic. Sorry about that.} and continues with a process. Just one of the guards will be allowed to succeed, and the corresponding process will be executed. The optional \verbtt{+} before the first alternative helps offside parsing.
\item Parallel composition \<par> makes a process become several processes, simulated in parallel. The optional bar before the first alternative helps offside parsing.
\end{itemize}

\section{Keep it real}
\seclabel{keepitreal}

Quantum bits are not classical bits, in more than the sense that they are not simply 0/1 values. There's a theorem of quantum mechanics which states that there can be no operation which takes a qubit in arbitrary state \bv{\phi} together with any number of other qubits and delivers a state in which there are two qubits each in state \bv{\phi}. No duplication, ever -- so there can be no analogue in quantum computation of the classical assignment $x:=y$. The designers of CQP \citep{GaySJ:comqp} wanted their language to exclude programs that can't really execute. Qtpi loyally follows suit.

Because qtpi is implemented, it isn't quite CQP: for one important thing, at each measurement it makes a probabilistic choice and follows it through, rather than splitting into two possible processes, labelling them with their probabilities, and following both as CQP would. There are some linguistic changes too, especially lifting quantum steps to the level of processes. And because I wanted it to be used, I had to devise ways of restricting the language which keep it real and which I could explain. I chose overkill and simple explanations. 

The sort of qubits that CQP and qtpi simulate are physical things -- atoms, molecules, photons, ... -- with quantised physical state such as spin or polarisation. It makes sense to send such a qubit from one protocol agent to another, and CQP is a language of communicating quantum processes which do just that. Agents can't share such a qubit -- it's in one place or another, not both. This doesn't handle every possible physical experiment: you \emph{might}, for example,  quantise the position of a photon as being with some probability on one of two paths towards detectors, but CQP and qtpi don't try to deal with that.

\begin{enumerate}
\item No uncertainty about naming.
\begin{itemize}
\item You cannot form lists or tuples of non-classical type. 
\item In a tuple of process arguments or values to be sent, a qubit-valued expression must be a single qubit name, and can appear only once in the tuple.
\end{itemize}
\item Functions deal with classical values.
\begin{itemize}
\item Functions cannot take arguments or return values of non-classical type.
\item A function body cannot refer to a free qubit.
\end{itemize}
\item No sharing within processes.
\begin{itemize}
\item A pattern in \verbtt{let} or \verbtt{match} cannot bind a qubit value.
\item A process parameter can be a single qubit or a classical value. In a tuple of process arguments, a qubit-valued argument must be a single qubit name, and can appear only once in the tuple.
\end{itemize}
\item When an agent sends a qubit in a message, it leaves its control and can't be used again (unless it's sent back). 
\begin{itemize}
\item Channels can carry either a single qubit or a classical value.
\item A qubit sent away can't be used later in the process unless redeclared.
\end{itemize}
\item No peeking at the simulation.
\begin{itemize}
\item Qubits can't be compared.
\item The library function \verbtt{show}, applied to a qubit, doesn't give information about its state; the function \verbtt{qval} does, but there are no operations on its result type \verbtt{qstate} other than send and receive.
\end{itemize}
\item No gating silliness.
\begin{itemize}
\item In a gated tuple of qubits, no qubit can be mentioned twice.
\end{itemize}
\item No sharing between sub processes.
\begin{itemize}
\item The qubits used in one arm of a \<par> must be distinct from those used in other arms.
\end{itemize}
\item And a random one.
\begin{itemize}
\item Qubit channels can't be used in \<alt> guards. (Perhaps this could be dropped for receive guards ...)
\end{itemize}

\end{enumerate}
\section{Types \setvar{T}}
\begin{figure}
\centering
\ensuremath{
\begin{array}{rcl}
T    &::=& \verbtt{num} \asep \verbtt{bool} \asep \verbtt{bit} \asep \verbtt{string} \asep \verbtt{char} \asep \verbtt{angle} \asep \verbtt{qubit} \asep \verbtt{gate} \asep \\
     &&    \verbtt{bra} \asep \verbtt{ket} \asep \verbtt{matrix} \asep \verbtt{sxnum} \asep \verbtt{qstate} \asep \<TV> \asep \\
     &&    ^{\wedge}\;T \asep [\;T\;] \asep (T\;,..\;,\;T) \asep T -> ... -> T \asep T\; \verbtt{process} \vspace{3pt} \\
\<TV> &::=& 'x \asep ''x \asep '{*}x   
\end{array}}
\caption{Type syntax}
\figlabel{typesyntax}
\end{figure}
Type syntax is in \figref{typesyntax}.
\begin{itemize}
\item List and tuple types are Miranda style rather than ML style: $[T]$ rather than $T\;\verbtt{list}$; $(T,\;...\;,T)$ rather than $T*\;...\;*T$. Zero-tuple is a type which contains only the value () (cf. ML `unit'); singleton $(T)$ is $T$.
\item \verbtt{num} is the type of numbers: unbounded integers and unbounded-precision rationals (fractions), so that qtpi can do accurate arithmetic.\footnote{Not having a type \verbtt{int} can cause some problems. Some library functions, such as \setvar{take} and \setvar{drop} for example, really don't work with fractional arguments (or, at least, I can't decide what they should do). In such cases you can make use of \setvar{floor}, \setvar{ceiling} and \setvar{round} to resolve problems.}
%\item CQP had range types; qtpi doesn't.
\item \verbtt{bool} is the type of booleans, \verbtt{true} or \verbtt{false}.
\item \verbtt{bit} isn't a subtype of \verbtt{num}.
\item \verbtt{sxnum} is the type of symbolic complex numbers, the values that qtpi's symbolic quantum calculator manipulates.
\item \verbtt{angle} is the type of arguments to sin and cos functions, rational multiples of $\pi$.
\item \verbtt{bra} is the type of unitary row vectors of \verbtt{sxnum}; \verbtt{ket} of unitary column vectors of \verbtt{sxnum}. A qubit state is a ket.
\item \verbtt{matrix}  is the type of matrices of \verbtt{sxnum}; \verbtt{gate} is the type of unitary square matrices.
\item \verbtt{qstate}  is the type of the result of the \setvar{qval}  function (see \secref{specialio}). It's a peek at the simulator state. But a \verbtt{qstate} can't be compared or manipulated in any way. The only useful thing you can do with a \verbtt{qstate}  is to send it down the \setvar{outq} output channel, which prints it out.
\item \verbtt{process} types are necessary in typechecking, but I think they are otherwise useless.
\item The syntactic precedence of types is more or less as listed, or so I hope and intend. 
\item Classical types are everything except \verbtt{qubit}  or those involving \verbtt{qubit}  (but function, process and channel types are classical whatever their internal types).  
\item Equality types are everything except \verbtt{qubit}, \verbtt{qstate} , function and process (or anything involving those).  
\item Channel types (types following $^{\wedge}$) are restricted: they may only be \verbtt{qubit} or classical.
\item Type variables \<TV> are \begin{itemize}
		\item $'x$, a classical type (no qubits);		
		\item $''x$, an equality type (no qubits, qstates, functions, processes);
		\item $'{*}x$, an everything type (includes qubits).
	\end{itemize}
\end{itemize}

\section{Patterns (\setvar{pat}, \setvar{bpat})}

\begin{figure}
\centering
\[
\begin{array}{rcl}
\<pat>   &::=& \_ \asep x \asep \<Const> \asep (\; \<pat>\; ,\; .. \;,\; \<pat>\; ) \asep [\; \<pat>\; ;\; ... \;;\; \<pat>\; ] \asep \<pat>\; ::\; \<pat> \asep \<pat>\ :\ T \vspace{3pt} \\
\<bpat>  &::=& \_ \asep x \asep (\; \<bpat>\; ,\; .. \;,\; \<bpat>\; ) \asep \<bpat>\ :\ T
\end{array}
\]
\caption{Pattern syntax}
\figlabel{patsyntax}
\end{figure}

In matches \<pat> disambiguates lists and tuples and constants. In lets and fdefs, \<bpat> binds names to values, including elements of tuples, and never fails to match. The syntax is in \figref{patsyntax}: a \<pat> can be an empty list; both \<pat> and \<bpat> can be a zero-tuple, a bracketed pattern, or a multi-tuple. Patterns can be typed (but may then need to be bracketed).

\section{Expressions \setvar{E}}

Expressions are as in \figref{expressionsyntax}: constants, names, tuples (including the zero tuple); lists; function applications (by juxtaposition, and left associative so that $E\;E\;E$ is $(E\;E)\;E$); arithmetic and boolean expressions including matrix arithmetic; conditionals. Expressions can be typed.
\var{arithop,compop,logop,elsepart}
\begin{figure}
\centering
\[
\begin{array}{rcl}
E  		&::=&	\<Const> \asep x \asep (\ E\ ,\ ..\ ,\ E\ ) \asep [\ E\ ;\ ...\ ;\ E\ ] \asep E\ E\ \asep E\ :\ T \asep \\
		&&		\verbtt{-}\ E \asep \verbtt{¬¨}\ E \asep E\ ^{\dag} \asep E\ \<arithop>\ E \asep E\ \<compop>\ E\ \asep E\ \<logop>\ E \asep \\
		&&		E\;@\;E \asep E\;::\;E \asep \\
	  	&&		\verbtt{if}\ E\ \verbtt{then}\ E\ \<elsepart> \asep \verbtt{match}\ E\  \adot \ \optq{+}\;\<pat> \adot E\; +\; ... \;+\; \<pat> \adot E \asep \\
		&&		Œª\ \<bpat>\ ...\ \<bpat>\ \adot\ E \vspace{3pt}\\
\<arithop>	&::=&	\verbtt{+}\ \asep \verbtt{-}\ \asep \verbtt{*}\ \asep \verbtt{/}\ \asep \verbtt{\%}\ \asep \verbtt{‚äó} \asep \verbtt{**}\ \asep \verbtt{‚äó‚äó} \vspace{3pt}\\
\<compop>	&::=&	\verbtt{<}\ \asep \verbtt{<=}\ \asep \verbtt{=}\ \asep \verbtt{>=}\ \asep \verbtt{>}\ \asep \verbtt{<>} \vspace{3pt}\\ 
\<logop>	&::=&	\verbtt{\&\&}\ \asep \verbtt{||} \vspace{3pt}\\ 
\<elsepart>	&::=& \verbtt{else}\ E\ \optq{\verbtt{fi}} \asep \verbtt{elif}\ E\ \verbtt{then}\ E\ \<elsepart>
\end{array}
\]
\caption{Expression syntax}
\figlabel{expressionsyntax}
\end{figure}

\subsection{Constants \setvar{Const}}

\begin{itemize}
\item integers;
\item chars \verbtt{'}c\verbtt{'} with the usual escapes -- \textbackslash{n}, \textbackslash{r}, \textbackslash{t} and even \textbackslash{b} (why?);
\item strings \verbtt{"}char..char\verbtt{"} with escapes as for chars;
\item bit constants \verbtt{0b0} and \verbtt{0b1};
\item ket constants \zero, \one, \plus{} and \minus, plus longer versions like \bv{001} and \bv{+-+} and so on and on;
\item bra constants \vb{0}, \vb{1}, \vb{+}, \vb{-}, plus longer versions as for kets; 
\item sxnum constants \verbtt{sx\_0}, \verbtt{sx\_1}, plus functions in library;
\item the zero-tuple () (no one-tuple, and tuples are \emph{always} bracketed) and the empty list [];
\item the angle constant ùùÖ
%  * There is no one-tuple.   
%  * Tuples are always bracketed, as in Miranda.  
%  * Match expressions are parsed with the offside rule: the components can't start left of `match`, and the patterns and right-hand-side expressions have to be right of `+`. (Explicit match expressions will one day disappear, I hope, in favour of Miranda-style matching on function parameters.)  
%  * Function applications are *E* *E* -- juxtaposition. And of course left associative, so that *E* *E* *E* is (*E* *E*) *E*.  There's a function library (see below) and perhaps one day there will be downloadable bundles of functions.  
%  * Absolutely no process stuff, no manipulation of qubits. But see \verbtt{print\_string}, \verbtt{print\_strings} and \verbtt{print\_qubit} below.  
\end{itemize}

\subsection{Typechecking expressions}

Expressions can mention qubits, but because of the need to police sharing and duplication, qubit-valued expressions can only be used when gating. Typechecking is mostly straightforward -- comparison operators compare equality types, logical operators deal with booleans, application $E\ E$ is $'a\;->\;'a$ and left-associative -- but arithmetic operators are heavily overloaded.
\begin{itemize}
\item unary `\verbtt{+}' and `\verbtt{-}' are $t->t$, where $t$ is \verbtt{num}, \verbtt{angle} or \verbtt{sxnum};
\item binary `\verbtt{+}' and `\verbtt{-}' are $t->t->t$, where $t$ is \verbtt{num}, \verbtt{angle}, \verbtt{sxnum} or \verbtt{matrix};
\item `\verbtt{*}' can be 
\begin{itemize}
	\item $t->t->t$, where $t$ is \verbtt{num}, \verbtt{angle}, \verbtt{sxnum}, \verbtt{gate} or \verbtt{matrix}
	\item $\verbtt{num}->\verbtt{angle}->\verbtt{angle}$, $\verbtt{angle}->\verbtt{num}->\verbtt{angle}$, $\verbtt{gate}->\verbtt{ket}->\verbtt{ket}$, $\verbtt{ket}->\verbtt{bra}->\verbtt{matrix}$, $\verbtt{bra}->\verbtt{ket}->\verbtt{sxnum}$, $\verbtt{matrix}->\verbtt{sxnum}->\verbtt{matrix}$, $\verbtt{sxnum}->\verbtt{matrix}->\verbtt{matrix}$;
\end{itemize}
\item `\verbtt{/}' is $t->\verbtt{num}->t$, where $t$ is \verbtt{num} or \verbtt{angle};
\item `\verbtt{\%}' (mod) and `\verbtt{**}' (exp) are $\verbtt{num}->\verbtt{num}->\verbtt{num}$;
\item `\verbtt{‚äó}' (tensor mult) is $t->t->t$, where $t$ is \verbtt{bra}, \verbtt{ket}, \verbtt{gate} or \verbtt{matrix};
\item `\verbtt{‚äó‚äó}' (tensor exp) is $t->\verbtt{num}->t$, where $t$ is \verbtt{bra}, \verbtt{ket}, \verbtt{gate} or \verbtt{matrix};
\item `\verbtt{::}' (cons) is $'t->['t]->['t]$;
\item `\verbtt{@}' (append) is $['t]->['t]->['t]$;
\item `\ensuremath{^{\dag}}' (conjugate transpose) is $\verbtt{gate}->\verbtt{gate}$ or $\verbtt{matrix}->\verbtt{matrix}$.
\end{itemize}


\section{Built-in i/o channels, \verbtt{show} and \verbtt{qval}}
\seclabel{specialio}

There's an input channel $\verbtt{in}:\; \caret{}\verbtt{string}$; there are output channels $\verbtt{out}: \caret{}[\verbtt{string}]$ and $\verbtt{outq}: \caret{}\verbtt{qstate}$. Writing to the input channel, or reading from an output channel, is a run-time error because I don't know how to do the typechecking.
\begin{itemize}
\item \verbtt{in?(s)} reads a line from standard input and delivers it as a string. 
\item \verbtt{out![s1; .. ;s2]} writes strings on standard output. 
\item $\verbtt{show}:\; '{*}t->\verbtt{string}$ takes any value and produces a string. It produces `\verbtt{<qubit>}' for a qubit, `\verbtt{<qstate>}' for a qstate, to stop computational cheating. It treats functions, processes and channels similarly opaquely, but for more familiar reasons.
\item $\verbtt{qval}:\; \verbtt{qubit} ->\verbtt{qstate}$ takes a qubit and produces a description of its state. Useful for tracing and debugging, but to stop cheating the only thing you can usefully do with a qstate is to send it out along the \verbtt{outq} channel.
\item \verbtt{outq!qs} writes a string representing qubit state \verbtt{qs} on standard output; a string $\#i:V$, the qubit's index $i$ and a representation $V$ of its state as a symbolic-number vector in the computational basis -- including, if there is entanglement, a list of the indices of the qubits it's entangled with.
.
\end{itemize}

The \verbtt{outq} chanel is peculiar for good reason. It allows logging of a qubit's state, but it couldn't be a channel which takes a qubit, because if you send a qubit down a channel, you lose it. So there's \verbtt{qval} to help out: \verbtt{outq!qval q} is safe, if annoying. 

\section{Symbolic calculation}

Qtpi uses a symbolic quantum calculator: only during quantum measurement does it calculate numerically and possibly approximately. This enables it to do some nice tricks, like accurately `teleporting' a qubit whose value is unknown. It also means that it can do exact calculations.

Qubits are represented as integer indices into a quantum state of unitary vectors in the computational basis defined by \zero{} and \one. An unentangled qubit indexes a pair of complex-valued amplitude expressions $(A, B)$ representing $A\zero+B\one$; either $A$ or $B$ may be zero, and always $|A|^{2}+|B|^{2}=1$. A simply-entangled pair of qubits $\#i$ and $\#j$ each index a quadruple $(A,B,C,D)$, representing $(A\zerozero+B\zeroone+C\onezero+D\oneone)$ where $|A|^{2}+|A|^{2}+|B|^{2}+|C|^{2}+|D|^{2}=1$ and, again, some of $A$, $B$, $C$ and $D$ may be zero. And so on for larger entanglements: famously, $n$ qubits need $2^{n}$ amplitudes.

If $\#i${} is an `unknown' qubit, created by a \verbtt{newq} declaration without specifying a state, then its amplitudes are variables $a_{i}$ and $b_{i}$. The variables do have a secret value that is used when measuring the qubit or anything it's entangled with, but calculation uses only the uninterpreted variables and the fact that $|a_{i}|^{2}+|b_{i}|^{2}=1$.

Symbolic calculation uses the type \verbtt{sxnum}, which involves fractions (\verbtt{num}), variables, square roots of \verbtt{num}s ($\verbtt{sx\_sqrt}: \verbtt{num}->\verbtt{sxnum}$), $\sin$ and $\cos$ of fractions of $\pi$ (\verbtt{sx\_sin} and \verbtt{sx\_cos} are each $\verbtt{angle}->\verbtt{sxnum}$). It's remarkably effective.\footnote{It used to be based on powers of $\sqrt{1/2}$. No longer.}

\section{Non-unitary modulus}

Because it is unitary, the amplitudes of a ket\footnote{A column vector.}) which represents a qubit or a collection of qubits\footnote{Possibly entangled.} should be such that the sum of their absolute squares\footnote{The product of an amplitude with its complex conjugate, written $|a|^{2}$.}) should be 1. But when the amplitude formulae are very complicated it can sometimes be difficult for qtpi's calculator to normalise the result. So kets carry a modulus, the sum of the squares of its amplitudes. Normally this is 1, and then not mentioned, but otherwise the vector is printed prefixed by \verbtt{<<}$M$\verbtt{>>}, where $M$ is the sum of the absolute squares of its amplitudes. The interpretation is that every amplitude in the vector is divided by $\sqrt{M}$, and this is taken into account numerically during measurement.

\subsection{Complex amplitudes}

Amplitudes always represent complex numbers $x+iy$, but often $y$ is zero. The absolute square is always a real number.

\section{Pre-defined gates}

The built-in library defines various named gates. Mostly arity 1, except Cnot which is arity 2, F and T, which are arity 3. For definitions see the Wikipedia pages `Quantum logic gates' and `list of quantum logic gates'. But note: qtpi's versions of $Rx$, $Ry$ and $Rz$ are slightly different to the wiki ones -- period $2\pi$ rather than $4\pi$, suitable for polarised photons rather than spinning electrons. 

\begin{itemize}
\item  H, the Hadamard gate, takes \zero{} to $\frac{1}{\sqrt{2}}(\zero+\one)$, \one{} to $\frac{1}{\sqrt{2}}(\zero-\one)$. A kind of $45\deg$ or $\frac{\pi}{4}$ rotation -- but note, H*H=I.
\item I takes \zero{} to \zero, \one{} to \one. Identity.
\item X  takes \zero{} to \one{} and vice-versa. Exchange, inversion, not.
\item Z  takes \zero{} to \zero, \one{} to -\one{}. (dunno what to call it.)
\item Y  takes \zero{} to $-i$\one{}, \one{} to $i$\zero{}. (In some descriptions, Y is equivalent to Z*X. Qtpi has the Pauli version.)
\item Cnot takes \onezero{} to \oneone{} and vice-versa, otherwise an identity. (Controlled-not). Also spelled as `CNot` and `CNOT`. Same as CX.
\item CX, CY, CZ. Each treat \zerozero{} and \zeroone{} as I treats \zero{} and \one, and treat \onezero{} and \oneone{} as X, Y, Z treat \zero{} and \one{}. If you see what I mean ...
\item Swap takes \zeroone{} to \onezero{} and vice versa; otherwise an identity. Also spelled as `SWAP`.
\item F, the Fredkin gate, takes \onezeroone{} to \oneonezero{} and vice-versa, otherwise an identity. Also spelled as `Cswap`, `CSwap` and `CSWAP`.
\item T, the Toffoli gate, takes \oneonezero{} to \oneoneone{} and vice-versa, otherwise an identity. (Controlled-controlled-not). \vspace{5pt}

\item phi: $\verbtt{num}->\verbtt{gate}$ -- phi 0=I; phi 1=X; phi 2=Z; phi 3=Y; otherwise undefined. \vspace{5pt}

\item Rx, Ry and Rz are each rotation matrix functions, $\verbtt{angle}->\verbtt{gate}$. Note period $2\pi$ rather than $4\pi$.
  \begin{itemize}
  \item $\verbtt{Rx}\;\theta = \qgate{\cos\theta}{-i\sin\theta}{-i\sin\theta}{\cos\theta}$
  \item $\verbtt{Ry}\;\theta = \qgate{\cos\theta}{-\sin\theta}{\sin\theta}{\cos\theta}$
  \item $\verbtt{Rz}\;\theta = \qgate{\cos\theta-i\sin\theta}{0}{0}{\cos\theta+i\sin\theta}$
  \end{itemize}
\end{itemize}
  
\section{The \verbtt{dispose} channel}

Qubits can be discarded: Alice sends one to Bob, Bob receives it, measures it, remembers the result, and then waits for the next one. The qubit is destroyed on detection (unless you use the switch \verbtt{-measuredestroys false}), and it vanishes from the simulation. A vanished qubit is in fact recycled.

Qubits that aren't measured, and even measured qubits with \verbtt{-measuredestroys false}, live for ever. Sometimes this is inconvenient -- it muddies the waters if you are debugging, for example. To solve this problem there is a \verbtt{dispose}: $\caret{}\verbtt{qubit}$ channel: send a qubit down the \verbtt{dispose} channel and it vanishes. It will be made available to be recycled, unless it is entangled, in which case it may be made available later if the entanglement collapses, or it is an unknown, in which case it will be forever in limbo. Like any sent-away qubit, you can't use it once it's disposed.

Reading from \verbtt{dispose} is a run-time error, because I don't know how to typecheck send-only channels. At one time I thought it might be a source of qubits, but that would be to carry a joke too far.

\chapter{The library}

\newenvironment{explain}{\list{}{}\item\relax}{\endlist}
\newcommand{\libitem}[2]{\hspace{10pt}\verbtt{#1}\vspace{-\topsep}\vspace{-\parskip}\begin{explain}#2\vspace{-\parskip}\end{explain}}
\newcommand{\libitemS}[1]{\libitem{#1}{\mbox{}\vspace{-\topsep}\vspace{-\topsep}}}
Much of the library is inspired by Miranda, and by Bird \& Wadler's "Introduction to Functional Programming". Their descriptions of the functions are better than mine, too: wish I'd included pattern-matching function definitions.

Almost all functions take classical arguments (\verbtt{'a} rather than \verbtt{'*a}). None (except for the absurd case of \verbtt{abandon}) returns a value of a non-classical type.
    
Qtpi doesn't have an \verbtt{int} type, but several of the library functions insist on whole-number arguments: \verbtt{bitand}, \verbtt{drop}, \verbtt{nth}, \verbtt{num2bits}, \verbtt{randbits}, \verbtt{tabulate}, \verbtt{take}. If this causes a problem, use \verbtt{floor}, \verbtt{round} or \verbtt{ceiling} on the arguments.

\subsection{List functions}
\libitem{append: ['a] $->$ ['a] $->$ ['a]}{concatenates its arguments.}
\libitem{concat: [['a]] $->$ ['a]}{concatenates the lists in its first argument.}
\libitem{drop: num $->$ ['a] $->$ ['a]}{$drop\;n\;xs$ returns $xs$ without the leading segment which $take\;n\;xs$ would return.}
\libitem{dropwhile: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$dropwhile\;f\;xs$ returns $xs$ without the leading segment which $takewhile\;f\;$ would return.}
\libitem{exists: ('a $->$ bool) $->$ ['a] $->$ bool}{$exists\;f\;xs$ is true iff there is an element of xs for which $f$ returns true.}
\libitem{filter: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$filter\;f\;xs$ returns $xs$ without those elements for which $f$ returns false.}
\libitem{foldl: ('a $->$ 'b $->$ 'a) $->$ 'a $->$ ['b] $->$ 'a}{$foldl\;f\;z\;[x_{1};\,...\, ;\,x_{n}]$ is $f\;(...\;(f\;(f\;z\;x_{1})\;x_{2})\;...)\;x_{n}$.}
\libitem{foldr: ('a $->$ 'b $->$ 'b) $->$ 'b $->$ ['a] $->$ 'b}{$foldr\;f\;z\;[x_{1};\,...\, ;\,x_{n}]$ is $f\;x_{1}\;(f\;x_{2}(...\,(f\;x_{n}\;z)\,...))$.}
\libitem{forall: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$forall\;f\;xs$ is true iff $f$ returns true for each element of xs.}
\libitem{hd: ['a] $->$ 'a}{$hd\;xs$ returns first element of $xs$; fails if $xs$ is empty.}  
\libitem{iter: ('a $->$ 'b) $->$ ['a] $->$ unit}{not sure this should be in the library.}
\libitem{length: ['a] $->$ num}{$length\;xs$ returns the number of elements in $xs$.}  	
\libitem{map: ('a $->$ 'b) $->$ ['a] $->$ ['b]}{$map\;f\;[x_{1};\,...\, ;\,x_{n}]$ is $[f\;x_{1};\,...\, ;\,f\;x_{n}]$.}
\libitem{mzip: ['a] $->$ ['b] $->$ [('a,'b)]}{turns two lists into a list of pairs; result is the length of the shorter list (as in Miranda).}
\libitem{nth: ['a] $->$ num $->$ 'a}{$nth\;i\;xs$ returns the $i$th element of $xs$ (counting from 0); fails if $i$ is negative, fractional or too large. (As in OCaml.)}
\libitem{rev: ['a] $->$ ['a]}{reverses its argument.}
\libitem{sort: (''a $->$ ''a $->$ num) $->$ [''a] $->$ [''a]}
		{sorts according to order defined by first argument -- 0 for $a=b$, -1 for $a<b$, 1 for $a>b$ (as C/OCaml).}
\libitem{tabulate: num $->$ (num $->$ 'a) $->$ ['a]}{$tabulate\;n\;f$ is $map\;f\;[0..n-1]$.}
\libitem{take: num $->$ ['a] $->$ ['a]}{$take\;n\;xs$ returns the first $n$ elements of $xs$; [] if $n$ is negative or zero; $xs$ if $n$ is too large.}
\libitem{takewhile: ('a $->$ bool) $->$ ['a] $->$ ['a]}{returns the longest initial segment of $xs$ for which $f$ returns true on every element.}
\libitem{tl: ['a] $->$ ['a]}  
	    {returns all but the first element of $xs$; fails if $xs$ is empty.}  
\libitem{unzip: [('a,'b)] $->$ (['a], ['b])}{turns a list of pairs into a pair of lists.}
\libitem{zip: ['a] $->$ ['b] $->$ [('a,'b)]}{turns two lists into a list of pairs; fails if the lists aren't the same length (as in OCaml).}

\subsection{Tuple functions}
\libitem{fst: ('a, 'b) $->$ 'a}{$fst\;(a,b)=a$}
\libitem{snd: ('a, 'b) $->$ 'b}{$snd\;(a,b)=b$}
 
\subsection{Gate and matrix functions}
\libitem{degate: gate $->$ matrix}{simple type conversion.}
\libitem{engate: matrix $->$ gate}{type conversion; fails if argument is not $2^{n}\times2^{n}$ and unitary ($M*M^{\dag}=I^{‚äón}$).}
\libitem{makeC: gate $->$ gate}{makes the `C\_' version of a $2\times2$ gate. $makeC\;X$, for example, is CX.}
\libitem{phi: num $->$ gate}{$phi\;0=I$; $phi\;1=X$; $phi\;2=Z$; $phi\;3=Y$; fails otherwise.}
\libitem{tabulate\_m: num $->$ num $->$ (num $->$ num $->$ sxnum) $->$ matrix}{$tabulate\_m\;r\;c\;f$ builds a matrix with $r$ rows and $c$ columns such that $M_{i,j}=f\;i\;j$.}
\libitem{tabulate\_diag\_m: num $->$ (num $->$ sxnum) $->$ matrix}{$tabulate\_diag\_m\;n\;f$ builds a diagonal $n\times{}n$ matrix such that $M_{i,i}=f\;i$ and off-diagonal elements are 0.}

\subsection{Numerical functions}
\libitem{ceiling: num $->$ num}{$ceiling\;i$ is the smallest integer not less than $i$}
\libitem{floor: num $->$ num}{$floor\;i$ is the largest integer not greater than $i$}
\libitem{max: num $->$ num $->$ num}{maximum}
\libitem{min: num $->$ num $->$ num}{minimum}
\libitem{pi: num}{a constant, approximately $\pi$.}
\libitem{round: num $->$ num}{$round\;i$ is the floor of $i+1/2$, if $i>=0$; the ceiling of $i-1/2$, if $i<0$.}
\libitem{sqrt: num $->$ num}{an approximation to square root; fails if argument is negative.}

\subsection{Bit functions}
\libitem{bitand: num $->$ num $->$ num}{bitwise `\&\&'.}
\libitem{bits2num: [$bit$] $->$ num}{convert to integer.}
\libitem{num2bits: num $->$ [$bit$]}{convert from integer; fail if negative or fractional.}

\subsection{Random functions}
\libitem{randbit: unit $->$ bit}{a single random bit.}
\libitem{randbits: num $->$ [$bit$]}{$randbits\;n$ is a sequence of $n$ random bits; fails if $n$ is negative or fractional.}
\libitem{randbool: unit $->$ bool}{a random boolean.}
\libitem{randp: num $->$ bool}{$randp\;p$ is a random boolean with probability $p$ of being true; fails unless $0\leq{}p\leq{}1$.}

\section{Symbolic-number functions}
\libitem{sx\_cos: angle $->$ sxnum}{$sx\_cos\;a$ is the \verbtt{sxnum} representing $\cos{a}$.}
\libitem{sx\_sqrt: num $->$ sxnum}{$sx\_sqrt\;n$ is the \verbtt{sxnum} representing $\sqrt{n}$.}
\libitem{sx\_sin: angle $->$ sxnum}{$sx\_sin\;a$ is the \verbtt{sxnum} representing $\sin{a}$.}
\libitem{sx\_0: sxnum, sx\_1: sxnum, sx\_i: sxnum}{constants representing 0, 1 and $\sqrt{-1}$.}

\subsection{Input-output functions}
\libitem{read\_alternative: string $->$ string $->$ [(string,'a)] $->$ 'a}
	    {$read\_alternative\;prompt\;sep\;[(s_{0},v_{0});\,(s_{0},v_{0});\,..]$ prints $prompt$ followed by the $s_{i}$s separated by $sep$; it insists that the user inputs one of the $s_{i}$s, and returns the corresponding $v_{i}$.}
\libitem{read\_bool: string $->$ string $->$ string $->$ bool}
	    {$read\_bool\;prompt\;y\;n$ is a version of $read\_alternative$ in which $y$ is the $s_{i}$ which returns \verbtt{true} and $n$ the one which returns \verbtt{false}.}
\libitem{read\_num: string $->$ num}{$read\_num\;prompt$ returns the number which the user inputs (it insists on a number).}
\libitem{read\_string: string $->$ string}{$read\_string\;prompt$ returns the string which the user inputs (an input line, without the newline).}  
\libitem{print\_qubit: qubit $->$ unit}
	    {$print\_qubit\;q$ has the same effect as \verbtt{outq!(qval q)}. (I think it's still possible to use it, but barely so.)}
\libitem{print\_string: string $->$ unit}
	    {$print\_string\;E$ has the same effect as \verbtt{out![E]}.}
\libitem{print\_strings: [string] $->$ unit}
	    {$print\_strings\;Es$ has the same effect as \verbtt{out!Es}.}

\subsection{Miscellaneous}
\libitem{abandon: [string] $->$ '*t}{stops the program, printing its argument, and doesn't return. For typechecking purposes, pretends to returns a value (which might be any type).}
\libitem{compare: ''a $->$ ''a $->$ num}
	{\verbtt{compare a b} returns 0 for $a=b$, -1 for $a<b$, 1 for $a>b$ (as C/OCaml)}
\libitem{const: 'a $->$ 'b $->$ 'a}{$const\; k\; x = k$}
\libitem{memofun: ('a $->$ 'b) $->$ 'a $->$ 'b}{makes a `memo function' of its argument: a function which remembers arguments with which it has been called and avoids recalculation. (Oh dear.)}
\libitem{qval: qubit $->$ qstate}{constructs an opaque value, of type \verbtt{qstate}, which describes the state of a qubit. The only thing you can usefully do with the value is send it down the \verbtt{outq} channel.}
\libitem{qvals: qubits $->$ qstate}{\verbtt{qval} for qubit collections. See \secref{specialio}.}
\libitem{show: '{*}a $->$ string}{converts a value, of arbitrary type, to a string. Gives a deliberately opaque result if applied to a qubit, function, process, channel or qstate. (Actually it's not really a function, more a sort of macro description for a family of functions, one for each type.)} 
\libitem{showf: num $->$ num $->$ string}{$showf\;i\;n$ returns a string representing $n$ as a decimal fraction to $i$ decimal places.} 


\bibliographystyle{plainnat}
\bibliography{quantum} 

\end{document}