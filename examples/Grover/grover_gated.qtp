fun compose (f : 'b -> 'a) (g : 'c -> 'b) (v : 'c) : 'a = f (g v)

fun semicolon (g : 'c -> 'b) (f : 'b -> 'a) : ('c -> 'a) = compose f g

fun read_min_int m s
  = k where k = if j>=m then j 
                else semicolon (Î» _ . print_strings ["pardon? at least "; show m; "\n"])
                               (Î» _ . read_min_int m s)
                               ()
      where j = read_num s

proc 
  System () =
    . (let n = read_min_int 2 "number of bits")
    
    . (let bs = randbits n) (* should this be rev'd, for big-endian? *)
    . (let iters = floor (pi*sqrt(2**n)/4+0.5))
    . out!["grover "; show n; " bs = "; show bs; "; "; show iters; " iterations"; "\n"]
    
    . (let Hn = HâŠ—âŠ—n) (let Xn = XâŠ—âŠ—n)
    (* main iteration *)
    . (newq aux = |->)
    . (newqs qs = |+>âŠ—âŠ—n)  
    . (newqs ancs = |0>âŠ—âŠ—(n-1)) 
    . (let ns = tabulate n (Î» i. i))
    . ğ„† iâ†tabulate iters (Î» i. i):
        . (* oracle *) â1
              . (* invert the zero address bits *)
              . ğ„† (j,k)â†zip bs ns: . qsâ†“k >> (if j=0b0 then X else I) .  
              . (* MCT(U) should be a subprocess, but I'm not allowed subprocesses *)
              . qsâ†“0,qsâ†“1,ancsâ†“0>>T
              . ğ„† kâ†tabulate (n-2) (Î» i. i): qsâ†“(k+2),ancsâ†“k,ancsâ†“(k+1)>>T . 
              . ancsâ†“(n-2),aux>>CNot
              . ğ„† kâ†rev (tabulate (n-2) (Î» i. i)): qsâ†“(k+2),ancsâ†“k,ancsâ†“(k+1)>>T . 
              . qsâ†“0,qsâ†“1,ancsâ†“0>>T
              . (* de-invert the address bits *)
              . ğ„† (j,k)â†zip bs ns: . qsâ†“k >> (if j=0b0 then X else I) . 
        . (* diffuser *) â10
              . qs>>>Hn â11
              . qs>>>Xn â12
              . (* MCZ *)
              . qsâ†“0,qsâ†“1,ancsâ†“0>>T
              . ğ„† kâ†tabulate (n-2) (Î» i. i): qsâ†“(k+2),ancsâ†“k,ancsâ†“(k+1)>>T . 
              . ancsâ†“(n-2),aux>>CX
              . ğ„† kâ†rev (tabulate (n-2) (Î» i. i)): qsâ†“(k+2),ancsâ†“k,ancsâ†“(k+1)>>T . 
              . qsâ†“0,qsâ†“1,ancsâ†“0>>T â20
              . qs>>>Xn â21
              . qs>>>Hn â22
        .  ğ„‡

    . out!["finally "] . outq!showq qs . out!["\n"]
    
    . qsâŒ¢âƒ«(bs') 
    . out!["measurement says "; show bs'; 
           if bs=bs' then " ok" else " ** WRONG **"; "\n"] 
    . 

            with 1: out!["iterated oracle\n"] . out!["before oracle "; show i; " "] . outq!showq qs . out!["\n"] . 
                 10: out!["iterated diffuser\n"] . out!["before diffuser "; show i; " "] . outq!showq qs . out!["\n"] . 
                 11: out!["after diffuser "; show i; "'s  HâŠ—âŠ—n "] . outq!showq qs . out!["\n"] . 
                 12: out!["after diffuser "; show i; "'s  XâŠ—âŠ—n "] . outq!showq qs . out!["\n"] . 
                 20: out!["after diffuser "; show i; "'s  MCX "] . outq!showq qs . out!["\n"] . 
                 21: out!["after diffuser "; show i; "'s  second XâŠ—âŠ—n "] . outq!showq qs . out!["\n"] . 
                 22: out!["after diffuser "; show i; "'s  second HâŠ—âŠ—n "] . outq!showq qs . out!["\n"] . 
(* multiple controlled Toffoli ... *)
(* proc MCU () 

*)