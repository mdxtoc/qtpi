proc Alice(n:int, qB, bsB, report) = 
  (new chosen) 
  (  Choose (n,[],chosen)
   | chosen?(bvs) . 
     report!map fst bvs .
     report!map snd bvs .
     (new sent)
     (  SendBits (bvs, qB, sent)
      | sent?(_) .
        Negotiate (bvs, bsB, report)
     )
  )
  
(* choose n basis,bit pairs -- this could all be done with Random *)
proc Choose(n, bvs, chosen) =
    (let bs = randbits n) (let vs = randbits n) chosen!zip bs vs . _0

(* send encoded bits down channel qB *)
proc SendBits (bvs,qB,sent) =   
    match bvs .
        []         . sent!() . _0
    <+> (b,v)::bvs . (newq q = match b,v .
                                   0b0,0b0 . |0> 
                               <+> 0b0,0b1 . |1> 
                               <+> 0b1,0b0 . |+> 
                               <+> 0b1,0b1 . |-> 
                               hctam
                     )
                     qB!q.
                     SendBits(bvs,qB,sent)
    hctam

proc Negotiate (bvs,bsB,report) =
    bsB!map fst bvs   . (* send him my bases *)
    bsB?(bBs)         . (* receive his bases *)
    report!bBs        . (* report his bases *)
    (let rvs = reconcile bBs bvs)
    report!rvs        . (* report my reconciliation *)
    bsB?(mask)        . (* A mask of rvs: 0b1 if sampled *)
    report!mask       . (* report his mask *)
    bsB?(sample)      . (* the corresponding bits from vs *)
    report!sample     . (* report his sample *)
    (let ok = test_checkbits mask sample rvs)
    (let code = mask_filter 0b0 mask rvs)
    report!if ok then 0b0 else 0b1 fi::code . 
    bsB?(codedvs)     .
    report!codedvs    .
    report!(xor_mask code codedvs) .
    _0
