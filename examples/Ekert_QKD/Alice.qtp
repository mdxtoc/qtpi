proc Alice(nq,m,qc,ic,bc,logc,verbose) = 
  (new rc) 
    | AliceRead (nq,qc,rc,[])
    | rc?(bvs)    .
      (let bs = map fst bvs)
      ic!bs     .
      ic?(bBs)  .
      (let bBbvs = combine bBs bvs)
      (let vAs = sanitise bBbvs)
      bc!vAs   . (* send Bob the values, where we used different bases *)
      bc?(vBs) .
      (* we can do the non-interference check for all the orientations, but while we have a slow
         interpreter, two each for Alice and Bob sort of gives coverage.
       *)
      if not (check verbose bs bBs vAs vBs (0,1) && check verbose bs bBs vAs vBs (1,2)) then (* we have interference *)
        bc![bool2bit false] .
        out!["Alice detects interference\n"] .
        logc![] .
        _0
      else 
        bc![bool2bit true]  .
        bc?(go)             .
        if bit2bool (hd go) then (* Bob says ok too *)
          (let key = map snd (filter (lam ((b,b'),v') . b=b') bBbvs))
          (let message = randbits m)
          (* out!["Alice sends  "; show message; "\n"] . *)
          bc!xor_mask (take m key) message   .
          logc!message              .
        _0
        else
          logc![] .
          _0
        fi
      fi

proc AliceRead (nq,qc,rc,bvs) = 
  if nq=0 then rc!rev bvs . _0
  else
    qc?(q) . (new r) | AliceMeasure (q,r) | r?(bv) . AliceRead (nq-1,qc,rc,bv::bvs)
  fi

proc AliceMeasure (q,r) =
  match rand4() . 
    + 0 . q-/-[]    (b) . r!0,b . _0
    + 1 . q-/-[F]   (b) . r!1,b . _0
    + 2 . q-/-[F*F] (b) . r!2,b . _0
    + _ . AliceMeasure (q,r) (* 3 - try again *)
