proc Bob (qA, bsA, againA, log) = 
    (new received) 
    (  ReceiveBits([],qA,bsA,received)
     | received?(bs)                . (* bs, vs is what I saw *)
       received?(vs)                .
            log!bs               .
            log!vs               .
       received?(bAs)               . (* receive her bases *)
            log!bAs              .
       bsA!bs                       . (* send my bases *)
            log!bs               .
       (let rvs = reconcile bAs bs vs) (* the bits we should agree on *)
            log!rvs              .
       (let mask = tabulate (length rvs) cb_choose)
       (let checkbits = mask_filter 0b1 mask rvs)
       bsA!mask                     . (* send her the mask *)
       bsA!checkbits                . (* send her the checkbits *)
            log!mask             .
            log!checkbits        .
       (let codebits = mask_filter 0b0 mask rvs)
       (    againA?(_)       .      log![bool2bit true]  .
                               Bob (qA, bsA, againA, log)
        <+> bsA?(encryptedM) .      log![bool2bit false] .
                               (let code = take (length encryptedM) codebits)
                               (let M = xor_mask encryptedM code)
                                    log!encryptedM       .
                                    log!code             .
                                    log!M                .
                               _0
       )
    )
  
(* receive qbits, measure them, log the results when you see her bases *)
proc ReceiveBits(bvs,qA,bsA,results) =
      bsA?(bases) . (let bvs = rev bvs)
                    results!map fst bvs . 
                    results!map snd bvs . 
                    results!bases       .
                    _0
  <+> qA?(q)      . (let basis = randbit ())
                    q =?[if basis=0b1 then _H else _I fi] (value) .
                          dispose!q                               .
                    ReceiveBits((basis,value)::bvs,qA,bsA,results)
