(* given a random qbit (a|0>+b|1>), this may terminate with
   either a|0>+b|1> or a|0>-b|1>. Interesting, eh? Only 
   'really' works if the initial qbit is |0> 
   -- i.e. an unfair coin IMHO.
 *)

proc P(s:^qbit, log) = 
  + s?(y) . y>>I . s!y . log!() . _0        
  + s?(y) . y>>X . s!y . log!() . _0
                     
proc Q(q: qbit, s:^qbit, log) = 
  out!["initially "] . outq!(qval q) . out!["; "] .
  q>>H . s!q . s?(q') . q'>>H . 
  out!["finally "] . outq!(qval q') . out!["\n"] .
  log!() . _0 

proc System() = (let k = read_num "number of trials")
                (let bv = read_alternative "basis" "," ["0",|0>; "1",|1>; "+",|+>; "-",|->])
                (let verbose = read_bool "with commentary" "y" "n")
           out!["See output for results -- can print but can't examine qbit state\n"] .
           Logger (k, bv, verbose)

proc Logger (k, bv, verbose) = Run (k, bv, verbose, 0)

proc Run (k, bv, verbose, i) = 
  if i=k then out![show i; " trials\n"] . _0
  else
    (newq q = bv) 
    (new s:^qbit)
    (new reportP, reportQ)
    | P(s,reportP) 
    | Q(q,s,reportQ) 
    | reportP?(_) .
      reportQ?(_) .
      Run (k, bv, verbose, i+1)
  fi
