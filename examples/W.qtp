(* W-state algorithm taken from 
    the Q# Kata on superposition
    (https://github.com/microsoft/QuantumKatas/tree/main/Superposition/ReferenceImplementation.qs), 
    task 16, WState_PowerOfTwo_Reference
 *)

fun ixs k = tabulate k (Î» i. i)

fun powerceiling b n =
  pwc 1
  where pwc c = if c>=n then c else pwc (b*c)

proc W (c,n) = 
  if   n<=0 then (let _ = abandon ["W "; show n; " is impossible"]) . _0
  elsf n=1  then (newqs qs = |1>) c!qs . _0
  else . (let k = floor (n/2)) 
       . (new c1) 
       | W (c1,k)     
       | . c1?(q0s)      
         . out!["W "; show n; " has "; show (n/2); "\n"]
         . (newqs q1s = |0>âŠ—âŠ—(n-k))   
         . (newq anc = |+>)        
         . ð„† iâ†ixs k: anc,q0sâ†“i,q1sâ†“i>>F . out!["."] . _0
         . out!["W "; show n; " has done its Fs\n"]
         . ð„† iâ†ixs k: q1sâ†“i,anc>>CNot . out!["."] . _0 
         . out!["W "; show n; " has done its CNots\n"]
         . dispose!anc
         . (joinqs q0s, q1s â†’ qs)
         . c!qs
         . _0

proc Wmake (c,n) =
  (let k = powerceiling 2 n)
  | W (c,k)
  | . c?(qs)
    . out!["W "; show k; " = "] . outq!qvals qs . out!["\n"]
    . if k=n then _0
      else 
        . out!["discarding "; show (k-n); " qbits "]
        . (splitqs qs â†’ q0s(k-n),qs)
        . q0sâŒ¢âƒ«(bs)
        . out!["which measured "; show bs; ", leaving "] . outq!qvals qs 
        . if forall (Î» b . b=0b0) bs then out!["\n"] . _0 else out![" -- round again!\n"] . Wmake (c,n)  
               

proc System () =
  . (new c)
  . (let n = read_num "how many qbits") 
  . Wmake (c,n)
