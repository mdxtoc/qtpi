% !TEX root = ./qtpi_description.tex

\chapter{Introduction}

Qtpi is a programming language designed to simulate quantum computation, especially in quantum security protocols. The implementation, with a symbolic calculator, is also called qtpi. It is based on CQP \citep{GaySJ:comqp} (\underline{C}ommunicating \underline{Q}uantum \underline{P}rotocols), which was itself a development of the pi calculus \citep{DBLP:journals/iandc/MilnerPW92a}. 

Quantum protocols, just like any other kind, feature agents which send each other messages and act independently on the values they receive. CQP used an extended pi calculus to show how classical (non-quantum) computer science notions of concurrent programming -- processes as agents, messages as a kind of distributed assignment -- could be used to specify and analyse proposed concurrent quantum algorithms. Program execution is a mixture of classical and quantum steps, so that would seem to be that. But there are things which a quantum protocol cannot attempt, because of the real-world physical fact that you can't clone, copy or share a qubit. It's trivial to clone a classical bit in a program execution: every assignment clones many bits a time. So a central feature of CQP is that it uses linear typing \citep{linearityandthepi-calculus}, an abstraction of execution, in a static compile-time check that a quantum program obeys the rules. If a qubit is sent in a message, for example, it's ownership vanishes from the sender and reappears in the receiver when the message is received. And so on: there are more restrictions than that.

CQP was a theoretical proposal, directed towards explanation rather than calculation. In particular at each quantum measurement step a CQP execution splits into two, each labelled with the probability that a real-world execution would take that branch (and I suppose it splits at each guarded command). The effect is to generate a tree of execution paths, labelled with the individual probability that that path might be taken. Qtpi, by contrast, makes a pseudo-random choice at each measurement, biased by the probabilities of the quantum state, and so generates a single execution path. 

Qtpi includes a quantum calculator which uses unbounded-precision rationals, square roots of rationals and sin/cos of rationals to make \emph{exact} calculations -- no approximations, no floating point. CQP had an `expr' step in which all the quantum stuff went on (and more than that): Qtpi elevates quantum measurement and quantum gating to the level of program steps, and has a `let' construct to allow classical functional calculations.

Qtpi is perhaps most impressivewhen it's dealing with protocols, but nowadays it can do somewhat more complicated simulations. I introduce it using examples. \Chapref{corenotation} describes the language more formally, for those who want to skip to the chase; \chapref{library} describes the library of functions and constants. \Chapref{symboliccalculator} tells how qtpi manages to perform precise symbolic calculation surprising quickly.

\section{Why isn't it Python?}

Concurrent programming is inherently tricky, and no notation could make it simple. Qtpi is derived from the pi calculus because of those linear typing checks. It could never involve assignment, so it isn't C, and it isn't Java, and it isn't Python.
