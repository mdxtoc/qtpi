fun expg g n =
  if n=0 then I else g*expg g (n-1)

fun rand8 () = bits2num (randbits 8)

fun randg g = if randbit()=0b1 then g else I

proc Alice (x:qubit, c:^(bit,bit)) = 
    . (newq z) 
    . (let rxe = rand8())
    . out!["rxe="; show rxe; "\n"]
    . z >> expg Rx rxe
    . z >> randg X
    . z >> randg Y
    . z >> randg Z
    . (let rze = rand8())
    . out!["rze="; show rze; "\n"]
    . z >> expg Rz rze
    . ⁁ 1
    . z,x>>CNot . z>>H . z-/-(vz) . x-/-(vx) 
    . c!vz,vx 
    . _0 
                                        with 1: out!["initially Alice's z is "] . 
                                                outq!(qval z) . out!["\n"] .
                                                _0

proc Bob(y:qubit, c:^(bit,bit)) = 
    . c?(pair) 
    . y >> match pair . + (0b0,0b0) . I
                        + (0b0,0b1) . X
                        + (0b1,0b0) . Z
                        + (0b1,0b1) . Z*X    
    . ⁁ 1
    . _0 
                                        with 1: out!["finally Bob's y is "] . 
                                                outq!(qval y) . out!["\n"] .
                                                _0
    

proc System () = 
  .  (newq x=|+>, y=|0>) 
  . x,y>>CNot 
  . (new c:^(bit,bit)) 
  . | Alice(x,c) 
    | Bob(y,c)
