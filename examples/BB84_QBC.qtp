
Alice(verbose, k, n:int, r:^bit, qB, bB, vB, again) = 
  Alice1 (verbose, k, 0, 0, 0, 0, n, r, qB, bB, vB, again)

Alice1(verbose, k, i, nA, nB, nH, n:int, r:^bit, qB, bB, vB, again) = 
  if i=k then 
    {print_strings ["\n\nAll over: "; string_of_value nA; " Alice; ";
                                      string_of_value nB; " Bob; ";
                                      string_of_value nH; " honest\n"
                   ]
    } . 
    _0
  else
    {print_strings ["trial number "; string_of_value (i+1)]} .
    {print_string if verbose then ": " else "\n" fi} .
    r?(basis) .
    (let vs = randbits n)
    {if verbose then print_strings ["Alice chose basis "; string_of_value basis;
                                    " and values "; string_of_value vs; "\n"
                                   ]
     else ()
     fi
    } .
    (new done) (  AliceSendBits (vs,basis,qB,done)
                | done?(s) . bB?(guess:bit) . vB!basis,vs . again?(honest) .
                  (let nH = if honest then nH+1 else nH fi)
                  (let nA,nB = if guess=basis then nA,nB+1 else nA+1,nB fi)
                  {print_string if guess=basis then "Alice says Bob wins\n"
                                               else "Alice claims a win\n"
                  fi
                  } . 
                  Alice1(verbose,k,i+1,nA,nB,nH,n,r,qB,bB,vB,again)
               )
  fi

(* send bits encoded in basis down channel qB *)
AliceSendBits (vs,basis,qB,done) =   
    match vs .
        []    . done!() . _0
    <+> v::vs . (newq q = match basis,v .
                              0b0,0b0 . |0> 
                          <+> 0b0,0b1 . |1> 
                          <+> 0b1,0b0 . |+> 
                          <+> 0b1,0b1 . |-> 
                          hctam
                )
                qB!q.
                AliceSendBits(vs,basis,qB,done)
    hctam

Bob(verbose, k, n:int, r:^bit, qA, bA, vA, again) = 
  if k=0 then _0
  else
    (new done,verified) 
    (  BobReceive(n,[],qA,r,done)
     | done?(bvs) . r?(guess) .
       {if verbose then print_strings ["Bob received "; string_of_value bvs;
                                       " and guessed "; string_of_value guess; "\n"
                                      ]
        else ()
        fi
       } .
       bA!guess . vA?(basis:bit, vs:bit list) .
       BobVerify (basis,vs,bvs,verified)
     | verified?(honest) .
       again!honest .
       Bob (verbose, k-1, n, r, qA, bA, vA, again)
    )
  fi

(* receive qbits down qA, measure them, record the results *)
BobReceive(n,bvs,qA,r,done) =
    if n=0 then done!rev bvs . _0
    else qA?(q).
         r?(basis).
         q =?[if basis=0b1 then _H else _I fi] (value) .
         dispose!q .
         BobReceive(n-1,(basis,value)::bvs,qA,r,done)
    fi

(* verify Alice's story *)
BobVerify (basis,vs,bvs,done) =
  match vs, bvs .
      []   , []           . Honest (done)
  <+> []   , _            . Liar (done)
  <+> _    , []           . Liar (done)
  <+> v::vs, (b,v')::bvs  . if b=basis && v<>v' 
                              then Liar (done)
                              else BobVerify(basis,vs,bvs,done)
                            fi
  hctam
  
Liar   (done) = {print_string "Bob says Alice lied\n"} . done!false . _0
Honest (done) = {print_string "Bob says Alice was honest\n"} . done!true . _0

(* a source of random bits. A bit of a joke, but relatively harmless *)
Random(q:qbit, r:^bit) = q>>_H . q=?(v) . r!v . Random(q,r)

System() = (let k = read_int "number of trials")
           (let n = read_int "number of qbits")
           (let s = read_string "with commentary (y/n)")
           (let verbose = match s . "y" . true <+> "n" . false <+> _ . abandon "pardon?" hctam)
           (new r,qc,bc,vc,again)
           (  Alice(verbose,k,n,r,qc,bc,vc,again) 
            | Bob(verbose,k,n,r,qc,bc,vc,again) 
            | (newq q = |0>) Random(q,r)
           )
