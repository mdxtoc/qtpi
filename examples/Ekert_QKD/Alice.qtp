fun int_sqrt n = i_s 0 n

fun i_s k n =
  if k*k>=n then k 
  else i_s (k+1) n fi

fun abs i = if i<0 then -i else i fi

proc Alice(n,qc,ic,bc,logc) = 
  (new rc) 
    | AliceRead (n,qc,rc,[])
    | rc?(bvs)    .
      (let bs = map fst bvs)
      ic!bs     .
      ic?(bBs)  .
      (let bBbvs = combine bBs bvs)
      (let vAs = sanitise bBbvs)
      bc!vAs   . (* send Bob the values, where we used different bases *)
      bc?(vBs) .
      (* we can do the non-interference check for all the orientations, but while we have a slow
         interpreter, one each for Alice and Bob will have to do.
       *)
      if not (check bs bBs vAs vBs (0,1)) then (* we have interference *)
        bc![bool2bit false] .
        {print_strings ["Alice detects interference\n"]} .
        logc![] .
        _0
      else 
        bc![bool2bit true]  .
        bc?(go)             .
        if bit2bool (hd go) then (* Bob says ok too *)
          (let key = map snd (filter (lam ((b,b'),v') . b=b') bBbvs))
          (let message = randbits (length key))
          {print_strings ["Alice sends  "; show message; "\n"]} .
          bc!xor_mask key message   .
          logc!message              .
        _0
        else
          logc![] .
          _0
        fi
      fi

proc AliceRead (n,qc,rc,bvs) = 
  if n=0 then rc!rev bvs . _0
  else
    qc?(q) . (new r) | AliceMeasure (q,r) | r?(bv) . AliceRead (n-1,qc,rc,bv::bvs)
  fi

proc AliceMeasure (q,r) =
  match rand4() . 
    + 0 . q=?[]    (b) . dispose!q . r!0,b . _0
    + 1 . q=?[_FG] (b) . dispose!q . r!1,b . _0
    + 2 . q=?[_H]  (b) . dispose!q . r!2,b . _0
    + _ . AliceMeasure (q,r) (* 3 - try again *)
