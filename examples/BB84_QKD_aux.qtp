(* check that masked bits in vs match check bits *)
fun test_checkbits mask checks vs =
  forall f mcvs where f ((mb,cb),vb) = mb<>0b1 || cb=vb
                where mcs = zip mask checks
                where mcvs = zip mcs vs

(* pick out the bits that are in the same bases *)
proc Reconcile (bs,bvs,vs,result) =
  match bs, bvs .
       []    , []         . result!rev vs . _0
   <+> b'::bs, (b,v)::bvs . Reconcile (bs, bvs, if b'=b then v::vs else vs fi, result)
   <+> _                  . {abandon "Reconcile failure"} . _0
   hctam
  
(* filter out masked bits *)
fun masked_filter mask vs filtered =
  snd (unzip (filter f (zip mask vs)) where f (b,v) = b=0b0

fun xor_mask code message = map (uncurry2 xor_bits) (zip code message)

(* sample bits at random: take a quarter for check bits *)
proc Sample (vs, mask, sample, result) =
  match vs .
      []    . result!rev mask . result!rev sample . _0
  <+> v::vs . (let b1, b2 = randbit(), randbit()) 
              if b1=0b0 && b2=0b0 then 
                Sample (vs, 0b1::mask, v::sample, result)
              else
                Sample (vs, 0b0::mask, sample, result)
              fi
  hctam

