
proc Alice (x:qbit, c:^bit*bit, z:qbit, log) = 
    out!["initially Alice's z is "] . outq!(qval z) . out!["\n"] .
    z,x>>CNot . z>>H . z-/-(vz) . x-/-(vx) . c!vz,vx . 
    log!() . _0 

proc Bob(y:qbit, c:^bit*bit, log) = 
    c?(b1,b2) . y>>phi (match b1,b2 .
                         + 0b0,0b0 . 0
                         + 0b0,0b1 . 1
                         + 0b1,0b0 . 2 (* i.e. Y *)
                         + 0b1,0b1 . 3 (* i.e. Z *) (* this doesn't work *)
                        ) . 
    out!["finally Bob's y is "] . outq!(qval y) . out!["\n"] .
    dispose!y .
    log!() . _0 

proc System () = 
  out!["This is teleportation using the Phi collection I, X, Y, Z. It doesn't work\n"] .
  (let k = read_num "number of trials")
  (let standard = read_bool "standard initial state or random" "s" "r")
  out!if standard then []
                  else ["\nThat, as you will see, is a step too far for the symbolic quantum calculator\n\n"] .
  out!["See output for results -- can print but can't examine qbit state\n"] .
  Run (k, standard, 0)

proc Run (k, standard, i) =
  if i=k then out![show k; " trials\n"] . _0
  else (new log)
       | if standard then (newq x=|0>, y=|0>) Experiment (x, y, log)
                     else (newq x,y)          Experiment (x, y, log)
       | log?(_) .
         Run (k, standard, i+1)
  
proc Experiment (x, y, log) =
  x>>H . x,y>>CNot . 
  (new c:^bit*bit)
  (newq z)
  (new logA, logB)
  | Alice(x,c,z,logA) 
  | Bob(y,c,logB)
  | logA?(_) . logB?(_) . log!() . _0
