(* check that masked bits in vs match check bits *)
fun test_checkbits mask checks vs =
  forall (lam (cb,vb) . cb=vb) 
         (zip checks (mask_filter 0b1 mask vs)) 

(* pick out the bits that are in the same bases *)
fun reconcile b1s b2s vs =
  mask_filter 0b0 (xor_mask b1s b2s) vs
    
(* filter out masked bits *)
fun mask_filter (m:'a) (mask:'a list) (vs:'b list) : 'b list =
  vs where _, vs = unzip mvs
     where mvs = filter (lam (me,_) . me=m) (zip mask vs)

(* select check bits randomly. Use 1/4 probability because it's easy *)
fun cb_choose _ = if randbit()=0b1 && randbit()=0b1 then 0b1 else 0b0 fi

fun xor_mask code message = 
  map (lam (b1,b2) . if b1=b2 then 0b0 else 0b1 fi) (zip code message)

fun bit2bool b = b=0b1
fun bool2bit b = if b then 0b1 else 0b0 fi

fun read_min_int m s =
  k where k = if j>=m then j 
              else semicolon (lam _ . print_strings ["pardon? at least "; string_of_value m; "\n"])
                             (lam _ . read_min_int m s)
                             ()
              fi
    where j = read_int s
    
fun compose f g v = f (g v)

fun semicolon f g = compose g f

fun int_sqrt n = i_s 0 n

fun i_s k n =
  if k*k>=n then k 
  else i_s (k+1) n fi
  
fun histogram ns = 
  histo [] (sort ns)

fun histo buckets ns =
  match ns .
      []    . buckets
  <+> n::ns . histo ((n,length pre+1)::buckets) post
                where pre = takewhile sameas ns
                where post = dropwhile sameas ns
                where sameas = lam k . k=n
  hctam

fun listsum ns = foldl (lam sum n . sum+n) 0 ns

fun listmin ns = foldl (lam sofar n . min sofar n) (hd ns) (tl ns)
       