<h1>qtpi language description</h1>
<p>Based on CQP (Gay &amp; Nagarajan, POPL 2005) and therefore on the pi calculus. Some changes cosmetic (e.g. fewer square brackets, fewer capital letters); some for convenience (no mandatory types, because there's a typechecker); some because state-changing operations (e.g. applying unary gates, measurement) should be protocol steps; new operators intended to be easy to read.</p>
<p>The expression language is moving closer to Miranda: '<code>where</code>' clauses, offside parsing and, eventually, laziness. The process language is beginning to exploit the offside parser and maybe I've gone too far with the parallel, sum and match constructs.</p>
<h2>The offside rule</h2>
<p>Most languages use lots of brackets in their syntax. You often have to use brackets in OCaml, for example, around the stuff between <code>then</code> and <code>else</code>, because the <code>else</code> part can be missing (i.e. no closing bracket for <code>then</code>) and likewise after the <code>else</code> because there's no closing <code>fi</code>.</p>
<p>When I began to implement Qtpi I thought that I'd do the Algol 68 thing and include <code>fi</code>. When I realised I needed pattern matching, I introduced a construct which started <code>match</code> and ended <code>hctam</code>. It looked horrible.</p>
<p>Landin's <em>offside rule</em> makes closing brackets unnecessary. In the Miranda expression <em>E</em> <code>where</code> <em>E'</em>, <em>E'</em> mustn't be left of <code>where</code>, and can't be left of its own first token. This disambiguates things like</p>
<pre><code>	hwc key message
	  where message = packets [] bits
	                    where bits = f message
	                    where f = g k
	  where key = ...
</code></pre>
<p>-- the first and fourth <code>where</code>s attach to hwc key message; the second and third attach to packets [] bits.</p>
<p>So far the offside parser applies to function definitions (expression to the right of '='), to <code>where</code> clauses, to <code>match</code>es in processes and expressions, to guarded sums, and to parallel process compositions.</p>
<h2>Grammar</h2>
<p>Processes <em>P</em>, input-output steps <em>IO</em>, quantum steps <em>Q</em>, expressions <em>E</em>, types <em>T</em>, process names <em>N</em>, variable names <em>x</em>, parameters <em>par</em>, patterns <em>pat</em>, gate expressions <em>G</em>. Square brackets surround optional elements.</p>
<ul>
<li>
<p>Program description</p>
<p>A program is a sequence of process and function definitions. One of the process descriptions must be <code>System</code>, which must have no parameters.</p>
<p>| <code>proc</code> <em>N</em> <code>(</code>  <em>par</em>  <code>,</code>  ... <code>,</code> <em>par</em> <code>)</code> = <em>P</em><br />
| <code>fun</code> <em>x</em> <em>pat</em> ... <em>pat</em>  = <em>E</em><br />
| <code>fun</code> <em>x</em> <em>pat</em> ... <em>pat</em> <code>:</code> <em>T</em> = <em>E</em></p>
<ul>
<li>Types are optional in process parameters, as everywhere.</li>
<li>As with <code>let</code> and with reads <code>E?(pat)</code>, function parameters are bullet-proof: underscore <code>_</code>, names and unit, but otherwise no constants and definitely no lists.</li>
<li>Function parameters may include a type, and the result type of the function may be given. This allows you to define functions with types like <code>bit list -&gt; 'a list -&gt; 'a list</code>.</li>
<li>Note that the arguments and result of a function must be entirely classical -- i.e. have nothing to do with qbits.</li>
</ul>
</li>
<li>
<p>Process <em>P</em></p>
<p>| <em>Q</em> <code>.</code> <em>P</em><br />
| <code>+</code> <em>IO</em> <code>.</code> <em>P</em> ... <code>+</code> <em>IO</em> <code>.</code> <em>P</em><br />
| <code>|</code> <em>P</em> ... <code>|</code> <em>P</em><br />
| <code>if</code> <em>E</em> <code>then</code> <em>P</em> <code>else</code> <em>P</em> <code>fi</code><br />
| <code>match</code> <em>E</em> <code>.</code> <code>+</code> <em>pat</em> <code>.</code> <em>P</em> ... <code>+</code> <em>pat</em> <code>.</code> <em>P</em><br />
| <code>( new</code> <em>par</em>  <code>,</code>  ... <code>,</code> <em>par</em> <code>)</code> <em>P</em><br />
| <code>( newq</code> <em>par</em> [ <code>=</code> <em>E</em> ] <code>,</code>  ... <code>,</code> <em>par</em> [ <code>=</code> <em>E</em> ] <code>)</code> <em>P</em><br />
| <code>( let</code> <em>pat</em> <code>=</code> <em>E</em> <code>)</code> <em>P</em><br />
| <em>N</em> <code>(</code> <em>E</em>  <code>,</code>  ... <code>,</code> <em>E</em>  <code>)</code><br />
| <code>(</code> <em>P</em> <code>)</code><br />
| <code>_0</code></p>
<ul>
<li>Note that a a guarded sum starts with a <code>+</code>, and a parallel composition starts with a <code>|</code>. Neither needs to be bracketed, because the offside parser ensures that everything is to the right of the <code>+</code> or <code>|</code>, as appropriate.</li>
<li>matches also use the <code>+</code> separator.</li>
<li><code>new</code> creates channels, as in the pi calculus Î½.</li>
<li><code>newq</code> creates qbits. Initialisation to basis vectors is optional (without it you get (<em>a</em><code>|0&gt;</code>+<em>b</em><code>|1&gt;</code>), for unknown <em>a</em> and <em>b</em>, where <em>a</em><sup>2</sup>+<em>b</em><sup>2</sup>=1).</li>
<li><code>let</code> expressions use a restricted form of pattern -- no constants, no lists -- so they can't fail to match.</li>
<li><code>_0</code> is the null process (i.e. termination). I would have used <code>()</code> (null parallel or null guarded sum: same difference) but it would have caused parsing problems.</li>
<li><code>{</code> <em>E</em> <code>}</code> <code>.</code> <em>P</em> is no longer included. It was used exclusively for printing, and the output channels out and outq now do the job.</li>
<li>You can execute an arbitrary expression via a 'let' binding, if you wish.  Very non-pi if you write <code>(let _ =</code> <em>E</em><code>)</code>. Can't see how to prohibit that: sorry (I could make it a runtime error if <em>E</em> has unit type, but I hate runtime errors).</li>
</ul>
</li>
<li>
<p>Quantum step <em>Q</em></p>
<p>| <em>E</em> <code>,</code> <em>E</em> <code>,</code> ... <code>,</code> <em>E</em> <code>&gt;&gt;</code> <em>G</em><br />
| <em>E</em> <code>=?</code> (<em>pat</em>)<br />
| <em>E</em> <code>=?</code> <code>[</code> <em>E</em> <code>;</code> ... <code>;</code> <em>E</em> <code>]</code> (<em>pat</em>)</p>
<ul>
<li>'<code>&gt;&gt;</code>' is 'send through a gate'; each left-hand <em>E</em> must describe a single qbit. The arity of the input tuple must match the arity of the gate (e.g. _H takes one qbit, _Cnot takes 2, _Fredkin if we had it would take 3, and so on).</li>
<li><code>=?</code> is measure, in the computational basis defined by <code>|0&gt;</code> and <code>|1&gt;</code>.  The parameter <em>par</em> binds the single-bit result.</li>
<li>Measurement takes a pattern, either <code>_</code> or <em>x</em>. As you'd expect, if the pattern is a name then the result of the measurement (a bit 0b0 or 0b1) is bound to the name <em>and the qbit vanishes</em> (is used up). If it's <code>_</code> then the result of the measurement is ignored, but the qbit remains, transformed to <code>|0&gt;</code> or <code>|1&gt;</code>. That is, qbits are destroyed on <em>detection</em>, not on measurement (as in experiments with polaroid plastic film).</li>
<li>The optional square-bracketed <em>E</em> list is a gate expression controlling the measurement basis: for example <code>[_H]</code> specifies measurement in the Hadamard basis, and <code>[_I]</code> the computational basis. If there's more than one gate it specifies measurement in the basis defined by the matrix product of those gates. Internally <code>q=?[G](b)</code> is equivalent to <code>q&gt;&gt;G . q=?(b) . q&gt;&gt;G*</code> where <code>G*</code> is the conjugate transpose of <code>G</code>.</li>
<li>CQP had <code>*=</code> for measure, which looked like an assignment, so (at Guillaume Poly's suggestion) I changed it to <code>=?</code>.</li>
</ul>
</li>
<li>
<p>Input-output step <em>IO</em></p>
<p>| <em>E</em> <code>?</code> <code>(</code> <em>pat</em> <code>)</code><br />
| <em>E</em> <code>?</code> <code>_</code><br />
| <em>E</em> <code>!</code> <em>E</em></p>
<ul>
<li>'<code>?</code>' is read, as in many implementations of the pi calculus: <em>E</em> is a channel; the pattern is bracketed, as is the name in the pi calculus. The pattern is restricted as in a <code>let</code>  binding -- no constants except <code>()</code>, no lists.</li>
<li>'<code>!</code>' is write, as in many implementations of the pi calculus: the first <em>E</em> is a channel; the output expression can of course be an unbracketed tuple. (Miranda style says tuples must be bracketed: not this one.)</li>
<li>Channels each carry either a qbit or a classical value (one not including any qbits).</li>
</ul>
</li>
<li>
<p>Parameter <em>par</em></p>
<p>| <em>x</em><br />
| <em>x</em> <code>:</code> <em>T</em></p>
<ul>
<li>Parameter type specs are optional, always.</li>
</ul>
</li>
<li>
<p>Type <em>T</em></p>
<p>| <code>qbit</code><br />
| <code>unit</code><br />
| <code>int</code><br />
| <code>bool</code><br />
| <code>bit</code><br />
| <code>Range</code> <em>int</em><code>:</code> <em>int</em><br />
| <code>string</code><br />
| <code>char</code><br />
| <code>basisv</code><br />
| <code>qstate</code><br />
| <code>'</code><em>x</em><br />
| <code>''</code><em>x</em><br />
| <em>T</em> <code>list</code><br />
| <em>T</em> <code>*</code> ... <code>*</code> <em>T</em><br />
| <code>^</code> <em>T</em><br />
| <em>T</em> <code>-&gt;</code> ... <code>-&gt;</code> <em>T</em><br />
| <em>T</em> <code>process</code><br />
| <code>(</code> <em>T</em> <code>)</code></p>
<ul>
<li>These types are still ML style. Miranda style is neater (<code>[int]</code> rather than <code>int list</code>, <code>(int,bit)</code> rather than <code>int*bit</code>, and they don't need syntactic precedence. One day soon ...)</li>
<li>Range types were in original CQP. They are hard to deal with in the typechecker and are currently pretty useless, but with a subtyping typechecker they may come back (I do hope so).</li>
<li><code>basisv</code> is the type of basis vectors (see below).</li>
<li><code>qstate</code> is the type of the result of the <em>qval</em> function (see below). It's a peek at the simulator state. But qstates can't be compared or manipulated in any way. The only useful thing you can do with them is to send them down the outq output channel, which prints them out.</li>
<li>'<code>*</code>' separates elements of a tuple type.</li>
<li>Process types <em>T</em> <code>process</code> are currently for internal use.</li>
<li>The syntactic precedence of types is more or less as listed, or so I hope and intend.</li>
<li>Explicit types are optional syntactically, as in ML and OCaml and Miranda and Haskell and all good strongly-typed languages. The typechecker infers them. It may be pragmatic to include them in the parameter list of a process definition, and in '<code>new</code>' channel declarations.</li>
<li>Type variables / unknown types <code>'</code><em>x</em> and <code>''</code><em>x</em> are for function definitions. As in ML, <code>''</code><em>x</em> is an equality type (see below).</li>
</ul>
</li>
<li>
<p>Pattern <em>pat</em></p>
<p>| <code>_</code><br />
| <code>[]</code><br />
| <code>()</code><br />
| <em>constant</em><br />
| <em>x</em><br />
| <code>[</code> <em>pattern</em> <code>;</code> <em>pattern</em> ... <code>;</code> <em>pattern</em> <code>]</code>
| <em>pat</em> <code>::</code> <em>pat</em><br />
| <em>pat</em> <code>,</code> ... <code>,</code> <em>pat</em><br />
| <em>pat</em> <code>:</code> <em>type</em><br />
| <code>(</code> <em>pat</em> <code>)</code></p>
<ul>
<li>For constants see Expression <em>E</em> below.  Also, it seems, gates are allowed.</li>
<li>Typed patterns <em>pat</em><code>:</code><em>type</em> often need bracketing.</li>
<li><code>let</code>, <code>E?..</code> and function parameters use a restricted form of pattern: only <em>x</em>, <code>_</code>, <code>()</code> and tuples thereof -- i.e. patterns which can't fail to match.</li>
</ul>
</li>
<li>
<p>Expression <em>E</em></p>
<p>| <em>constant</em><br />
| <code>_Phi(</code> <em>E</em> <code>)</code><br />
| <em>x</em><br />
| <code>if</code> <em>E</em> <code>then</code> <em>E</em> <code>else</code> <em>E</em> <code>fi</code><br />
| <code>if</code> <em>E</em> <code>then</code> <em>E</em> <code>elif</code> <em>E</em> <code>then</code> <em>E</em> ... <code>else</code> <em>E</em> <code>fi</code><br />
| <code>match</code> <em>E</em> <code>.</code> <code>+</code> <em>pat</em> . <em>E</em> ... <code>+</code> <em>pat</em> . <em>E</em><br />
| <code>(</code> <em>E</em> <code>,</code> ... <code>,</code> <em>E</em> <code>)</code><br />
| <code>[</code> <em>E</em> <code>;</code> ... <code>;</code> <em>E</em> <code>]</code></p>
<p>| <em>E</em> <em>E</em><br />
| <code>-</code> <em>E</em><br />
| <code>not</code> <em>E</em><br />
| <em>E</em> <code>::</code> <em>E</em><br />
| <em>E</em> <code>@</code> <em>E</em><br />
| <em>E</em> <em>aop</em> <em>E</em><br />
| <em>E</em> <em>cop</em> <em>E</em><br />
| <em>E</em> <em>bop</em> <em>E</em><br />
| <code>lam</code> <em>pat</em> ... <em>pat</em> <code>.</code> <em>E</em></p>
<ul>
<li>Constants are integers; chars <code>'c'</code>; strings <code>&quot;chars&quot;</code>; bit constants <code>0b1</code> and <code>1b1</code>; basis vectors<code>|0&gt;</code>, <code>|1&gt;</code>, <code>|+&gt;</code> and <code>|-&gt;</code>; gates <code>_H</code>, <code>_CNot</code>, <code>_I</code>, <code>_X</code>, <code>_Y</code>, <code>_Z</code>, <code>_F</code> and <code>_G</code>.</li>
<li>The gate <code>_Phi(*E*)</code> is not a constant. (I suppose it is a constructor -- the only one so far.)</li>
<li>The zero-tuple <code>()</code> and the empty list <code>[]</code> are special cases of the bracketed rules.</li>
<li>There is no one-tuple.</li>
<li>Match expressions are parsed with the offside rule: the components can't start left of <code>match</code>, and the patterns and right-hand-side expressions have to be right of <code>+</code>. (They will one day disappear, I hope, in favour of Miranda-style matching on function parameters.)</li>
<li>Function applications are <em>E</em> <em>E</em> -- juxtaposition. And of course left associative, so that <em>E</em> <em>E</em> <em>E</em> is (<em>E</em> <em>E</em>) <em>E</em>.  There's a function library (see below) and perhaps one day there will be downloadable bundles of functions.</li>
<li>Absolutely no process stuff, no manipulation of qbits. But see <em>print_string</em>, <em>print_strings</em> and <em>print_qbit</em> below.</li>
</ul>
</li>
<li>
<p>Built-in operators</p>
<ul>
<li><code>@</code> (append) was an operator in one of Gay &amp; Nagarajan's examples; it's still included.</li>
<li><code>::</code> (cons) is now included.</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> arithmetic operators <em>aop</em>.</li>
<li><code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>&lt;&gt;</code>, <code>&gt;=</code>, <code>&gt;</code> comparison operators <em>cop</em>.</li>
<li><code>&amp;&amp;</code>, <code>||</code>, boolean operators <em>bop</em>.</li>
</ul>
</li>
<li>
<p>Process name <em>N</em></p>
<p>Starts with an upper-case letter, continues with alphanumeric, prime and underscore.</p>
</li>
<li>
<p>Variable name <em>x</em></p>
<p>Starts with a lower-case letter, continues with alphanumeric, prime and underscore. (Actually, it seems, you can get away with upper case, but names in function definitions have to start with lower case.)</p>
</li>
</ul>
<h2>Input-Output channels</h2>
<p>There's an input channel <em>in</em></p>
<ul>
<li><em>in</em>: ^<em>string</em></li>
</ul>
<p>It reads a single line of input as a string. Writing to it is a run-time error, because I don't know how to typecheck read-only channels.</p>
<p>There are functions which print out strings and qbit states (see below). But it's inelegant to do that in a process. So there are output channels.</p>
<ul>
<li><em>out</em>: ^<em>string list</em></li>
<li><em>outq</em>: ^<em>qstate</em></li>
</ul>
<p>outq is peculiar for peculiar reasons. There can't be an output channel which takes qbits, because if you send a qbit down a channel, you lose it. So there's a special type <em>qstate</em>, the result of <em>qval</em>: <em>qbit</em> -&gt; <em>qstate</em>, which is a classical value that can be sent down a channel. So that there's no computational cheating, there's nothing else you can do with a <em>qstate</em> value.</p>
<p>Reading from an output channel is a runtime error, because I don't know how to typecheck write-only channels.</p>
<p>There is also the special function <em>show</em></p>
<ul>
<li><em>show</em>: '<em>a</em> -&gt; <em>string</em></li>
</ul>
<p>-- it takes any <em>classical</em> value and turns it into a string. Obviously it shouldn't have anything to do with qbits (or there could be computational cheating), but for functions, processes, qstates and channels (all classical values) it just prints <function>, <process>, <qstate> and <channel>.</p>
<h2>The <em>dispose</em> channel</h2>
<p>Qbits get discarded: Alice sends one to Bob, Bob receives it, measures it, records the result, and then waits for the next one. The qbit is destroyed on detection, and it vanishes from the simulation. A vanished qbit is in fact recycled: not quite garbage-collected, because conventional garbage collection doesn't understand how qbits work.</p>
<p>Before I realised that qbits are destroyed on detection, I implemented a <em>dispose</em> channel of qbits (and it still exists because perhaps sometimes it might be needed). Send a qbit down the <em>dispose</em> channel and it has gone. It will be made available to be recycled, unless it is entangled, in which case it may be made available later. Like any sent-away qbit, you can't use it once it's disposed (see <a href="./ownership.html">the resourcing document</a> for explanation).</p>
<p>Reading from from the <em>dispose</em> channel is a run-time error.</p>
<p><a name="restrictions"></a></p>
<h2>Restrictions</h2>
<p>Qbits are big fragile things. They are measured, sent through gates, transmitted through channels. Protocol descriptions (e.g. QKD) talk of processes sending qbits to each other and separately communicating information like basis and value over classical channels. So although you are able to make lists of qbits, tuples of qbits and the like, for simplicity of description of protocols, because of these restrictions you cannot do anything with them. This also massively simplifies <em>resourcing</em>: see <a href="./ownership.html">the resourcing document</a> for explanation.</p>
<p>These restrictions, then, attempt to give you a language in which qbits are known only by a single name at any time. This simplifies the description of protocols, I believe, and it simplifies resource-checking, but it's really there for aesthetic reasons.</p>
<p>It is also impossible to branch according to the state or identity or equality of a qbit. (In unsimulated real life you couldn't ...). Likewise the identity or equality of a function.</p>
<ul>
<li>
<p><strong>A channel is either <code>^qbit</code> or <code>^classical</code></strong>.</p>
</li>
<li>
<p><strong>A process argument is either <code>qbit</code>, or classical</strong>.</p>
<p>Note that a channel value is classical, even if its type is <code>^qbit</code>.</p>
</li>
<li>
<p><strong>No qbit-valued conditionals as  process argument or send argument</strong>.</p>
<p>Conditionals include <code>if</code> and pattern-matching. It's ok to have qbit-valued conditionals in other positions, such as</p>
<pre><code>	if a=0 then q1 else q2 fi &gt;&gt; _H
</code></pre>
</li>
<li>
<p><strong><code>let</code>, and pattern-matching in processes, can only bind classical values</strong>.</p>
<p>Pattern-matching in expressions seems to be ok. Will know when we have a Coq proof.</p>
</li>
<li>
<p><strong>A function application can take only classical arguments, and deliver only a classical result</strong>.</p>
</li>
<li>
<p><strong>No comparison of qbits, qstates, or values containing qbits or qstates</strong>.</p>
<p>This stops programs doing anything outside the use of measurement to branch on the value of a qbit.</p>
</li>
<li>
<p><strong>No comparison of functions or processes, or values containing functions or processes</strong>.</p>
<p>This is standard in functional programming. You can't compare function values, because they are infinite. Ditto processes (which may one day arise as computational values: they are already a type).</p>
</li>
<li>
<p><strong>Library functions don't expose simulation state</strong>.</p>
<p>There used to be a function <em>qbit_state</em> which gave you a string representation of a qbit's internal state. Useful for diagnostic printing, I thought. Then I realised it allowed the program to branch on whether a pair of qbits are entangled or not, by comparing the results of <em>qbit_state</em> on them. Horror!</p>
<p>Not all is lost: there's <em>qval</em> which gives a <em>qstate</em>, there's the <em>outq</em> channel which accepts a <em>qstate</em>, and the <code>-verbose qsim</code> switch on Qtpi allows you to watch the simulation in any case.</p>
<p>This is a restriction on the implementation of the language. Not sure how to police it ... especially if I allow downloadable libraries. Hmm.</p>
</li>
</ul>
<h2>Interface functions</h2>
<p>We need to be able to read and write stuff: reading to give initial values like how many qbits to create; writing to describe results. It's also useful to include some functions to deal with lists and tuples.</p>
<p><strong>But</strong>, <em>but</em>, but. Functions can't deliver qbits or values containing qbits. See restrictions above.</p>
<p>The library is mostly inspired by Miranda and/or Bird &amp; Wadler's &quot;Introduction to Functional Programming&quot;. Easy to add more (see the file library.ml). Note that <em>'a</em>, etc., are classical types.</p>
<ul>
<li><em>abandon</em>: <em>string</em> -&gt; <em>'a</em>
<ul>
<li>stops the program and doesn't return (raises an exception).</li>
</ul>
</li>
<li><em>append</em>: <em>'a list</em> -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>concat</em>: <em>'a list list</em> -&gt; <em>'a list</em></li>
<li><em>const</em>: <em>'a</em> -&gt; <em>'b</em> -&gt; <em>'a</em></li>
<li><em>drop</em>: <em>int</em> -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>dropwhile</em>: (<em>'a</em> -&gt; <em>bool</em>) -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>exists</em>: (<em>'a</em> -&gt; <em>bool</em>) -&gt; <em>'a list</em> -&gt; <em>bool</em></li>
<li><em>filter</em>: (<em>'a</em> -&gt; <em>bool</em>) -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>foldl</em>: (<em>'a</em> -&gt; <em>'b</em> -&gt; <em>'a</em>) -&gt; <em>'a</em> -&gt; <em>'b list</em> -&gt; <em>'a</em></li>
<li><em>foldr</em>: (<em>'a</em> -&gt; <em>'b</em> -&gt; <em>'b</em>) -&gt; <em>'b</em> -&gt; <em>'a list</em> -&gt; <em>'b</em></li>
<li><em>forall</em>: (<em>'a</em> -&gt; <em>bool</em>) -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>fst</em>: <em>'a</em>*<em>'b</em> -&gt; <em>'a</em></li>
<li><em>hd</em>: <em>'a list</em> -&gt; <em>'a</em>
<ul>
<li>raises an exception if applied to <code>[]</code></li>
</ul>
</li>
<li><em>iter</em>: (<em>'a</em> -&gt; <em>'b</em>) -&gt; <em>'a list</em> -&gt; <em>unit</em></li>
<li><em>length</em>: <em>'a list</em> -&gt; <em>int</em></li>
<li><em>map</em>: (<em>'a</em> -&gt; <em>'b</em>) -&gt; <em>'a list</em> -&gt; <em>'b list</em></li>
<li><em>max</em>: <em>int</em> -&gt; <em>int</em> -&gt; <em>int</em></li>
<li><em>min</em>: <em>int</em> -&gt; <em>int</em> -&gt; <em>int</em></li>
<li><em>nth</em>: <em>'a list</em> -&gt; <em>int</em> -&gt; <em>'a</em></li>
<li><em>rev</em>: <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>show</em>: <em>'a</em> -&gt; <em>string</em>
<ul>
<li>converts any value to a string. If you use it on a qbit or a function you won't see anything interesting.</li>
</ul>
</li>
<li><em>sort</em>: <em>'a list</em> -&gt; <em>'a list</em>
<ul>
<li>sorts in ascending order; shouldn't sort functions and qbits (but probably does)</li>
</ul>
</li>
<li><em>snd</em>: <em>'a</em>*<em>'b</em> -&gt; <em>'b</em></li>
<li><em>tabulate</em>: <em>int</em> -&gt; (<em>int</em> -&gt; <em>'a</em>) -&gt; <em>'a list</em></li>
<li><em>take</em>: <em>int</em> -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>takewhile</em>: (<em>'a</em> -&gt; <em>bool</em>) -&gt; <em>'a list</em> -&gt; <em>'a list</em></li>
<li><em>tl</em>: <em>'a list</em> -&gt; <em>'a list</em>
<ul>
<li>raises an exception if applied to <code>[]</code></li>
</ul>
</li>
<li><em>unzip</em>: <em>'a</em>*<em>'b</em> <em>list</em> -&gt; <em>'a</em> <em>list</em> * <em>'b</em> <em>list</em></li>
<li><em>zip</em>: <em>'a</em> <em>list</em> -&gt; <em>'b</em> <em>list</em> -&gt; <em>'a</em>*<em>'b</em> <em>list</em>
<ul>
<li>raises an exception if applied to lists of differing lengths (but probably shouldn't)</li>
</ul>
</li>
<li></li>
<li><em>bitand</em>: <em>int</em> -&gt; <em>int</em> -&gt; <em>int</em></li>
<li><em>bits2int</em>: <em>bit list</em> -&gt; <em>int</em></li>
<li><em>int2bits</em>: <em>int</em> -&gt; <em>bit list</em></li>
<li></li>
<li><em>read_alternative</em>: <em>string</em> -&gt; <em>string</em> -&gt; (<em>string</em>*<em>'a</em>) <em>list</em> -&gt; <em>'a</em>
<ul>
<li><em>read_alternative</em> <em>prompt</em> &quot;/&quot; [(<em>s0</em>,<em>v0</em>);(<em>s1</em>,<em>v1</em>);...] prints <em>prompt</em>(<em>s0</em>/<em>s1</em>/...) and returns <em>v0</em> or <em>v1</em> or ... according to what the user types</li>
</ul>
</li>
<li><em>read_bool</em>: <em>string</em> -&gt; <em>string</em> -&gt; <em>string</em> -&gt; <em>bool</em>
<ul>
<li>prompt, true_response, false_response</li>
</ul>
</li>
<li><em>read_int</em>: <em>string</em> -&gt; <em>int</em></li>
<li><em>read_string</em>: <em>string</em> -&gt; <em>string</em>
<ul>
<li><em>read_int</em> and <em>read_string</em> take a prompt-string argument.</li>
</ul>
</li>
<li></li>
<li><em>print_qbit</em>: <em>qbit</em> -&gt; <em>unit</em>
<ul>
<li>prints a string <em>q</em><code>(</code><em>A</em><code>|0&gt;</code>+<em>B</em><code>|1&gt;)</code>, the qbit's index <em>q</em> and a representation of its state as a probability vector in the computational basis. In probabilities the constant <code>h</code> means <em>sqrt</em>(1/2), and <code>h(</code><em>k</em><code>)</code> means (<em>sqrt</em>(1/2))<sup><em>k</em></sup>. If <em>q</em> is entangled with <em>q'</em> you will see stuff like <code>[</code><em>q</em>;<em>q'</em><code>](</code><em>A</em><code>|00&gt;</code>+<em>B</em><code>|01&gt;+</code><em>C</em><code>|10&gt;</code>+<em>D</em><code>|11&gt;)</code>. The standard example would be <code>[0,1](h|00&gt;+h|01&gt;)</code>. And so on for larger entanglements.</li>
</ul>
</li>
<li><em>print_string</em>: <em>string</em> -&gt; <em>unit</em></li>
<li><em>print_strings</em>: <em>string list</em> -&gt; <em>unit</em></li>
</ul>
