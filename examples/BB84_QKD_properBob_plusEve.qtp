
Alice(n:int, qB, bsB, report) = 
  (new chosen) 
  (  Choose (n,[],chosen)
   | chosen?(bvs) . 
     report!map fst bvs .
     report!map snd bvs .
     (new sent)
     (  SendBits (bvs, qB, sent)
      | sent?(_) .
        Negotiate (bvs, bsB, report)
     )
  )
  
(* choose n basis,bit pairs -- this could all be done with Random *)
Choose(n, bvs, chosen) =
    (let bs = randbits n) (let vs = randbits n) chosen!zip bs vs . _0

(* send encoded bits down channel qB *)
SendBits (bvs,qB,sent) =   
    match bvs .
        []         . sent!() . _0
    <+> (b,v)::bvs . (newq q = match b,v .
                                   0b0,0b0 . |0> 
                               <+> 0b0,0b1 . |1> 
                               <+> 0b1,0b0 . |+> 
                               <+> 0b1,0b1 . |-> 
                               hctam
                     )
                     qB!q.
                     SendBits(bvs,qB,sent)
    hctam

Negotiate (bvs,bsB,report) =
    bsB!map fst bvs . (* send him my bases *)
    bsB?(bBs)       . (* receive his bases *)
    report!bBs      .
    (new reconciled) 
    (  Reconcile (bBs, bvs, [], reconciled)
     | reconciled?(rvs)  . (* rvs are the values we should agree upon *)
       report!rvs        . 
       bsB?(mask)        . (* A mask of rvs: 0b1 if sampled *)
       report!mask       .
       bsB?(vBs)         . (* vBs are the bits to check, from vs *)
       report!vBs        .
       (new checked)
       (  CheckBits (mask, vBs, rvs, checked)
        | checked?(b)       . 
          (new filtered)
          (  Filter (mask, rvs, [], filtered)
           | filtered?(code)   .
             report!if b then 0b1 else 0b0 fi::code . 
             bsB?(codedvs)     .
             report!codedvs    .
             (let message = map (uncurry2 xor_bits) (zip code codedvs))
             report!message    .
             _0
          )
      )
    )
    
(* check that masked bits in vs match vBs *)
CheckBits (mask, vBs, vs, result) =
  match mask, vBs, vs .
      []       , []     , []    . result!true . _0
  <+> 0b1::mask, vB::vBs, v::vs . if v=vB then CheckBits (mask, vBs, vs, result) 
                                          else result!false . _0 
                                  fi
  <+> 0b0::mask, _      , v::vs . CheckBits (mask, vBs, vs, result)
  <+> _                         . result!false . _0
  hctam

Reconcile (bBs,bvs,vs,result) =
  match bBs, bvs .
       []     , []         . result!rev vs . _0
   <+> bB::bBs, (b,v)::bvs . Reconcile (bBs, bvs, if bB=b then v::vs else vs fi, result)
   <+> _                   . {abandon "Reconcile failure"} . _0
   hctam
  

Filter (mask, vs, code, done) =
  match mask, vs .
      0b1::mask , v::vs . Filter (mask, vs, code, done)
  <+> 0b0::mask, v::vs  . Filter (mask, vs, v::code, done)
  <+> _                 . done!rev code . _0
  hctam
  
Bob(n:int, qA, bsA, report) = 
    (new received, reconciled) 
    (  ReceiveBits(n,[],qA,received)
     | received?(bvs)     . (* bvs is what I saw *)
       report!map fst bvs .
       report!map snd bvs .
       bsA?(bAs)          . (* receive her bases *)
       report!bAs         .
       bsA!map fst bvs    . (* send my bases *)
       Reconcile (bAs,bvs,[],reconciled)
     | reconciled?(rvs) . (* the bits we should agree on *)
       report!rvs       .
       (new sampled)
       (  Sample (rvs, [], [], sampled)
        | sampled?(mask)   .
          sampled?(sample) .
          bsA!mask         . (* send her the mask *)
          bsA!sample       . (* send her the sample *)
          (new filtered)
          (  Filter (mask, rvs, [], filtered)
           | filtered?(code) .
             report!code    .
             (let message = randbits (length code))
             report!message .
             (let codedvs = map (uncurry2 xor_bits) (zip code message))
             bsA!codedvs    .
             _0
          )
       )
    )
  
(* receive qbits, measure them, record the results *)
ReceiveBits(n,bvs,qA,result) =
    if n=0 then result!rev bvs . _0
    else qA?(q).
         (let basis = randbit ())
         q =?[if basis=0b1 then _H else _I fi] (value) .
         dispose!q .
         ReceiveBits(n-1,(basis,value)::bvs,qA,result)
    fi
       
(* sample the agreed bits at random: take a quarter for check bits *)
Sample (vs, mask, sample, result) =
  match vs .
      []    . result!rev mask . result!rev sample . _0
  <+> v::vs . (let b1, b2 = randbit(), randbit()) 
              if b1=0b0 && b2=0b0 then 
                Sample (vs, 0b1::mask, v::sample, result)
              else
                Sample (vs, 0b0::mask, sample, result)
              fi
  hctam

(* a very naive eavesdropper. Sees Alice's bits but messes with them. Knows 'n', somehow *)
Eve (n, qA, qB, report) =
    (new done) (  EvesDrop(n,[],qA,qB,done)
                | done?(bvs) .
                  report!map fst bvs .
                  report!map snd bvs .
                  _0
               )
  
EvesDrop (n, bvs, qA, qB, result) =
    if n=0 then result!rev bvs . _0
    else qA?(q) .
         (let b = randbit ())
         q=?[if b=0 then _I else _H fi](v) . 
         qB!q . 
         EvesDrop (n-1, (b,v)::bvs, qA, qB, result)
    fi

System() = (let k = read_int "number of trials")
           (let n = read_int "number of qbits")
           (let verbose = read_bool "with commentary" "y" "n")
           Report (k, verbose, n)
           
Report (k, verbose, n) = Controller (k, 0, verbose, 0, 0, 0, -1, n)

Controller (k, i, verbose, nAlice, nEve, sumChecks, minChecks, n) =
  if k=i then {print_strings ["all done: "; 
                              string_of_value nEve;            " Eve's; ";
                              string_of_value nAlice;          " Alice's; ";
                              string_of_value (k-nAlice-nEve); " false positive(s); ";
                              "average check bits "; string_of_value (sumChecks/k); 
                              " minimum check bits "; string_of_value minChecks; "\n"
                             ]
              } . 
              _0 
         else {print_strings ["trial number "; string_of_value (i+1); if verbose then "\n" else " " fi]} .
              (new qc1,qc2,bsc,reportA,reportB,reportE)
              (  Alice (n,qc1,bsc,reportA) 
               | Bob   (n,qc2,bsc,reportB) 
               | Eve   (n,qc1,qc2,reportE) 
               | reportA?(bsA)   .
                 reportA?(vsA)   .
                 {if verbose then print_strings ["Alice chose "; string_of_value (zip bsA vsA); "\n"] else () fi} .
                 reportE?(bsE) .
                 reportE?(vsE) .
                 {if verbose then print_strings ["Eve saw "; string_of_value (zip bsE vsE); "\n"] else () fi} .
                 reportB?(bsB) .
                 reportB?(vsB) .
                 {if verbose then print_strings ["Bob saw "; string_of_value (zip bsB vsB); "\n"] else () fi} .
                 reportB?(bAs)         .
                 {if verbose then print_strings ["Alice sent bases "; string_of_value bAs; "\n"] else () fi} .
                 reportA?(bBs)  .
                 {if verbose then print_strings ["Bob sent bases "; string_of_value bBs; "\n"] else () fi} .
                 reportA?(rvAs)   . 
                 {if verbose then print_strings ["Alice reconciled "; string_of_value rvAs; "\n"] else () fi} .
                 reportB?(rvBs) .
                 {if verbose then print_strings ["Bob reconciled "; string_of_value rvBs; "\n"] else () fi} .
                 reportA?(mask) .
                 {if verbose then print_strings ["Bob sent check-bit mask "; string_of_value mask; "\n"] else () fi} .
                 reportA?(vBs)  .
                 {if verbose then print_strings ["Bob sent check bits "; string_of_value vBs; "\n"] else () fi} .
                 reportB?(codeB) .
                 {if verbose then print_strings ["Bob's code is "; string_of_value codeB; "\n"] else () fi} . 
                 reportA?(bcodeA) .
                 (let interference, codeA = match bcodeA .
                                                b::code . b<>0b1, code
                                            <+> _       . abandon "can't happen"
                                            hctam
                 )
                 (let nc = length vBs)
                 {print_strings if interference then ["interference detected -- "; string_of_value nc; " check bits\n"]
                                                else []
                                fi
                 } .
                 {if verbose then print_strings ["Alice's code is "; string_of_value codeA; "\n"] else () fi} .
                 reportB?(messageB) .
                 {if verbose then print_strings ["Bob chooses message "; string_of_value messageB; "\n"] else () fi} .
                 reportA?(codedvs)  .
                 {if verbose then print_strings ["Alice sees coded "; string_of_value codedvs; "\n"] else () fi} .
                 reportA?(messageA) .
                 {if verbose then print_strings ["Alice decodes message "; string_of_value messageA; "\n"] else () fi} .
                 (let corrupt = messageB<>messageA)
                 (let evewins = not interference && corrupt)
                 {print_strings if evewins then ["Eve wins -- "; string_of_value nc; " check bits\n"]
                                           else []
                                fi
                 } .
                 (let nAlice, nEve = if   interference then nAlice+1, nEve      (* Alice spotted her *)
                                     elif corrupt      then nAlice  , nEve+1    (* Alice didn't spot her, and she corrupted the message *)
                                     else                   nAlice  , nEve      (* somehow she was missed, and the message was ok *)
                                     fi
                 )
                 (let minChecks = if minChecks<0 then nc elif nc<minChecks then nc else minChecks fi)
                 Controller (k, i+1, verbose, nAlice, nEve, sumChecks+nc, minChecks, n)
              )
  fi
