(* a sophisticated eavesdropper. Plays Bob to Alice, Alice to Bob. Knows that 
   Alice generates more code bits than she needs.
 *)
(* a mess, because it should use sub-processes *)

proc Eve (qcA, qcB, bcA, bcB, againA, againB, logasB, logasA) =
  (new copied) 
  (  CopyBits([],qcA,qcB,bcA,copied)
   | copied?(bs) . copied?(vs)      . (* bs, vs are what I _sent_ *)
     logasA!bs   . logasA!vs        .
    
     copied?(basesA) . bcA!bs       .   (* note Alice's bases; send my bases to her *)
        
     bcB!bs . bcB?(basesB)          .   (* send my bases to Bob; receive his in return *)
     (let rvsB = reconcile basesB bs vs)
     bcB?(maskB) . bcB?(checkbitsB) .   (* receive Bob's mask and check bits *)
                                        (* but ignore his check bits *)
     logasA!checkbitsB              .   (* -- other than logging them *)
     (let codeB = mask_filter 0b0 maskB rvsB)
   
     (* do a Bob-style calculation of a check mask and check bits *)
     (let rvsA = reconcile bs basesA vs)
     (let maskA = tabulate (length rvsA) cb_choose)
     (let checkbitsA = mask_filter 0b1 maskA rvsA)
     (let codeA = mask_filter 0b0 maskA rvsA)
   
     (* don't worry if Alice doesn't have enough code bits: she will signal if necessary *)
     bcA!maskA                      .   (* send check bits and mask *)
     bcA!checkbitsA                 . 
   
     (* see if Alice is ok with that *)
     (    againA?(_)                .   (* Alice didn't get enough code bits *)
            logasB![bool2bit true]  .
            againB!()               .   (* round again, Bob *)
            logasA![bool2bit true]  .
            Eve (qcA, qcB, bcA, bcB, againA, againB, logasB, logasA)
      <+> bcA?(encrypted)           .   (* receive her encrypted message *)
            EveFinish (length bs, qcA, qcB, bcA, bcB, againA, againB, logasB, logasA, codeA, codeB, encrypted)
     )
  )          

proc EveFinish (n, qcA, qcB, bcA, bcB, againA, againB, logasB, logasA, codeA, codeB, encrypted) =
  (* there is a possibility that Bob may not have enough code bits ... *)
  if length codeB<length encrypted then
    againB!()                       .   (* round again, Bob (but not Alice) *)
        logasB![bool2bit true]      .
    EveLoop (n,qcA, qcB, bcA, bcB, againA, againB, logasB, logasA, codeA, encrypted)
  else
    (* decode from Alice as Bob would *)
    (let message = xor_mask (take (length encrypted) codeA) encrypted)
        logasB![bool2bit false]     .   (* Bob isn't going round again *)
        logasA![bool2bit false]     .   (* and neither is Alice *)
        logasB!encrypted            .
        logasA![bool2bit true]      .   (* I got the message *)
        logasA!message              .   (* and here it is *)
    (* encode for Bob as Alice would *)
    bcB!xor_mask (take (length message) codeB) message       
                                .   
    _0
  fi
   
(* just do the Bob preamble again and then EveFinish *)
proc EveLoop (n, qcA, qcB, bcA, bcB, againA, againB, logasB, logasA, codeA, encrypted) =
  (* in case Bob is suspicious, send him new qbits *)
  (let bs = randbits n)
  (let vs = randbits n)
  (new sent)
  (  SendBits (zip bs vs, qcB, sent)            (* just like Alice, ho ho! *)
   | sent?(_)                               .
        logasA!bs                              .  
        logasA!vs                              .
     bcB!bs . bcB?(basesB)                  .   
     (let rvsB = reconcile basesB bs vs)
     bcB?(maskB) . bcB?(checkbitsB)         .   
        logasA!checkbitsB                      .
     (let codeB = mask_filter 0b0 maskB rvsB)
     EveFinish (n, qcA, qcB, bcA, bcB, againA, againB, logasB, logasA, codeA, codeB, encrypted)
  )
  
proc CopyBits (bvs, qcA, qcB, bcA, result) =
        qcA?(q)                                  . 
            (let b = randbit ())
            q=?[if b=0 then _I else _H fi](v)   . 
            qcB!q                                . 
            CopyBits ((b,v)::bvs, qcA, qcB, bcA, result)
    <+> bcA?(basesA)                            . 
            (let bvs = rev bvs)
            result!map fst bvs                  . 
            result!map snd bvs                  . 
            result!basesA                       .
            _0

