fun basisv_of_bits b v = match b,v .
                         + 0b0,0b0 . |0> 
                         + 0b0,0b1 . |1> 
                         + 0b1,0b0 . |+> 
                         + 0b1,0b1 . |-> 

(* send encoded (bit, value) pairs down channel qc *)
proc SendQbits (bvs,qc,sent) =   
    match bvs .
    + []         . sent!() . _0
    + (b,v)::bvs . (newq q = basisv_of_bits b v)
                     qc!q    .
                     SendQbits (bvs,qc,sent)

(* receive qbits on channel qc, measure them, return the results 
   when you see a tagged message on channel bsc
 *)
proc ReceiveQBits (bvs, qc, bsc, results) =
  + bsc?(tag,bits)          . 
        (let bs, vs = unzip (rev bvs))
        results!bs          . 
        results!vs          .
        results!tag         .
        results!bits        .
        _0
  + qc?(q)                  . 
        (let basis = randbit ())
        q =?[if basis=0b1 then _H else _I fi] (value) .
        ReceiveQBits((basis,value)::bvs,qc,bsc,results)

(* Read qbits from qA, measure them in a random bases, send the measured bits on qB. 
   Stop when you see a message on bsA, and return measurements, tag and message.
 *)
proc CopyQBits (bvs, qA, qB, bsA, results) =
    + qA?(q)            . (let b = randbit ())
                          q=?[if b=0b0 then _I else _H fi](v) . 
                          (newq q = match b,v .
                                    + 0b0,0b0 . |0>
                                    + 0b0,0b1 . |1>
                                    + 0b1,0b0 . |+>
                                    + 0b1,0b1 . |->
                          ) 
                          qB!q                              . 
                          CopyQBits ((b,v)::bvs, qA, qB, bsA, results)
    + bsA?(tag,bits)    . (let bs, vs = unzip (rev bvs))
                          results!bs                        . 
                          results!vs                        .
                          results!tag                       .
                          results!bits                      .
                          _0

(* filter out masked bits *)
fun mask_filter (m:''a) (mask:''a list) (vs:'b list) : 'b list
   = vs where _, vs = unzip mvs
        where mvs = filter (lam (me,_) . me=m) (zip mask vs)

(* check that masked bits in vs match check bits *)
fun test_checkbits mask checks vs 
     = forall (lam (cb,vb) . cb=vb) 
              (zip checks (mask_filter 0b1 mask vs)) 

fun xor_mask code message 
  = map (lam (b1,b2) . if b1=b2 then 0b0 else 0b1 fi) (zip code message)

(* pick out the bits that are in the same bases *)
fun reconcile b1s b2s vs = mask_filter 0b0 (xor_mask b1s b2s) vs
    
(* select check bits randomly. Use 1/4 probability because it's easy *)
fun cb_choose _ = if randbit()=0b1 && randbit()=0b1 then 0b1 else 0b0 fi

fun bit2bool b = b=0b1
fun bool2bit b = if b then 0b1 else 0b0 fi

fun compose (f : 'b -> 'a) (g : 'c -> 'b) (v : 'c) : 'a = f (g v)

fun semicolon (g : 'c -> 'b) (f : 'b -> 'a) : ('c -> 'a) = compose f g

fun read_min_int m s
  = k where k = if j>=m then j 
                else semicolon (lam _ . print_strings ["pardon? at least "; show m; "\n"])
                               (lam _ . read_min_int m s)
                               ()
                fi
      where j = read_num s
    
fun int_sqrt n = i_s 0 n
                   where i_s k n = if k*k>=n then k else i_s (k+1) n fi
  
fun histo buckets ns
  = match ns .
    + []    . buckets
    + n::ns . histo ((n,length pre+1)::buckets) post
                  where pre = takewhile sameas ns
                  where post = dropwhile sameas ns
                  where sameas = lam k . k=n

fun histogram ns = histo [] (sort ns)

fun listsum ns = foldl (lam sum n . sum+n) 0 ns

fun listmin ns = foldl (lam sofar n . min sofar n) (hd ns) (tl ns)

fun packets rs (size:num) (bits:bit list) : bit list list
  = match bits .
    + [] . rs
    + _  . packets (take size bits::rs) size (drop size bits)

fun hwc message keys i w : bit list 
  = if w=0 || message=[] then [0b0] else
      hwc1 message
        where hwc1 bits = 
                match hps .
                + [hash] . hash
                + ps     . hwc1 (concat hps)
                  where hps = map (lam p . num2bits (bitand mask (key*bits2num p))) ps
                  where ps = packets [] size bits
        where key = nth keys i
        where size = 2*s
        where mask = bits2num (tabulate s (const 0b1)) (* 2^s-1 *)
        where s = ceiling ((w+1)/3*4+1)     (* odd, at least, and bigger than w *)
    fi
  
fun tagged keys i w message = hwc message keys i w, message
  
fun checkhash hks w (i,(h,m)) = hwc m hks i w = h
