(* given a random qbit (a|0>+b|1>), this may terminate with
   either a|0>+b|1> or a|0>-b|1>. Interesting, eh? Only 
   'really' works if the initial qbit is |0> or |+> 
   -- i.e. an unfair coin.
 *)

P(fromQ:^qbit, toQ:^qbit) =   fromQ?(y) . toQ!y . _0
                            | fromQ?(y) . 
                              (let n = print_string "with _X\n")
                              y>>_X . toQ!y . _0
                     
Q(x: qbit, toP:^qbit, fromP:^qbit) = 
  (let n = print_strings ["initially "; qbit_state x; "\n"])
  x>>_H . toP!x . fromP?(z) . z>>_H . 
  (let n = print_strings ["finally "; qbit_state z; "\n"])
  _0 

System() = (let bv = read_string "initial state (0,1,+,-)")
           (newq x = match bv .
                         "0" . |0> 
                     <m> "1" . |1> 
                     <m> "+" . |+>
                     <m> "-" . |->
                     <m> _   . abandon "bad initial state"
                     hctam
           ) 
           (new s:^qbit, r:^qbit) 
           (P(s,r) | Q(x,s,r))
