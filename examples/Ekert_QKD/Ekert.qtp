fun bit2int b = if b=0b0 then 0 else 1 fi

fun inverse b = if b=0b0 then 0b1 else 0b0 fi

fun rand4() = i1*2+i2 where i1=bit2int b1
                      where i2=bit2int b2
                      where b1,b2 = randbit(), randbit()

fun combine bs bvs = zip (zip bs (map fst bvs)) (map snd bvs)

fun sanitise bbvs =
  map (lam ((b, b'), v') . if b=b' then 0b0 else v' fi) bbvs
  
fun compose (f : 'b -> 'a) (g : 'c -> 'b) (v : 'c) : 'a = f (g v)

(* produce pairs (h|01>-h|10> -- the '-' is crucial *)
proc Source(qcA,qcB) = (newq a=|1>,b=|->) b,a >> _Cnot . qcA!a . qcB!b . Source(qcA,qcB)

fun frow xs (i,j) =
  i, j, zs, length (filter (lam (vi,vj) . vi=vj) zs)
      where zs = map (lam ((_,vi),(_,vj)) . vi,vj) ys
      where ys = filter (lam ((i',_),(j',_)) . i=i' && j=j') xs
      
fun crossprod xs ys =
  match xs . + []    . []
             + x::xs . row x ys @ crossprod xs ys
                         where row x ys = match ys . + []    . []
                                                     + y::ys . (x,y) :: row x ys
                                                     
proc Control(qcA,qcB,n,k,nq) =
  if n=k then _0 
  else
    {(* if (k+1) % 1000 = 0 then *) print_strings ["trial number "; show (k+1); "\n"] (* else () fi *)} .
    (new ic,bc,logcA, logcB)
    | Alice (nq,qcA,ic,bc,logcA)
    | Bob (qcB,ic,bc,logcB)
    | logcA?_ . logcB?_ . 
        (* {print_strings ["Alice saw "; show vA; " in basis "; show bA;
                        "; Bob saw "; show vB; " in basis "; show bB; "\n"
                       ]} . *)
        Control(qcA,qcB,n,k+1,nq)
  fi
  
proc System() = 
  (let n = read_int "number of trials")
  (let nq = read_int "number of qbits")
  (new qcA,qcB) | Source(qcA,qcB)
                | Control(qcA,qcB,n,0,nq)
