fun bit2int b = if b=0b0 then 0 else 1 fi

fun bool2bit b = if b then 0b1 else 0b0 fi
fun bit2bool (b:bit) :bool = b=0b1

fun inverse b = if b=0b0 then 0b1 else 0b0 fi

fun rand4() = i1*2+i2 where i1=bit2int b1
                      where i2=bit2int b2
                      where b1,b2 = randbit(), randbit()

fun combine bs bvs = zip (zip bs (map fst bvs)) (map snd bvs)

fun sanitise bbvs =
  map (lam ((b, b'), v') . if b=b' then 0b0 else v' fi) bbvs
  
fun compose (f : 'b -> 'a) (g : 'c -> 'b) (v : 'c) : 'a = f (g v)

(* apply the non-interference test *)
(* All the tests are about choosing from a sequence of k ~= nq/9 with 
   probability (1+h)/2 (where h=1/sqrt 2) ~= 0.854. The standard deviation 
   sigma = sqrt (k*(1+h)/2*(1-h)/2) = sqrt (k/8). 
 *)

fun int_sqrt n = i_s 0 n

fun i_s k n =
  if k*k>=n then k 
  else i_s (k+1) n fi

fun abs i = if i<0 then -i else i fi

fun check bs b's vs v's ij = 
  nsigmas<5 where nsigmas = abs (mean-ndiff)/sigma
  nsigmas<5 where nsigmas = if sigma<>0 then abs (mean-ndiff)/sigma
                               else 0 where _ = print_strings ["non-interference check finds "; show size;
                                                               " "; show ij; "s in\n"; show bbvvs; 
                                                               "\n -- less than 8 is too few for statistical investigation\n"]
                               fi
            where mean = size*854/1000
            where sigma = int_sqrt ((size+4)/8)
            where ndiff = length (filter (lam (v,v') . v<>v') vv_ijs)
            where size = length vv_ijs
            (* where _ = print_strings ["combine "; show bbvvs; "; "; show vv_ijs; "\n"] *)
            where vv_ijs = map snd (filter (lam (ij',_) . ij=ij') bbvvs)
            where bbvvs = zip (zip bs b's) (zip vs v's)
            
fun xor_mask code message = 
  map (lam (b1,b2) . if b1=b2 then 0b0 else 0b1 fi) (zip code message)

fun frow xs (i,j) =
  i, j, zs, length (filter (lam (vi,vj) . vi=vj) zs)
      where zs = map (lam ((_,vi),(_,vj)) . vi,vj) ys
      where ys = filter (lam ((i',_),(j',_)) . i=i' && j=j') xs
      
fun crossprod xs ys =
  match xs . + []    . []
             + x::xs . row x ys @ crossprod xs ys
                         where row x ys = match ys . + []    . []
                                                     + y::ys . (x,y) :: row x ys
                                                     
(* *************************************************************************************** *)

(* produce pairs (h|01>-h|10> -- the '-' is crucial (well maybe not, but I do use anti-correlation in calculations) *)
proc Source(qcA,qcB) = (newq a=|1>,b=|->) b,a >> _Cnot . qcA!a . qcB!b . Source(qcA,qcB)

proc System() = 
  (let n = read_int "number of trials")
  (let nq = read_int "number of qbits")
  (new qcA,qcB) | Source(qcA,qcB)
                | Control(qcA,qcB,n,0,nq)
