(* check that masked bits in vs match check bits *)
letr test_checkbits mask checks vs =
  match mask, checks, vs .
      []       , []        , []    . true
  <+> 0b1::mask, cb::checks, v::vs . if v=cb then test_checkbits mask checks vs 
                                             else false 
                                     fi
  <+> 0b0::mask, _         , v::vs . test_checkbits mask checks vs
  <+> _                            . false
  hctam .

(* pick out the bits that are in the same bases *)
Reconcile (bs,bvs,vs,result) =
  match bs, bvs .
       []    , []         . result!rev vs . _0
   <+> b'::bs, (b,v)::bvs . Reconcile (bs, bvs, if b'=b then v::vs else vs fi, result)
   <+> _                  . {abandon "Reconcile failure"} . _0
   hctam
  
(* filter out masked bits *)
letr masked_filter mask vs filtered =
  match mask, vs .
      0b1::mask, v::vs  . masked_filter mask vs filtered
  <+> 0b0::mask, v::vs  . masked_filter mask vs (v::filtered)
  <+> _                 . rev filtered
  hctam .

letr xor_mask code message = map (uncurry2 xor_bits) (zip code message) .

(* sample bits at random: take a quarter for check bits *)
Sample (vs, mask, sample, result) =
  match vs .
      []    . result!rev mask . result!rev sample . _0
  <+> v::vs . (let b1, b2 = randbit(), randbit()) 
              if b1=0b0 && b2=0b0 then 
                Sample (vs, 0b1::mask, v::sample, result)
              else
                Sample (vs, 0b0::mask, sample, result)
              fi
  hctam

