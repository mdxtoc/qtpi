%!TEX TS-program = pdflatexmk
\documentclass[11pt,a4paper]{book}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subfigure}
\usepackage[round]{natbib}
\usepackage[pagebackref]{hyperref}
\usepackage{verbatim}
\usepackage{verbatimbox}
\usepackage{mdwlist} % compact lists
\usepackage{ifthen}

\hoffset = 0mm
\voffset = 0mm
\textwidth = 165mm
\textheight = 229mm
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
%\headheight = 0.0 in
%\headsep = 0.0 in
\parskip = 3pt
\parindent = 0.0in

\makeatletter
\renewcommand{\@makefntext}[1]{\setlength{\parindent}{0pt}%
\begin{list}{}{\setlength{\labelwidth}{1em}%
  \setlength{\leftmargin}{\labelwidth}%
  \setlength{\labelsep}{3pt}\setlength{\itemsep}{0pt}%
  \setlength{\parsep}{0pt}\setlength{\topsep}{0pt}%
  \footnotesize}\item[\hfill\@makefnmark]#1%
\end{list}}
\makeatother

\makeatletter
\newcommand{\mvb}[1]{\begin{myverbbox}[\ifthenelse{\equal{\the\verbatim@line}{}}{\vspace{-5pt}}{}]{#1}}
\makeatother

%\newcommand{\greyorcolour}[2]{#2} % #1 highlighting (etc.) for greyscale, #2 for colour
%\input{rbmacros}

\input{qmacros}

\makeatletter
\def\verbatim@font{\ttfamily\footnotesize}
\makeatother

\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{2297}{\ensuremath{\otimes}}
\DeclareUnicodeCharacter{2041}{\ensuremath{{/}\mspace{-9.1mu}}\raisebox{-0.47ex}{\ensuremath{{\wedge}}}}
\DeclareUnicodeCharacter{03BB}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{2190}{\ensuremath{\leftarrow}}
\DeclareUnicodeCharacter{2192}{\ensuremath{\rightarrow}}
\DeclareUnicodeCharacter{2193}{\ensuremath{\downarrow}}
\DeclareUnicodeCharacter{1D106}{\ensuremath{|\mspace{-1mu}\!|\!\mspace{0.7mu}|\!\!:}}
\DeclareUnicodeCharacter{2322}{} % ignore frown
\DeclareUnicodeCharacter{20EB}{\ensuremath{\mspace{4mu}/\!\mspace{-1mu}/\mspace{-22mu}\frown}}
\DeclareUnicodeCharacter{0338}{\ensuremath{\mspace{6mu}/\mspace{-19mu}\frown}}
\DeclareUnicodeCharacter{221A}{\ensuremath{\sqrt{}}}
\DeclareUnicodeCharacter{1D745}{\ensuremath{\pi}}
\DeclareUnicodeCharacter{2194}{\ensuremath{\leftrightarrow}}\mathlig{<->}{\leftrightarrow}



\newcommand{\verbtt}[1]{\texttt{\small{}#1}}
\newcommand{\verbttf}[1]{\texttt{\footnotesize{}#1}}

\var{prog,pdef,fdef,pat,bpat,Pname[Pn],Fname[fn],E,P,Q,IO,T,TV[tv],Const}

\newcommand{\caret}[0]{\ensuremath{{}^{\wedge}}}

\title{Qtpi, a simulator for quantum protocols (and more)}
\author{Richard Bornat \\ School of Science and Technology, Middlesex University, London, UK \\ R.Bornat@mdx.ac.uk, richard@bornat.me.uk}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\chapter{An introduction to qtpi}

Qtpi is a symbolic calculator controlled by a programming language, designed to simulate quantum computation, especially computation in quantum security protocols. The language is also called qtpi.
I designed and built it simply because I found it hard, using pencil and paper, to check the calculations that underpin quantum security protocols and other famous quantum programs. The calculator is precise, using no approximations such as floating-point numbers. Protocol agents are processes, communication is via channels, there are quantum computation operations, qubits can be sent in messages, classical calculation is supported. 

The language isn't entirely novel: Raja Nangarajan was a colleague who was encouraging me to work on quantum stuff, and he was one of the authors of CQP \citep{GaySJ:comqp}, a development of the pi calculus \citep{DBLP:journals/iandc/MilnerPW92a} which could describe \underline{C}ommunicating \underline{Q}uantum \underline{P}rotocols. I made some changes from CQP which I thought would make qtpi more useful, but it remains obviously a CQP and pi calculus descendant. 

Qtpi began life as a simulator for quantum security protocols. It's still most impressive, perhaps, when it's dealing with protocols, but nowadays it can do somewhat more complicated simulations. I introduce it using examples. \Chapref{corenotation} describes the language more formally, for those who want to skip to the chase. \Chapref{symboliccalculator} tells how it manages to perform precise symbolic calculation.

\section{An example using gates and interaction}

\citep{quantumfulladderquantumdaily}, a web page about how to build a quantum equivalent of a hardware full-adder, shows a diagram from which I've extracted \figref{Cogginsfulladdercircuit}. 
\var{Cin,Sum,Cout}
\begin{figure}
\centering
\vspace{3pt}
\mbox{\Qcircuit @C=1em @R=.7em {
\lstick{A\ \ket{\alpha}}      & \ctrl{3}       & \qw            & \qw            & \ctrl{1} & \ctrl{2} & \qw      & \rstick{} 			  \qw \\
\lstick{B\ \ket{\beta}}       & \qw            & \ctrl{2}       & \qw            & \ctrl{3} & \qw      & \ctrl{1} & \rstick{}  			  \qw \\
\lstick{\<Cin>\ \ket{\gamma}} & \qw            & \qw            & \ctrl{1}       & \qw      & \ctrl{2} & \ctrl{2} & \rstick{} 			  \qw \\
\lstick{\<Sum>\ \ket{0}}      & \targ          & \targ          & \targ          & \qw      & \qw      & \qw      & \rstick{\ket{\phi}}   \qw \\
\lstick{\<Cout>\ \ket{0}}     & \qw            & \qw            & \qw	         & \targ    & \targ    & \targ    & \rstick{\ket{\psi}}   \qw
     }}
\vspace{3pt}
\caption{A quantum full adder, adapted from \citep{quantumfulladderquantumdaily}}
\figlabel{Cogginsfulladdercircuit}
\end{figure}
The diagram, read left-to-right, describes how Qubits A, B and Cin, in some unknown states \bv{\alpha}, \bv{\beta} and \bv{\gamma}, can be processed to produce their single-bit sum as a qubit Sum in state \bv{\phi} and a carry out as a qubit Cout in state \bv{\psi}. Sum and Cout each start in state \zero{}. The intention is to imitate a classical hardware full adder, with the quantum state \zero{} simulating classical 0, and \one{} simulating 1. The original has an extra X gate, which isn't needed, and some measurement steps which I've omitted (but I'll get to measurement eventually).

The first three gates each use CNot which, provided the inputs are each either \zero{} or \one{}, will flip the target qubit (Sum) \zero{}$<->$\one{} if the input qubit (A, B or Cin) is \one{}, or leave it unchanged if the input is \zero{}. So Sum, which starts at \zero{}, can be flipped zero, one, two or three times, becoming respectively \zero{}, \one{}, \zero{} or \one{} respectively. That's definitely what a half-adder should do. The next three gates are Toffoli gates: flip the target qubit (Cout) if \emph{both} inputs are \one{}. So again, with inputs which are each \zero{} or \one{}, Cout gets flipped zero times if they are all \zero{}, once if there are two \one{}s, and three times if they are all \one{}, becoming respectively \zero{}, \one{} and \one{}. That's what a full adder should do. 

But what if some of the inputs are in some superposition state, a mixture of \zero{} and \one{}, as qubits famously can be? We shall see ...

\mvb{\Cogginszerooneone}
proc System () =
  . (newq qA=|0>, qB=|1>, qCin=|1>) 
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  .
\end{myverbbox}
\begin{figure}
\centering
\Cogginszerooneone
\caption{A simulation of \figref{Cogginsfulladdercircuit}, with \bv{\alpha}=\zero{}, \bv{\beta}=\one{} and \bv{\gamma}=\one{}}
\figlabel{Cogginszerooneone}
\end{figure}

\Figref{Cogginszerooneone} is a program that simulates the circuit from \figref{Cogginsfulladdercircuit} with a particular starting state for each of the input qubits. In qtpi's process notation, following the pi calculus, declarations are bracketed and process steps -- such as quantum gating, quantum measurement, and message passing -- are separated by dots rather than semicolons. Qtpi lets you use extra dots if you wish and I like to put a dot at the start of each line because it keeps things aligned and stops me forgetting to include a dot.  Processes are introduced in groups, starting with the word `proc'. Every qtpi program must have a start-up process called System which takes no arguments and sets up the simulation. In this example the set-up only has to create five qubits and define their initial states, and then simulates the calculations in the diagram. It doesn't produce any output (but we'll come to that). 

The first line of System, with a \verbtt{newq} declaration, creates three input qubits, in which each qubit name starts with a lower-case `q' because there's an informal qtpi convention that names starting with an upper-case letter should be reserved for processes (but it's informal and it's often broken, so don't worry too much about it). The next two lines are the six steps of the diagram: \verbtt{q,...,q>>G} puts qubit(s) \verbtt{q,...,q} through gate G; this program uses CNot and T (for Toffoli), which are gates from qtpi's library. The process terminates on its fifth line with a blank step.

We can put this program in a file called \verbtt{Coggins.qtp}, and if we run it with a trace switch
\begin{quote}\verbtt{qtpi Coggins.qtp -trace}\end{quote}
we can see what the program does. \Figref{Cogginszerooneonetrace} shows that trace. The first five lines record the setup of the qubits: qubit \#0 is qA, \#1 is qB, \#2 is qCin, \#3 is qSum, and \#4 is qCout. The fifth line doesn't flip qSum, because qA is \zero{}; the sixth and seventh each flip qSum because qB and qCin are each \one{}. The next two lines don't flip qCout, because qA and qB aren't both \one{}, and neither are qA and qCin; the last line does flip qCout because qB and qCin are both \one{}. So in classical terms, from input 011 it's produced sum 0 and carry-out 1, as a full adder should.  

\mvb{\Cogginszerooneonetrace}
System creates #0:|0⟩

System creates #1:|1⟩

System creates #2:|1⟩

System creates #3:|0⟩

System creates #4:|0⟩

System (#0:|0⟩,#3:|0⟩) >> Cnot; result (#0:|0⟩,#3:|0⟩)

System (#1:|1⟩,#3:|0⟩) >> Cnot; result (#1:|1⟩,#3:|1⟩)

System (#2:|1⟩,#3:|1⟩) >> Cnot; result (#2:|1⟩,#3:|0⟩)

System (#0:|0⟩,#1:|1⟩,#4:|0⟩) >> T; result (#0:|0⟩,#1:|1⟩,#4:|0⟩)

System (#0:|0⟩,#2:|1⟩,#4:|0⟩) >> T; result (#0:|0⟩,#2:|1⟩,#4:|0⟩)

System (#1:|1⟩,#2:|1⟩,#4:|0⟩) >> T; result (#1:|1⟩,#2:|1⟩,#4:|1⟩)
\end{myverbbox}%can't be a macro
\begin{figure}
\centering
\Cogginszerooneonetrace
\caption{Trace of the full adder, with starting qubits \zero, \one{} and \one{}}
\figlabel{Cogginszerooneonetrace}
\end{figure}

So far, so simple. But qtpi is a programming language, and you can use input functions to control what it does. A more useful version of the program is shown in \figref{Cogginswithinput}: the istate function asks the user to type `0', `1', `+' or `-' and returns a value which is correspondingly either \zero{}, \one{}, \plus{} or \minus{}. The next-to-last line of the program outputs the final states of the qCout and qSum qubits. The `\verbtt{ch!E}' step sends the value of the expression \verbtt{E} down the channel \verbtt{ch}. Channels are strongly typed: `\verbtt{out}' accepts lists of strings which it prints out; `\verbtt{outq}' accepts a single `\verbtt{qstate}' value and prints it out, and `\verbtt{qval q}' delivers such a value. So the `\verbtt{outq!qval q}' step prints out the state of a qubit without revealing it to the program because there's nothing a qtpi program can do to interrogate a \verbtt{qstate}. The last line terminates the process with a blank step. 

Running this program with inputs which are each \zero{} or \one{} produces accurate simulated-classical-arithmetic results like \figref{Cogginswithinputtrace}. Pretty straightforward, as far as simulated-classical full adder behaviour is concerned.

\mvb{\Cogginswithinput}
fun istate x = 
  read_alternative x "," [("0",|0>); ("1",|1>); ("+",|+>); ("-",|->)]

proc System () =
  .(newq qA   = istate "qA", 
         qB   = istate "qB",
         qCin = istate "qCin").
  
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  . out!["qSum="] . outq!qval qSum . out!["; qCout="] . outq!qval qCout .  out!["\n"] 
  . 
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinput
\caption{A full adder with input and output}
\figlabel{Cogginswithinput}
\end{figure}
\mvb{\Cogginswithinputtrace}
qA (0,1,+,-)? 1
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 1
qSum=#3:|1⟩; qCout=#4:|1⟩
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinputtrace
\caption{Full-adder simulation output with classical-simulating input}
\figlabel{Cogginswithinputtrace}
\end{figure}

\subsection{Simulating a non-classical sum}

What's interesting about the full adder is that it can work with quantum superpositions as input. If we start with qA=$\plus{}=\frac{1}{\sqrt2}(\zero+\one)$, an equal-probability superposition of \zero{} and \one{}, but we make qB=\one{} and qCin=\zero{}, we discover that the outputs are not a simple classical-simulating \zero{} or \one{}, but instead a three-way entangled superposition, as shown by \figref{Cogginswithinputplusout}. The states of qSum and Cout are a multi-qubit state combining the states of \#0, \#3 and \#4 (qA, qSum, qCout). That state is an equal-probability superposition of \zeroonezero{} or \onezeroone{}, with probability $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$ in each case. 

Notice that you can read this superposition as a superposition of possible classical inputs and corresponding classical answers. If \#0 (qA) is \zero{}, then \#3 (qSum) has to be \one{} and \#4 (qCout) \zero{}; if \#0 is \one{}, then \#3 has to be \zero{} and \#4 \one{}. Given that qB is \one{}, those are the two possible correct answers.

If we turn tracing on we can see how all this arises,\footnote{To produce this trace I used \verbtt{-trace -gatingsimplifies true} which asks for a trace but also asks that unnecessarily large multi-qubit states are simplified after each gating step. Qtpi doesn't do that sort of simplification by default.} in \figref{Cogginswithinputplustrace}. There's quite a lot in there: it will take some unpicking.
\mvb{\Cogginswithinputplusout}
qA (0,1,+,-)? +
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 0
qSum=#3:[#0;#3;#4]1/√2(|010⟩+|101⟩); qCout=#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinputplusout
\caption{Full-adder input superposition produces entangled outputs}
\figlabel{Cogginswithinputplusout}
\end{figure}
\mvb{\Cogginswithinputplustrace}
System creates #0:1/√2(|0⟩+|1⟩)

System creates #1:|1⟩

System creates #2:|0⟩

System creates #3:|0⟩

System creates #4:|0⟩

System (#0:1/√2(|0⟩+|1⟩),#3:|0⟩) >> Cnot;  
      result (#0:[#0;#3]1/√2(|00⟩+|11⟩),#3=#0)

System (#1:|1⟩,#3:[#0;#3]1/√2(|00⟩+|11⟩)) >> Cnot; 
      result (#1:|1⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩))

System (#2:|0⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩)) >> Cnot;  
      result (#2:|0⟩,#3:[#0;#3]1/√2(|01⟩+|10⟩))

System (#0:[#0;#3]1/√2(|01⟩+|10⟩),#1:|1⟩,#4:|0⟩) >> T;  
      result (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#1:|1⟩,#4=#0)

System (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#2:|0⟩,#4=#0) >> T;  
      result (#0:[#0;#3;#4]1/√2(|010⟩+|101⟩),#2:|0⟩,#4=#0)

System (#1:|1⟩,#2:|0⟩,#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)) >> T;  
      result (#1:|1⟩,#2:|0⟩,#4:[#0;#3;#4]1/√2(|010⟩+|101⟩))
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinputplustrace
\caption{How the full-adder entanglement happens}
\figlabel{Cogginswithinputplustrace}
\end{figure}

\subsection{Entanglement in the full-adder simulation}

The first CNot line in \figref{Cogginswithinputplustrace} entangles qubits \#0 and \#3 (qA and qSum). It's inevitable: the probability that qA is \zero{} is $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$, so with that probability both qubits are \zero{}; with the same probability qA is \one{}, qSum is flipped and both qubits are \one{}.\footnote{Whether or not that explanation matches physical reality, that's the way the matrix arithmetic works. It's possible that quantum reality is wierder than quantum computation.} That entanglement, one of the famous Bell states, can't be separated unless one of the qubits is measured.

The second CNot line flips qSum, because qB in this example is \one{}; technically the result is a three-qubit state combining \#0, \#1 and \#3 as $\frac{1}{\sqrt2}(\zerooneone+\oneonezero)$, but because \#1 (qB) is \one{} in both the equal-probability it's reasonable to separate it out to give the result shown, \#1 listed separately from the entanglement of \#0 and \#3. The new entanglement, $\frac{1}{\sqrt2}(\zeroone+\onezero)$, is another of the Bell states, and also inseparable.

The third CNot line doesn't flip qSum, so no change.

The first Toffoli line involves qubit \#0, which is entangled with \#3, qubit \#2 and qubit \#4. With probability $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$ qubits 0 and 3 are \zeroone, which doesn't flip qubit \#4; with the same probability they are \onezero{}, which does. So we get the \#0, \#3, \#4 entanglement listed.

The second two Toffoli lines don't do any flips, so no change. 

\subsubsection{.. and its calculations}

The CNot gate is 4$\times$4: it operates on a 4-amplitude state, i.e. on two qubits. The second and third CNot lines in \figref{Cogginswithinputplustrace} ask it to operate on three qubits, which is an 8-amplitude state. Consider, for example, the second CNot step, taking qB \#1 as its source qubit and \#3 as its target. \#3 is entangled with \#0, which has nothing to do with the CNot, but has to be included nevertheless, so 3 bits to be processed. The standard quantum computation solution to this situation is as follows:
\begin{enumerate*}\item combine the source qubit \#1 and the entanglement \#0 and \#3 with tensor multiplication, giving the combined state of qubits  \#1, \#0 and \#3 as $\frac{1}{\sqrt2}(\onezerozero+\oneoneone)$; 
\item manipulate that state to show the qubits in the order \#1, \#3, \#0 as $\frac{1}{\sqrt2}(\onezerozero+\oneoneone)$ (looks the same but isn't, because the qubits read differently);
\item put that state through $\<CNot>\otimes\<I>$, -- CNot for the first two qubits, I for the third. That gate is
\begin{equation*}
\qgatethree{1&0&0&0&0&0&0&0}
           {0&1&0&0&0&0&0&0}
           {0&0&1&0&0&0&0&0}
           {0&0&0&1&0&0&0&0}
           {0&0&0&0&0&0&1&0}
           {0&0&0&0&0&0&0&1}
           {0&0&0&0&1&0&0&0}
           {0&0&0&0&0&1&0&0}
\end{equation*}
which swaps \onezerozero{} with \oneonezero{}, \onezeroone{} with \oneoneone{}, and vice-versa. 
\item the resulting combined state  of \#1, \#3 and \#0 is $\frac{1}{\sqrt2}(\onezeroone+\oneonezero)$, in which qubit \#1 is \one{} in either superposed state, so it can be  separated out leaving $\frac{1}{\sqrt2}(\zeroone+\onezero)$ as an entanglement of \#3 and \#0;
\item manipulate that to make an entanglement of \#0 and \#3, $\frac{1}{\sqrt2}(\zeroone+\onezero)$ (again, looks the same but isn't).\end{enumerate*}
Qtpi does that sort of calculation easily, without making mistakes. I used to find it hard to do it accurately with paper and pencil: hence qtpi.

\subsection{Measuring the full-adder result}

I haven't completely exhausted the lessons I can draw from the simulated full adder. Notice that the program in \figref{Cogginswithinput} doesn't do any quantum measurement. Instead it uses the `\verbtt{outq!qval q}' step to print out the state of a simulated qubit. \Figref{Cogginswithinputandmeasurement} measures qSum and qCout using the `\verbtt{q⌢̸(b)}' step to measure a qubit q and call the result b; then it prints out what the measurements produced using the \verbtt{out} channel (`show E' translates any qtpi value, except for qubits, functions and processes, into a string) and prints the states of the input qubits. 

This program doesn't always print the same result even though given the same inputs, because measurement affects the state of the measured qubit, thereby unpicking any entanglement it's involved in. One result of running this program, with the same inputs as before, is shown in \figref{Cogginswithinputandmeasurementoutput}. It says the sum is 0 and the carry out is 1. That comes from the second element of the entanglement: by measuring qSum, it forced the simulation to choose, and the simulation flipped a coin and chose \onezeroone{}. The measurement thus collapses the entanglement, choosing one of the superposed states, forcing qA and qCout each to be \one{}. That effect is shown in the measurement result of qCout (it's bound to be 1), and in the state of qA (it's \one{}, and not the superposition it started as). Run it again, with the same inputs, and you might get the other superposed state \zeroonezero{}, which would force qA to be \zero{}, qSum to be \one{}, and qCout to be \zero{}.
 
\mvb{\Cogginswithinputandmeasurement}
fun istate x = 
  read_alternative x "," [("0",|0>); ("1",|1>); ("+",|+>); ("-",|->)]

proc System () =
  .(newq qA   = istate "qA", 
         qB   = istate "qB",
         qCin = istate "qCin").
  
  . (newq qSum=|0>, qCout=|0>) 
  
  . qA,qSum>>CNot  . qB,qSum>>CNot    . qCin,qSum>>CNot 
  . qA,qB,qCout>>T . qA,qCin,qCout>>T . qB,qCin,qCout>>T 
  
  . out!["qSum="] . outq!qval qSum . out!["; qCout="] . outq!qval qCout .  out!["\n"] 
  
  . qSum⌢̸(sum) . qCout⌢̸(cout)
  
  . out!["qSum measured "; show sum; ", and qCout measured "; show cout; "\n"]
  . out!["now qA="] . outq!qval qA . out![", qB="] . outq!qval qB 
  . out![", and qCin="] . outq!qval qCin . out!["\n"]
  . 
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinputandmeasurement
\caption{The full adder with measurement of the result qubits}
\figlabel{Cogginswithinputandmeasurement}
\end{figure}
\mvb{\Cogginswithinputandmeasurementoutput}
qA (0,1,+,-)? +
qB (0,1,+,-)? 1
qCin (0,1,+,-)? 0
qSum=#3:[#0;#3;#4]1/√2(|010⟩+|101⟩); qCout=#4:[#0;#3;#4]1/√2(|010⟩+|101⟩)
qSum measured 0, and qCout measured 1
now qA=#0:|1⟩, qB=#1:|1⟩, and qCin=#2:|0⟩
\end{myverbbox} %can't be a macro\begin{figure}
\centering
\Cogginswithinputandmeasurementoutput
\caption{caption}
\figlabel{Cogginswithinputandmeasurementoutput}
\end{figure}

That's it for the full adder. Nothing so far on processes or protocol agents, and the only use of messages or channels was sending lists of strings down the \verbtt{out} channel, and special \verbtt{qstate} values down the \verbtt{outq} channel.
 
\section{An example using processes and messages}
\seclabel{cointossworkedexample}

In his story ``The Idyll of Miss Sarah Brown'', which was used as the plot of the musical ``Guys and Dolls'', Damon Runyon reports the advice received by Obadiah Masterson (The Sky) from his father:
\begin{quote}
\textit{``Son,'' the old guy says, ``no matter how far you travel, or how smart you get, always remember this: some day, somewhere,'' he says, ``a guy is going to come to you and show you a nice brand-new deck of cards on which the seal is never broken, and this guy is going to offer to bet you that the jack of spades will jump out of this deck and squirt cider in your ear. But, son,'' the old guy says, ``do not bet him, for as sure as you do you are going to get an ear full of cider.''}
\end{quote}
Meyer \citep{meyer1999quantumstrategies} describes the start of just such an encounter:
\begin{quote}
The starship \textit{Enterprise} is facing some imminent -- and apparently inescapable -- calamity when Q appears on the bridge and offers to help, provided Captain Picard can beat him at penny flipping: Picard is to place a penny heads up in a box, whereupon they will take turns (Q, then Picard, then Q) flipping the penny (or not), without being able to see it. Q wins if the penny is heads up when they open the box.
\end{quote}
Picard takes the bet, because in classical game theory he has a 50\% chance of success. But he really shouldn't, because Q wouldn't make the offer unless he already knew how to win.

In the classical world there's no winning strategy for Q: if he flips once, he loses if Picard passes; if he flips twice or passes twice, he loses if Picard flips. So classically he has 50\% chance of winning. But Meyer is making a point about game theory in a quantum world: if the coin is a qubit, if `heads' is \zero{} and `tails' \one{}, if `flipping' is putting the qubit through an X gate which changes \zero{} to \one{} and vice-versa, then is there a way to cheat?

Yes, there is. The H gate changes \zero{} to $\plus{}=\frac{1}{\sqrt2}(\zero+\one)$ and vice-versa. and is certainly not `flipping' as Picard. Picard X-flips do nothing to \plus{}. Q does H first; then whether Picard X-flips or not the coin is still \plus{}; Q does H again, the coin will be \zero{}, and Q wins. Picard's ear is full of metaphorical cider.

It is possible to read this as a simple example of a deep quantum property. Q puts the qubit into a state which is an equal-probability superposition of \zero{} and \one{}: amplitude $\frac{1}{\sqrt2}$ in each case, probabilities $|\frac{1}{\sqrt2}|^{2}=\frac{1}{2}$. An X-flip by Picard, should he choose to do it, changes that into an equal-probability superposition of \one{} and \zero{} -- no change, no use to Picard, no problem for Q who just H-flips back to \zero{}. Q always wins because he's playing a quantum game and Picard isn't. Q's H-flip trick depends on starting with \zero{}, but there's a different matrix he could use instead if they started with \one{}. Picard should have read more Damon Runyon (and so should you: it's very witty). Even without that background he should have been suspicious, because Q gets two flips to his one: why is that?

Damon Runyon's story is witty and believable, but Meyer's isn't \emph{quite} a believable scenario, even if you believe in Star Wars. There's no way to see, just by looking, whether a qubit is \zero{} or \one{} or anything else: quantum measurement doesn't work that way. But hey! This is science fiction, so we can pretend. Let's pretend by simulating the swindle: I've done it using two processes to stand for Picard and Q as protocol agents, and I've made Picard measure the qubit, once the flipping is all done, to see if he gets 0 (Q wins) or 1 (Picard wins).

\mvb {\cointoss}
proc System() = . (new ch:^qubit) 
                . | Picard(ch) | Q(ch)  

     Picard(ch) = . (newq q=|0>) 
                  . ch!q
                  . ch?(r)
                  . r >> if randbool() then X else I
                  . ch!r 
                  . ch?(s)
                  . s⌢̸(b)
                  . out!["the qubit measured "; show b; 
                         if b=0b0 then ". Q wins.\n" else "! I win!\n"
                        ]
                  .

     Q(ch) = ch?(t) . t>>H . ch!t . ch?(u) . u>>H . ch!u .  
\end{myverbbox}
\begin{figure}
\centering
\cointoss
\caption{Q is set up to swindle Picard}
\figlabel{cointoss}
\end{figure}

System in \figref{cointoss} only has to create a channel and two processes, giving them each the channel so they can pass the penny/qubit between them, and then let them run.
Its first line creates a channel with a \verbtt{new} declaration, and to emphasise that this is to be used to transmit a qubit, I've given the channel an explicit type. On the second line the process splits into two subprocesses with the `par' construct \verbtt{|...|}, and then turns one subprocess into an invocation of Picard and the other into an invocation of Q. Each invocation gets the channel as argument. The par completes the System process; the invocations complete the subprocesses; no need for any terminating blank steps.

The Picard process makes nine steps, if we count a declaration as a step, and count termination also: 
\renewcommand{\labelenumi}{P\theenumi}
\begin{enumerate*}
\item \verbtt{(newq q=|0>)} creates a qubit in state \zero{} (heads) and names it q; 
\item \verbtt{ch!q} sends q down the channel ch; 
\item \verbtt{ch?(r)} receives a qubit from the ch channel and names it r; 
\item \verbtt{r >> if randbool() then X else I} puts qubit r through a gate, using a conditional expression to choose an X gate or an I gate at random (but, since r must be \plus{}, neither gate has any effect); 
\item \verbtt{ch!r} sends the gated r back down the ch channel; 
\item \verbtt{ch?(s)} receives a qubit from the ch channel and names it s;
\item \verbtt{s⌢̸(b)} measures s, naming the result b (b will be a classical bit, either 0b0 or 0b1);
\item \verbtt{out![...]} describes the measurement result by sending a list of strings down the \verbtt{out} channel;
\item terminates with an empty/blank step.
\end{enumerate*}

The Q process makes seven steps: 
\renewcommand{\labelenumi}{Q\theenumi}
\begin{enumerate*}
\item \verbtt{ch?(t)} receives a qubit from the ch channel, and names it t;
\item \verbtt{t>>H} puts t through an H gate (which, since t must be \zero{}, changes it to \plus{}); 
\item \verbtt{ch!t} sends t down the ch channel back to Picard; 
\item \verbtt{ch?(u)} receives a qubit from the ch channel (which must be \plus{}), and names it u;
\item \verbtt{u>>H} puts u through an H gate (which changes \plus{} to \zero{});
\item \verbtt{ch!u} sends u (which must be \zero{}) down the ch channel; 
\item terminates with an empty/blank step
\end{enumerate*}
\renewcommand{\labelenumi}{\theenumi}

The two processes run in parallel, but in practice one is always waiting for the other: Q's \verbtt{ch?(t)} has to wait until Picard has reached \verbtt{ch!q}, and then Picard's \verbtt{ch?(r)} has to wait until Q reaches \verbtt{ch!t}; and so on. So in this example, as in many others, it's all interleaving.

%There is only one qubit when this program runs, created with \verbtt{newq q} and measured in \verbtt{s⌢̸(b)}, which the two processes pass between them. When one has the qubit it can gate it, while the other is waiting to get it back. It would be physically impossible in real life for two protocol agents to share access to a qubit and to gate or measure it both at the same time. Qtpi enforces this real-life property in part by insisting that once a qubit has been sent away it can't be used again. I've emphasised this by using three different names for the qubit in the Picard process, and two other names in Q, but it could have been q all the way through the program.
 
I can put this program in a file \verbtt{cointoss.qtp} and run \verbtt{qtpi cointoss.qtp}; the output (just as expected) is always 
\begin{quote}
\verbtt{the qubit measured 0. Q wins.}
\end{quote}
Running \verbtt{qtpi cointoss.qtp -trace} records quantum declarations and steps, and all messages, and prints it out when the program terminates. \Figref{cointoss_trace} shows a sample trace. The trace is almost identical if Picard uses the I gate. Obviously, Q always wins.

\mvb{\cointosstrace}
the qubit measured 0. Q wins.

Event Trace:

Picard creates #0:|0⟩

0: Picard -> Q Qubit #0

Q #0:|0⟩ >> H; result #0:1/√2(|0⟩+|1⟩)

0: Q -> Picard Qubit #0

Picard #0:1/√2(|0⟩+|1⟩) >> X; result #0:1/√2(|0⟩+|1⟩)

0: Picard -> Q Qubit #0

Q #0:1/√2(|0⟩+|1⟩) >> H; result #0:|0⟩

0: Q -> Picard Qubit #0

Picard: #0:|0⟩ ⌢̸ ; result 0
\end{myverbbox}
\begin{figure}
\centering
\cointosstrace
\caption{Despite X-flipping, Picard loses}
\figlabel{cointoss_trace}
\end{figure}

\section{A harder worked example}
\seclabel{teleportworkedexample}

Coin tossing doesn't really need two processes, but consider the famous quantum teleportation protocol \citep{bbcjp:93,teleportwiki}. I shan't try to explain everything about how or why the protocol works, but I shall show how to simulate it in qtpi. The protocol has two participant agents, conventionally called Alice and Bob. It's quite tricky, so I'll do in in stages.  This is the problem and its starting position:
\begin{quote}
Alice has a qubit whose state $\bv{\phi}=a\zero+b\one$ she doesn’t know. She wants to send the state of this qubit 
to Bob through classical channels. Alice and Bob each possess one qubit of an entangled pair in state $\bv{\psi}=\frac{1}{\sqrt{2}}(\zerozero+\oneone)$.
\end{quote}
Qtpi can simulate this rather well, using symbolic calculation with variables used to represent unknown amplitudes -- $a$ and $b$ in this description, $a_{2}$ and $b_{2}$ in the simulation, as we shall see.

\subsection{Creating an entanglement and an `unknown' qubit}

The System process in this example has to create an entangled pair and a couple of processes, connected with a channel. We've already seen how to create qubits and how to invoke processes and connect them. Entanglement we've already seen in the full-adder example:
\begin{quote}
Take two qubits, one in state $\plus=\frac{1}{\sqrt{2}}(\zero+\one)$, the other in state $\zero$, and put them through a CNot gate.
\end{quote}
To create Alice's unknown qubit, she can use a \verbtt{newq} declaration which doesn't specify the state of the new qubit. The program that creates the starting position is in \figref{teleportinit2}.

\mvb {\teleportinit}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch:^(bit,bit))
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        .  

     Bob(b:qubit, ch) = 
        . 
\end{myverbbox}
\begin{figure}
\centering
\teleportinit
\caption{Setting up Alice and Bob with a connecting channel, and acquiring Alice's unknown qubit}
\figlabel{teleportinit2}
\end{figure}

System begins by creating the two qubits to be entangled\footnote{Sharp-eyed readers will notice that the order in which the qubits are declared in \figref{teleportinit} is b, then a. That's because it makes Alice's calculation easier to interpret, as you will see in \secref{whatshappening}. The entanglement is unaffected by the order of declaration: it's always $\frac{1}{\sqrt{2}}(\zerozero+\oneone)$ whether a or b is listed first.} and then puts them through a CNot gate as the recipe requires. Then it declares a new channel, and just to emphasise how it's to be used, says via explicit typing that it carries pairs of (classical) bits. Then as in the previous example it splits into two subprocesses, one invoking Alice with the `a' qubit and the channel, the other Bob with the `b' qubit and the channel.  

The trace of this program is shown in \figref{teleportinittrace}. The first two events create qubits \#0 and \#1 in states \plus{} and \zero{}. The third event entangles them. The fourth event creates qubit \#2, so far unentangled with either \#0 or \#1, whose amplitudes $a_{2}$ and $b_{2}$ are unspecified. This isn't quite how the starting position is described, but it's ok: qtpi uses a $_{2}$ suffix because it's describing qubit number 2 in the simulation. All that the qtpi calculator knows about the unknown amplitudes is that $|a_{2}|^{2}+|b_{2}|^{2}=1$. We have our starting position. 

\mvb {\teleportinittrace}
System creates #0:1/√2(|0⟩+|1⟩)

System creates #1:|0⟩

System (#0:1/√2(|0⟩+|1⟩),#1:|0⟩) >> Cnot; 
      result (#0:[#0;#1]1/√2(|00⟩+|11⟩),#1=#0)

Alice creates #2:(a2|0⟩+b2|1⟩)
\end{myverbbox}
\begin{figure}
\centering
\teleportinittrace
\caption{Trace of execution, up to the starting position}
\figlabel{teleportinittrace}
\end{figure}

\subsection{Alice gates and measures her qubits}

Alice only has access to qubits \verbtt{a} and \verbtt{c} (qubits \#1 and \#2), while Bob has control of \verbtt{b} (\#0). The protocol proceeds by Alice measuring her qubits in a way that entangles them with Bob's. The original paper requires measurement in a complicated four-dimensional basis, and qtpi is not (yet) set up to do that. The other technique, revealed in the Wikipedia page, is to put bits c and a through a sort of reverse entanglement -- Cnot for c and a, then H for c alone -- before measuring in the computational basis. Just why the measurement is useful is discussed in \secref{whatshappening}; before that we look at what the measurement does. 

\Figref{teleportmeasure} shows the program. Alice does the CNot, H steps and then measures a and c. The order of measurement doesn't matter. The classical-bit results are bound to names va and vc. Bob is still passive. \Figref{teleportmeasuretrace} shows the part of the trace that covers Alice's calculation and measurement steps.

\mvb {\teleportmeasure}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch)
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a⌢̸(va) . c⌢̸(vc)
        . 

     Bob(b:qubit, ch) = 
        . 
\end{myverbbox}
\begin{figure}
\centering
\teleportmeasure
\caption{Alice calculates and measures}
\figlabel{teleportmeasure}
\end{figure}

\mvb {\teleportmeasuretrace}
...
Alice (#2:(a2|0⟩+b2|1⟩),#1:[#0;#1]1/√2(|00⟩+|11⟩)) >> Cnot; 
      result (#2:[#0;#1;#2]1/√2(a2|000⟩+b2|011⟩+b2|101⟩+a2|110⟩),#1=#2)

Alice #2:[#0;#1;#2]1/√2(a2|000⟩+b2|011⟩+b2|101⟩+a2|110⟩) >> H; 
      result #2:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩
                             +b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩)

Alice: #1:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩
                       +b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩) ⌢̸ ; 
      result 0 and (#0:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩),#2=#0)

Alice: #2:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩) ⌢̸ ; 
      result 1 and #0:(a2|0⟩-b2|1⟩)
\end{myverbbox}
\begin{figure}
\centering
\teleportmeasuretrace
\caption{Trace of Alice's calculation and measurement}
\figlabel{teleportmeasuretrace}
\end{figure}

This looks terrifyingly complicated, but notice that in the fourth step everything is reduced to an almost recognisable single-qubit state: $a_{2}\zero-b_{2}\one{}$ is almost the same as the $a_{2}\zero+b_{2}\one{}$ state which Alice was given when she created qubit number 2. So what's going on?


\subsubsection{A glimpse of what's going on}
\seclabel{whatshappening}

(I'm afraid I don't understand why the Cnot, H gating allows the measurement to happen in the \zero{}, \one{} basis. If anybody out there has the time to tell me, please do.)

(This description may tell you more than you wish to know: the details are interesting only if you want to know how qtpi does it. If not, skip to the bit about measurement.)

To cause the first event in \figref{teleportmeasuretrace}, Alice executes \verbtt{c,a>>CNot}: put qubits 2 and 1 through a CNot gate. But qubit 1 is entangled with 0, so there are actually three bits to be considered. We've seen the solution to this problem: rearrange the state a little so it reads in the order \#2, \#1, \#0; put it through $\<CNot>⊗\<I>$, rearrange it again to read in the order \#0, \#1, \#2.

To cause the second event, Alice  puts qubit \#2 (c) through an H gate. That qubit is now entangled with the two others: rearrange the state into \#2, \#0, \#1 order; put that state through $\<H>⊗\<I>⊗\<I>$ (H for \#2, I for the others); rearrange it again to read in the order \#0, \#1, \#2. $\<H>⊗\<I>⊗\<I>$, by the way, is a rather pretty gate:
\newcommand{\h}[0]{\ensuremath{\frac{1}{\sqrt2}}}
\begin{equation*}
\qgatethree{\h&0&0&0&\h&0&0&0}
           {0&\h&0&0&0&\h&0&0}
           {0&0&\h&0&0&0&\h&0}
           {0&0&0&\h&0&0&0&\h}
           {\h&0&0&0&-\h&0&0&0}
           {0&\h&0&0&0&-\h&0&0}
           {0&0&\h&0&0&0&-\h&0}
           {0&0&0&\h&0&0&0&-\h}
\end{equation*}

In the three-qubit state shown in the trace as the result of Alice's H-gating, an entanglement shown in \#0, \#1, \#2 order, qubits \#1 and \#2 are listed last, and \#0 first.\footnote{This is the reason I declared the to-be-entangled qubits in b, a order in System.} We can exploit that fact to rewrite the state as
\begin{equation*}\frac{1}{2}(a_{2}\zero\zerozero+a_{2}\zero\zeroone+b_{2}\zero\onezero-b_{2}\zero\oneone
			b_{2}\one\zerozero-b_{2}\one\zeroone+a_{2}\one\onezero+a_{2}\one\oneone)\end{equation*}
Gathering the \#1, \#2 values together, we can rewrite this as 
\begin{equation*}1/2((a_{2}\zero+b2\one)\zerozero+(a2\zero-b2\one)\zeroone+(b2\zero+a2\one)\onezero+(-b2\zero+a2\one)\oneone)\end{equation*}

This can be read as a four-way choice: if Alice's qubits were \zerozero, then Bob's would have to be $a_{2}\zero+b_{2}\one$; if Alice were to have \zeroone, then Bob would have $a_{2}\zero-b_{2}\one$; and so on. In \figref{teleportmeasuretrace} Alice has measured 0 and 1, and qubit number 0 is indeed in the $a_{2}\zero-b_{2}\one$ state, as predicted. If you ran the program several times you would get different answers: Alice can measure any of the four possible bit combinations, and the simulation follows that faithfully.

When Alice reads her qubits she \emph{must} find a combination which matches one of \zerozero, \zeroone, \onezero{} or \oneone{} and then, \emph{even though she doesn't know what the secret amplitudes $a_{2}$ are $b_{2}$ are}, she will know what combination of those amplitudes and the vectors \zero{} and \one{} make up the state of Bob's qubit, \emph{even though she's never had access to it}. If she tells Bob what she found, he'll know the same (because he knows what the protocol is), and he'll be able to reconstruct the qustate $a_{2}\zero+b_{2}\one$ just by using the gates X and Z to move amplitudes around and change their sign as necessary. 

\subsection{Alice tells Bob, and Bob tidies up}

\Figref{teleportfinal} is the final program. Alice sends the pair of bits which are the result of her measurement -- classical bits, not qubits -- to Bob over their shared channel, Bob receives them and then puts his qubit into one of four gates using a \verbtt{match} construction. (Notice that for typechecking reasons qtpi's bit-constants have to be written as 0b0 and 0b1 rather than num-constants 0 and 1.) 

The gates that Bob uses can be justified as follows:

\begin{enumerate}
\item if Alice measured \zerozero, Bob has $a_{2}\zero+b_{2}\one$ already, and has nothing to do -- an I gate does nothing; 
\item if Alice measured \zeroone, Bob has $a_{2}\zero-b_{2}\one$: he has to change the sign of the \one{} amplitude -- a Z gate will do that;
\item if Alice measured \onezero, Bob has $b_{2}\zero+a_{2}\one$: he has to swap the amplitudes -- an X gate will do that;
\item if Alice measured \oneone, Bob has $-b_{2}\zero+a_{2}\one$: he has to use X to swap the amplitudes and then Z to change the sign of the \one{} amplitude -- Z*X does that. 
\end{enumerate}

\begin{figure}
\begin{verbatim}
proc System () = 
        . (newq b=|+>, a=|0>)  
        . b,a>>CNot 
        . (new ch)
        . | Alice(a,ch) | Bob(b,ch)

     Alice (a:qubit, ch) = 
        . (newq c) 
        . c,a>>CNot . c>>H . a⌢̸(va) . c⌢̸(vc)
        . ch!(va,vc) .

     Bob(b:qubit, ch) = 
        . ch?(pair)
        . b >> match pair . + (0b0,0b0) . I
                            + (0b0,0b1) . Z
                            + (0b1,0b0) . X
                            + (0b1,0b1) . Z*X 
        .
\end{verbatim}
\caption{Alice sends to Bob, who tidies up}
\figlabel{teleportfinal}
\end{figure}

When the program is run and Alice measures 0 and 1 the trace ends as shown in \figref{teleportfinal_trace}. Bob \emph{always} gets the right answer, even though Alice doesn't always send the same message, as you can see if you run this program for yourself.
\begin{figure}
\begin{verbatim}
Alice: #1:[#0;#1;#2]1/2(a2|000⟩+a2|001⟩+b2|010⟩-b2|011⟩+b2|100⟩-b2|101⟩+a2|110⟩+a2|111⟩) ⌢̸ ; 
      result 0 and (#0:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩),#2=#0)

Alice: #2:[#0;#2]1/√2(a2|00⟩+a2|01⟩+b2|10⟩-b2|11⟩) ⌢̸ ; result 1 and #0:(a2|0⟩-b2|1⟩)

0: Alice -> Bob (0,1)

Bob #0:(a2|0⟩-b2|1⟩) >> Z; result #0:(a2|0⟩+b2|1⟩)
\end{verbatim}
\caption{Trace of Alice's measurement in the (0,1) case, her message, and Bob's final step}
\figlabel{teleportfinal_trace}
\end{figure}

\chapter{Core language}

The language described in this document is a mildly tweaked version of CQP. Separate chapters describe additions:  

\begin{description}
\item[logging sub-processes] allow you to attach output statements to a process without obscuring its content;  
\item[iterative sub-processes] can simplify the description of some algorithms;  
\item[qubit collections] allow you to simulate algorithms that deal with vectors of qubits.
\end{description}

\section{Minor points}
\subsection{Qubit or qbit?}
The world uses `qubit' for `quantum bit'. CQP used `qbit' for the simulated qubits a program manipulates, and at first qtpi did the same. Qbit actually would be a better name, because `qubit' looks as if it should be pronounced `quoobit'. But it's too late to change the world's mind, and qtpi now uses `qubit' (though it still accepts `qbit' in programs, because why not?).

\section{The offside parsing rule}

Most languages use lots of brackets in their syntax. You sometimes have to use brackets in OCaml, for example, around the clause which follows `then', when there is no `else' to bracket it, and likewise after the `else' because there's no bracket to match `if'.

When I began to implement Qtpi I thought that I'd do the Algol 68 thing and use `if .. then .. else .. fi'. When I added pattern matching, I introduced a construct which started `match' and ended `hctam'. It looked horrible, and I could never remember how to spell hcatm.

Landin's \emph{offside rule} -- no part of a construct should be to the left and below the first symbol of the construct -- often makes closing brackets unnecessary. In the expression $E$ where $E'$, `where' mustn't be left of $E$ and $E'$ mustn't be left of `where'. This disambiguates things like 

\begin{verbatim}
		hwc key message
		  where message = packets [] bits
		                    where bits = f message
		                    where f = g key
		  where key = ...
\end{verbatim}
	
-- the first \verbtt{where} affects only \verbtt{hwc key message}; the second and third affect only \verbtt{packets [] bits}; the fourth affects everything.

So far the offside parser applies to function definitions (expression to the right of '='), to `where' clauses, to `match'es in processes and expressions, to guarded sums, to parallel process compositions and to conditionals. In conditionals `fi' is optional (but offside parsing is not).

\subsection{Mostly-optional typing}

Qtpi has an automatic typechecker, so types are mostly optional. Mostly I omit explicit types when I'm writing a program, but of course it's a matter of taste, and sometimes types clarify a program. 

In order to permit matrix arithmetic, numerical arithmetic and trigonometric arithmetic, arithmetical operators are very highly overloaded. Explicit typing is sometimes necessary to resolve ambiguities.

\subsection{Syntax-description conventions}

\newcommand{\asep}[0]{\ \bigm{|} \ }
\newcommand{\optq}[1]{\ensuremath{\overline{\underline{[}}#1\overline{\underline{]}}}}
\newcommand{\optT}[0]{\;\optq{\!:\!T}}
In syntax descriptions, optional items are in decorated square brackets \optq{\;\; }. Repetition is represented by ellipsis: three dots for a non-empty sequence, two dots for possibly empty, with a bit of common-sense needed for separating symbols. So $\<pdef>\ ...\ \<pdef>$ is a non-empty sequence of \<pdef>s, for example, and $\<E>,\ ..\ ,E$ is a possibly-empty tuple of \<E>s, separated by commas

\subsection{Awful syntax error messages}

The parser, as currently implemented, can generate \emph{awful} error messages: `syntax error at line k character j' sort of thing. This is shameful and can prompt hair tearing. I'm sorry, I'm ashamed, and I really will fix it one day. I blame Donald Knuth and the automatic parser generators that he enabled.

\section{Program syntax}

\begin{figure}
\centering $$
\begin{array}{rcl}
\<prog> &::=& \verbtt{proc}\ \<pdef>\ ...\ \<pdef>\ \<prog> \\
	   &|&	  \verbtt{fun}\ \<fdef>\ ...\ \<fdef>\ \<prog> \\
	   &|&	  \verbtt{let}\ \<bpat>\ =\ E\ \<prog>\ \vspace{3pt} \\
\<pdef> &::=& \<Pname>(x\optT,\ ..\ ,z\optT) = P \vspace{3pt} \\
\<fdef> &::=& \<Fname>\ \<bpat>\ ...\ \<bpat> = E \\
\end{array} $$
\caption{Program syntax}
\figlabel{programsyntax}
\end{figure}

In \figref{programsyntax} a program is a sequence of process, function and variable definitions. Processes and functions are gathered into mutually-recursive groups.
\begin{itemize}
\item Process names \<Pname> start, by convention, with an upper-case letter; function names \<Fname> with a lower-case letter. (It's probably a silly convention because variable names $x$ can start with either case.) After the first letter, names continue with an alphanumeric sequence of characters.
\end{itemize}

\newcommand{\adot}{\;.\;}
\newcommand{\abar}{\;|\;}
\newcommand{\abang}{\;!\;}
\newcommand{\aquery}{\;?\;}
\var{alt,par,cond,decl}
\section{Process syntax (\setvar{P}, \setvar{IO}, \setvar{Q})}

Processes \<P> are where all the quantum stuff happens; expressions \<E> do classical calculations. Process syntax is detailed in \figref{processsyntax}: you can send and receive qubits in \<IO> steps, gate them or measure them in \<Q> steps. You can also send and receive classical values. But because qubits simulate strange quantum stuff, there are things you can't do with qubits, detailed in \secref{keepitreal}.

The notation is based on the pi calculus, enhanced with quantum steps and pattern matching. Steps are separated by dots rather than semicolons, and an empty step terminates a process. There are declarations, various ways of choosing between sub processes, parallel composition of sub processes, and a process can turn into another process. 
\begin{itemize}
\item $E!E,...,E$ sends a message: the first $E$ denotes the channel, and the non-empty tuple the values to be sent. The tuple doesn't need to be bracketed, as in the pi calculus. $E!()$ sends an empty tuple. 
\item $E ?(\<bpat>,..,\<bpat>)$ receives a message: the first $E$ denotes the channel, and the received values are bound to names in the bracketed tuple of \<bpat>s. $E?()$ receives an empty tuple. $E?(\_)$ accepts but ignores a message; $E?\_$ is allowed without the brackets.
\item $E,...,E>>E$ puts a non-empty tuple of qubits through the gate denoted by the final $E$. You are allowed to write conditional qubit-valued expressions in a gating step.
\item $q⌢̸(\<bpat>)$ measures a single qubit, binding the single-bit result \verbtt{0b0} or \verbtt{0b1} with the bracketed pattern \<bpat>. The length of the qubit sequence must match the size of the gate it's put through -- e.g. X takes a single qubit, Cnot takes 2, Fredkin takes 3, and so on. Measurement takes place in the computational basis defined by \zero{} and \one. %If you have to measure several qubits, then at present you have to do it with a sequence of measurements: this is a deficiency in the language which doesn't really make a difference, so I haven't fixed it.
\item $q⌢̸[E](\<bpat>)$ temporarily rotates the measurement basis with the gate denoted by E before measuring, and of course rotates it back afterwards. If the gate isn't some sort of rotation you won't be simulating reality. 
\begin{figure}
\centering \ensuremath{
\begin{array}{rcl}
\<IO>   &::=& E \abang E\ ,\ ...\ ,\ E \asep E \aquery (\<bpat>,\ ..\ ,\<bpat>) \asep E \aquery \_ \vspace{3pt} \\
Q       &::=& E, ... ,E \;>\!>\; E \asep q \;⌢̸\; \optq{\;[E]\;}\;(\<bpat>) \vspace{3pt} \\
P       &::=& Q  \adot  P \asep \<IO>  \adot  P \asep \adot P \asep \<decl>\ P \asep \\
		&&    \<Pname>(E,\;..\;,E) \asep \<alt> \asep \<par> \asep \<cond> \asep (\ P\ )\ \asep  \vspace{3pt} \\
\<decl>	&::=& \verbtt{(new } x\optT,\; ...\; ,z\optT ) \asep
		      \verbtt{(newq } x\;\optq{=E}, \;...\; ,z\;\optq{=E} ) \asep 
		      \verbtt{(let}\ \<bpat>=E) \vspace{3pt} \\
\<cond>	&::=& \verbtt{if}\ E\ \verbtt{then}\ P\ \verbtt{else}\ P\ \optq{\verbtt{fi}} \asep
		      \verbtt{match}\ E\  \adot \ \optq{+}\;\<pat> \adot P\; +\; ... \;+\; \<pat> \adot P \vspace{3pt} \\
\<alt>	&::=& \optq{+}\; \<IO>  \adot  P \;+\; ... \;+\;\<IO>  \adot  P \vspace{3pt} \\
\<par>	&::=& \optq{\abar} P  \abar  ...  \abar  P 
\end{array}}
\caption{process syntax}
\figlabel{processsyntax}
\end{figure}
\item Dots separate process steps, and you can insert extra dots if you wish (I find it helps me with layout). A process can be bracketed. An empty process (really it's an empty \<alt>) means termination.
\item Declarations \<decl> -- \verbtt{new} for channels, \verbtt{newq} for qubits, \verbtt{let} for classical values -- are always bracketed. 
\item Nothing follows a process invocation, an \<alt>, a \<par>, a \<cond> or a bracketed process. That kind of austerity comes from the pi calculus, and makes it possible to run the checks described in \secref{keepitreal}.
\item A process invocation $\<Pname>(E,\;..\;,E)$ turns one process into another, an instantiation of the process \<Pname> with parameters $E,\;..\;,E$. It isn't a process \emph{call} because it never returns: it is possible, however, to mix process invocation, \<par>, and message passing so that the new process sends a message back to (part of) the old. Process names, by convention, start with a capital letter, but qtpi doesn't force other names to be lower case so it's a bit of a silly convention (sorry).
\item Conditionals \verbtt{if} and \verbtt{match} choose between processes depending on the value of the classical expression \<E>. The optional `\verbtt{+}' before the first alternative in \verbtt{match} makes offside parsing more effective.
\item Alternatives \<alt> choose between processes on the basis of messages sent or received. Each alternative starts with an \<IO> guard\footnote{Oh dear. Should send guards be allowed in an \<alt>? Probably unrealistic. Sorry about that.} and continues with a process. Just one of the guards will be allowed to succeed, and the corresponding process will be executed. The optional \verbtt{+} before the first alternative helps offside parsing.
\item Parallel composition \<par> makes a process become several processes, simulated in parallel. The optional bar before the first alternative helps offside parsing.
\end{itemize}

\section{Keep it real}
\seclabel{keepitreal}

Quantum bits are not classical bits, in more than the sense that they are not simply 0/1 values. There's a theorem of quantum mechanics which states that there can be no operation which takes a qubit in arbitrary state \bv{\phi} together with any number of other qubits and delivers a state in which there are two qubits each in state \bv{\phi}. No duplication, ever -- so there can be no analogue in quantum computation of the classical assignment $x:=y$. The designers of CQP \citep{GaySJ:comqp} wanted their language to exclude programs that can't really execute. Qtpi loyally follows suit.

Because qtpi is implemented, it isn't quite CQP: for one important thing, at each measurement it makes a probabilistic choice and follows it through, rather than splitting into two possible processes, labelling them with their probabilities, and following both as CQP would. There are some linguistic changes too, especially lifting quantum steps to the level of processes. And because I wanted it to be used, I had to devise ways of restricting the language which keep it real and which I could explain. I chose overkill and simple explanations. 

The sort of qubits that CQP and qtpi simulate are physical things -- atoms, molecules, photons, ... -- with quantised physical state such as spin or polarisation. It makes sense to send such a qubit from one protocol agent to another, and CQP is a language of communicating quantum processes which do just that. Agents can't share such a qubit -- it's in one place or another, not both. This doesn't handle every possible physical experiment: you \emph{might}, for example,  quantise the position of a photon as being with some probability on one of two paths towards detectors, but CQP and qtpi don't try to deal with that.

\begin{enumerate}
\item No uncertainty about naming.
\begin{itemize}
\item You cannot form lists or tuples of non-classical type. 
\item In a tuple of process arguments or values to be sent, a qubit-valued expression must be a single qubit name, and can appear only once in the tuple.
\end{itemize}
\item Functions deal with classical values.
\begin{itemize}
\item Functions cannot take arguments or return values of non-classical type.
\item A function body cannot refer to a free qubit.
\end{itemize}
\item No sharing within processes.
\begin{itemize}
\item A pattern in \verbtt{let} or \verbtt{match} cannot bind a qubit value.
\item A process parameter can be a single qubit or a classical value. In a tuple of process arguments, a qubit-valued argument must be a single qubit name, and can appear only once in the tuple.
\end{itemize}
\item When an agent sends a qubit in a message, it leaves its control and can't be used again (unless it's sent back). 
\begin{itemize}
\item Channels can carry either a single qubit or a classical value.
\item A qubit sent away can't be used later in the process unless redeclared.
\end{itemize}
\item No peeking at the simulation.
\begin{itemize}
\item Qubits can't be compared.
\item The library function \verbtt{show}, applied to a qubit, doesn't give information about its state; the function \verbtt{qval} does, but there are no operations on its result type \verbtt{qstate} other than send and receive.
\end{itemize}
\item No gating silliness.
\begin{itemize}
\item In a gated tuple of qubits, no qubit can be mentioned twice.
\end{itemize}
\item No sharing between sub processes.
\begin{itemize}
\item The qubits used in one arm of a \<par> must be distinct from those used in other arms.
\end{itemize}
\item And a random one.
\begin{itemize}
\item Qubit channels can't be used in \<alt> guards. (Perhaps this could be dropped for receive guards ...)
\end{itemize}

\end{enumerate}
\section{Types \setvar{T}}
\begin{figure}
\centering
\ensuremath{
\begin{array}{rcl}
T    &::=& \verbtt{num} \asep \verbtt{bool} \asep \verbtt{bit} \asep \verbtt{string} \asep \verbtt{char} \asep \verbtt{angle} \asep \verbtt{qubit} \asep \verbtt{gate} \asep \\
     &&    \verbtt{bra} \asep \verbtt{ket} \asep \verbtt{matrix} \asep \verbtt{sxnum} \asep \verbtt{qstate} \asep \<TV> \asep \\
     &&    ^{\wedge}\;T \asep [\;T\;] \asep (T\;,..\;,\;T) \asep T -> ... -> T \asep T\; \verbtt{process} \vspace{3pt} \\
\<TV> &::=& 'x \asep ''x \asep '{*}x   
\end{array}}
\caption{Type syntax}
\figlabel{typesyntax}
\end{figure}
Type syntax is in \figref{typesyntax}.
\begin{itemize}
\item List and tuple types are Miranda style rather than ML style: $[T]$ rather than $T\;\verbtt{list}$; $(T,\;...\;,T)$ rather than $T*\;...\;*T$. Zero-tuple is a type which contains only the value () (cf. ML `unit'); singleton $(T)$ is $T$.
\item \verbtt{num} is the type of numbers: unbounded integers and unbounded-precision rationals (fractions), so that qtpi can do accurate arithmetic.\footnote{Not having a type \verbtt{int} can cause some problems. Some library functions, such as \setvar{take} and \setvar{drop} for example, really don't work with fractional arguments (or, at least, I can't decide what they should do). In such cases you can make use of \setvar{floor}, \setvar{ceiling} and \setvar{round} to resolve problems.}
%\item CQP had range types; qtpi doesn't.
\item \verbtt{bool} is the type of booleans, \verbtt{true} or \verbtt{false}.
\item \verbtt{bit} isn't a subtype of \verbtt{num}.
\item \verbtt{sxnum} is the type of symbolic complex numbers, the values that qtpi's symbolic quantum calculator manipulates.
\item \verbtt{angle} is the type of arguments to sin and cos functions, rational multiples of $\pi$.
\item \verbtt{bra} is the type of unitary row vectors of \verbtt{sxnum}; \verbtt{ket} of unitary column vectors of \verbtt{sxnum}. A qubit state is a ket.
\item \verbtt{matrix}  is the type of matrices of \verbtt{sxnum}; \verbtt{gate} is the type of unitary square matrices.
\item \verbtt{qstate}  is the type of the result of the \setvar{qval}  function (see \secref{specialio}). It's a peek at the simulator state. But a \verbtt{qstate} can't be compared or manipulated in any way. The only useful thing you can do with a \verbtt{qstate}  is to send it down the \setvar{outq} output channel, which prints it out.
\item \verbtt{process} types are necessary in typechecking, but I think they are otherwise useless.
\item The syntactic precedence of types is more or less as listed, or so I hope and intend. 
\item Classical types are everything except \verbtt{qubit}  or those involving \verbtt{qubit}  (but function, process and channel types are classical whatever their internal types).  
\item Equality types are everything except \verbtt{qubit}, \verbtt{qstate} , function and process (or anything involving those).  
\item Channel types (types following $^{\wedge}$) are restricted: they may only be \verbtt{qubit} or classical.
\item Type variables \<TV> are \begin{itemize}
		\item $'x$, a classical type (no qubits);		
		\item $''x$, an equality type (no qubits, qstates, functions, processes);
		\item $'{*}x$, an everything type (includes qubits).
	\end{itemize}
\end{itemize}

\section{Patterns (\setvar{pat}, \setvar{bpat})}

\begin{figure}
\centering
\[
\begin{array}{rcl}
\<pat>   &::=& \_ \asep x \asep \<Const> \asep (\; \<pat>\; ,\; .. \;,\; \<pat>\; ) \asep [\; \<pat>\; ;\; ... \;;\; \<pat>\; ] \asep \<pat>\; ::\; \<pat> \asep \<pat>\ :\ T \vspace{3pt} \\
\<bpat>  &::=& \_ \asep x \asep (\; \<bpat>\; ,\; .. \;,\; \<bpat>\; ) \asep \<bpat>\ :\ T
\end{array}
\]
\caption{Pattern syntax}
\figlabel{patsyntax}
\end{figure}

In matches \<pat> disambiguates lists and tuples and constants. In lets and fdefs, \<bpat> binds names to values, including elements of tuples, and never fails to match. The syntax is in \figref{patsyntax}: a \<pat> can be an empty list; both \<pat> and \<bpat> can be a zero-tuple, a bracketed pattern, or a multi-tuple. Patterns can be typed (but may then need to be bracketed).

\section{Expressions \setvar{E}}

Expressions are as in \figref{expressionsyntax}: constants, names, tuples (including the zero tuple); lists; function applications (by juxtaposition, and left associative so that $E\;E\;E$ is $(E\;E)\;E$); arithmetic and boolean expressions including matrix arithmetic; conditionals. Expressions can be typed.
\var{arithop,compop,logop,elsepart}
\begin{figure}
\centering
\[
\begin{array}{rcl}
E  		&::=&	\<Const> \asep x \asep (\ E\ ,\ ..\ ,\ E\ ) \asep [\ E\ ;\ ...\ ;\ E\ ] \asep E\ E\ \asep E\ :\ T \asep \\
		&&		\verbtt{-}\ E \asep \verbtt{¬}\ E \asep E\ ^{\dag} \asep E\ \<arithop>\ E \asep E\ \<compop>\ E\ \asep E\ \<logop>\ E \asep \\
		&&		E\;@\;E \asep E\;::\;E \asep \\
	  	&&		\verbtt{if}\ E\ \verbtt{then}\ E\ \<elsepart> \asep \verbtt{match}\ E\  \adot \ \optq{+}\;\<pat> \adot E\; +\; ... \;+\; \<pat> \adot E \asep \\
		&&		λ\ \<bpat>\ ...\ \<bpat>\ \adot\ E \vspace{3pt}\\
\<arithop>	&::=&	\verbtt{+}\ \asep \verbtt{-}\ \asep \verbtt{*}\ \asep \verbtt{/}\ \asep \verbtt{\%}\ \asep \verbtt{⊗} \asep \verbtt{**}\ \asep \verbtt{⊗⊗} \vspace{3pt}\\
\<compop>	&::=&	\verbtt{<}\ \asep \verbtt{<=}\ \asep \verbtt{=}\ \asep \verbtt{>=}\ \asep \verbtt{>}\ \asep \verbtt{<>} \vspace{3pt}\\ 
\<logop>	&::=&	\verbtt{\&\&}\ \asep \verbtt{||} \vspace{3pt}\\ 
\<elsepart>	&::=& \verbtt{else}\ E\ \optq{\verbtt{fi}} \asep \verbtt{elif}\ E\ \verbtt{then}\ E\ \<elsepart>
\end{array}
\]
\caption{Expression syntax}
\figlabel{expressionsyntax}
\end{figure}

\subsection{Constants \setvar{Const}}

\begin{itemize}
\item integers;
\item chars \verbtt{'}c\verbtt{'} with the usual escapes -- \textbackslash{n}, \textbackslash{r}, \textbackslash{t} and even \textbackslash{b} (why?);
\item strings \verbtt{"}char..char\verbtt{"} with escapes as for chars;
\item bit constants \verbtt{0b0} and \verbtt{0b1};
\item ket constants \zero, \one, \plus{} and \minus, plus longer versions like \bv{001} and \bv{+-+} and so on and on;
\item bra constants \vb{0}, \vb{1}, \vb{+}, \vb{-}, plus longer versions as for kets; 
\item sxnum constants \verbtt{sx\_0}, \verbtt{sx\_1}, plus functions in library;
\item the zero-tuple () (no one-tuple, and tuples are \emph{always} bracketed) and the empty list [];
\item the angle constant 𝝅
%  * There is no one-tuple.   
%  * Tuples are always bracketed, as in Miranda.  
%  * Match expressions are parsed with the offside rule: the components can't start left of `match`, and the patterns and right-hand-side expressions have to be right of `+`. (Explicit match expressions will one day disappear, I hope, in favour of Miranda-style matching on function parameters.)  
%  * Function applications are *E* *E* -- juxtaposition. And of course left associative, so that *E* *E* *E* is (*E* *E*) *E*.  There's a function library (see below) and perhaps one day there will be downloadable bundles of functions.  
%  * Absolutely no process stuff, no manipulation of qubits. But see \verbtt{print\_string}, \verbtt{print\_strings} and \verbtt{print\_qubit} below.  
\end{itemize}

\subsection{Typechecking expressions}

Expressions can mention qubits, but because of the need to police sharing and duplication, qubit-valued expressions can only be used when gating. Typechecking is mostly straightforward -- comparison operators compare equality types, logical operators deal with booleans, application $E\ E$ is $'a\;->\;'a$ and left-associative -- but arithmetic operators are heavily overloaded.
\begin{itemize}
\item unary `\verbtt{+}' and `\verbtt{-}' are $t->t$, where $t$ is \verbtt{num}, \verbtt{angle} or \verbtt{sxnum};
\item binary `\verbtt{+}' and `\verbtt{-}' are $t->t->t$, where $t$ is \verbtt{num}, \verbtt{angle}, \verbtt{sxnum} or \verbtt{matrix};
\item `\verbtt{*}' can be 
\begin{itemize}
	\item $t->t->t$, where $t$ is \verbtt{num}, \verbtt{angle}, \verbtt{sxnum}, \verbtt{gate} or \verbtt{matrix}
	\item $\verbtt{num}->\verbtt{angle}->\verbtt{angle}$, $\verbtt{angle}->\verbtt{num}->\verbtt{angle}$, $\verbtt{gate}->\verbtt{ket}->\verbtt{ket}$, $\verbtt{ket}->\verbtt{bra}->\verbtt{matrix}$, $\verbtt{bra}->\verbtt{ket}->\verbtt{sxnum}$, $\verbtt{matrix}->\verbtt{sxnum}->\verbtt{matrix}$, $\verbtt{sxnum}->\verbtt{matrix}->\verbtt{matrix}$;
\end{itemize}
\item `\verbtt{/}' is $t->\verbtt{num}->t$, where $t$ is \verbtt{num} or \verbtt{angle};
\item `\verbtt{\%}' (mod) and `\verbtt{**}' (exp) are $\verbtt{num}->\verbtt{num}->\verbtt{num}$;
\item `\verbtt{⊗}' (tensor mult) is $t->t->t$, where $t$ is \verbtt{bra}, \verbtt{ket}, \verbtt{gate} or \verbtt{matrix};
\item `\verbtt{⊗⊗}' (tensor exp) is $t->\verbtt{num}->t$, where $t$ is \verbtt{bra}, \verbtt{ket}, \verbtt{gate} or \verbtt{matrix};
\item `\verbtt{::}' (cons) is $'t->['t]->['t]$;
\item `\verbtt{@}' (append) is $['t]->['t]->['t]$;
\item `\ensuremath{^{\dag}}' (conjugate transpose) is $\verbtt{gate}->\verbtt{gate}$ or $\verbtt{matrix}->\verbtt{matrix}$.
\end{itemize}


\section{Built-in i/o channels, \verbtt{show} and \verbtt{qval}}
\seclabel{specialio}

There's an input channel $\verbtt{in}:\; \caret{}\verbtt{string}$; there are output channels $\verbtt{out}: \caret{}[\verbtt{string}]$ and $\verbtt{outq}: \caret{}\verbtt{qstate}$. Writing to the input channel, or reading from an output channel, is a run-time error because I don't know how to do the typechecking.
\begin{itemize}
\item \verbtt{in?(s)} reads a line from standard input and delivers it as a string. 
\item \verbtt{out![s1; .. ;s2]} writes strings on standard output. 
\item $\verbtt{show}:\; '{*}t->\verbtt{string}$ takes any value and produces a string. It produces `\verbtt{<qubit>}' for a qubit, `\verbtt{<qstate>}' for a qstate, to stop computational cheating. It treats functions, processes and channels similarly opaquely, but for more familiar reasons.
\item $\verbtt{qval}:\; \verbtt{qubit} ->\verbtt{qstate}$ takes a qubit and produces a description of its state. Useful for tracing and debugging, but to stop cheating the only thing you can usefully do with a qstate is to send it out along the \verbtt{outq} channel.
\item \verbtt{outq!qs} writes a string representing qubit state \verbtt{qs} on standard output; a string $\#i:V$, the qubit's index $i$ and a representation $V$ of its state as a symbolic-number vector in the computational basis -- including, if there is entanglement, a list of the indices of the qubits it's entangled with.
.
\end{itemize}

The \verbtt{outq} chanel is peculiar for good reason. It allows logging of a qubit's state, but it couldn't be a channel which takes a qubit, because if you send a qubit down a channel, you lose it. So there's \verbtt{qval} to help out: \verbtt{outq!qval q} is safe, if annoying. 

\section{Symbolic calculation}

Qtpi uses a symbolic quantum calculator: only during quantum measurement does it calculate numerically and possibly approximately. This enables it to do some nice tricks, like accurately `teleporting' a qubit whose value is unknown. It also means that it can do exact calculations.

Qubits are represented as integer indices into a quantum state of unitary vectors in the computational basis defined by \zero{} and \one. An unentangled qubit indexes a pair of complex-valued amplitude expressions $(A, B)$ representing $A\zero+B\one$; either $A$ or $B$ may be zero, and always $|A|^{2}+|B|^{2}=1$. A simply-entangled pair of qubits $\#i$ and $\#j$ each index a quadruple $(A,B,C,D)$, representing $(A\zerozero+B\zeroone+C\onezero+D\oneone)$ where $|A|^{2}+|A|^{2}+|B|^{2}+|C|^{2}+|D|^{2}=1$ and, again, some of $A$, $B$, $C$ and $D$ may be zero. And so on for larger entanglements: famously, $n$ qubits need $2^{n}$ amplitudes.

If $\#i${} is an `unknown' qubit, created by a \verbtt{newq} declaration without specifying a state, then its amplitudes are variables $a_{i}$ and $b_{i}$. The variables do have a secret value that is used when measuring the qubit or anything it's entangled with, but calculation uses only the uninterpreted variables and the fact that $|a_{i}|^{2}+|b_{i}|^{2}=1$.

Symbolic calculation uses the type \verbtt{sxnum}, which involves fractions (\verbtt{num}), variables, square roots of \verbtt{num}s ($\verbtt{sx\_sqrt}: \verbtt{num}->\verbtt{sxnum}$), $\sin$ and $\cos$ of fractions of $\pi$ (\verbtt{sx\_sin} and \verbtt{sx\_cos} are each $\verbtt{angle}->\verbtt{sxnum}$). It's remarkably effective.\footnote{It used to be based on powers of $\sqrt{1/2}$. No longer.}

\section{Non-unitary modulus}

Because it is unitary, the amplitudes of a ket\footnote{A column vector.}) which represents a qubit or a collection of qubits\footnote{Possibly entangled.} should be such that the sum of their absolute squares\footnote{The product of an amplitude with its complex conjugate, written $|a|^{2}$.}) should be 1. But when the amplitude formulae are very complicated it can sometimes be difficult for qtpi's calculator to normalise the result. So kets carry a modulus, the sum of the squares of its amplitudes. Normally this is 1, and then not mentioned, but otherwise the vector is printed prefixed by \verbtt{<<}$M$\verbtt{>>}, where $M$ is the sum of the absolute squares of its amplitudes. The interpretation is that every amplitude in the vector is divided by $\sqrt{M}$, and this is taken into account numerically during measurement.

\subsection{Complex amplitudes}

Amplitudes always represent complex numbers $x+iy$, but often $y$ is zero. The absolute square is always a real number.

\section{Pre-defined gates}

The built-in library defines various named gates. Mostly arity 1, except Cnot which is arity 2, F and T, which are arity 3. For definitions see the Wikipedia pages `Quantum logic gates' and `list of quantum logic gates'. But note: qtpi's versions of $Rx$, $Ry$ and $Rz$ are slightly different to the wiki ones -- period $2\pi$ rather than $4\pi$, suitable for polarised photons rather than spinning electrons. 

\begin{itemize}
\item  H, the Hadamard gate, takes \zero{} to $\frac{1}{\sqrt{2}}(\zero+\one)$, \one{} to $\frac{1}{\sqrt{2}}(\zero-\one)$. A kind of $45\deg$ or $\frac{\pi}{4}$ rotation -- but note, H*H=I.
\item I takes \zero{} to \zero, \one{} to \one. Identity.
\item X  takes \zero{} to \one{} and vice-versa. Exchange, inversion, not.
\item Z  takes \zero{} to \zero, \one{} to -\one{}. (dunno what to call it.)
\item Y  takes \zero{} to $-i$\one{}, \one{} to $i$\zero{}. (In some descriptions, Y is equivalent to Z*X. Qtpi has the Pauli version.)
\item Cnot takes \onezero{} to \oneone{} and vice-versa, otherwise an identity. (Controlled-not). Also spelled as `CNot` and `CNOT`. Same as CX.
\item CX, CY, CZ. Each treat \zerozero{} and \zeroone{} as I treats \zero{} and \one, and treat \onezero{} and \oneone{} as X, Y, Z treat \zero{} and \one{}. If you see what I mean ...
\item Swap takes \zeroone{} to \onezero{} and vice versa; otherwise an identity. Also spelled as `SWAP`.
\item F, the Fredkin gate, takes \onezeroone{} to \oneonezero{} and vice-versa, otherwise an identity. Also spelled as `Cswap`, `CSwap` and `CSWAP`.
\item T, the Toffoli gate, takes \oneonezero{} to \oneoneone{} and vice-versa, otherwise an identity. (Controlled-controlled-not). \vspace{5pt}

\item phi: $\verbtt{num}->\verbtt{gate}$ -- phi 0=I; phi 1=X; phi 2=Z; phi 3=Y; otherwise undefined. \vspace{5pt}

\item Rx, Ry and Rz are each rotation matrix functions, $\verbtt{angle}->\verbtt{gate}$. Note period $2\pi$ rather than $4\pi$.
  \begin{itemize}
  \item $\verbtt{Rx}\;\theta = \qgate{\cos\theta}{-i\sin\theta}{-i\sin\theta}{\cos\theta}$
  \item $\verbtt{Ry}\;\theta = \qgate{\cos\theta}{-\sin\theta}{\sin\theta}{\cos\theta}$
  \item $\verbtt{Rz}\;\theta = \qgate{\cos\theta-i\sin\theta}{0}{0}{\cos\theta+i\sin\theta}$
  \end{itemize}
\end{itemize}
  
\section{The \verbtt{dispose} channel}

Qubits can be discarded: Alice sends one to Bob, Bob receives it, measures it, remembers the result, and then waits for the next one. The qubit is destroyed on detection (unless you use the switch \verbtt{-measuredestroys false}), and it vanishes from the simulation. A vanished qubit is in fact recycled.

Qubits that aren't measured, and even measured qubits with \verbtt{-measuredestroys false}, live for ever. Sometimes this is inconvenient -- it muddies the waters if you are debugging, for example. To solve this problem there is a \verbtt{dispose}: $\caret{}\verbtt{qubit}$ channel: send a qubit down the \verbtt{dispose} channel and it vanishes. It will be made available to be recycled, unless it is entangled, in which case it may be made available later if the entanglement collapses, or it is an unknown, in which case it will be forever in limbo. Like any sent-away qubit, you can't use it once it's disposed.

Reading from \verbtt{dispose} is a run-time error, because I don't know how to typecheck send-only channels. At one time I thought it might be a source of qubits, but that would be to carry a joke too far.

\chapter{The library}

\newenvironment{explain}{\list{}{}\item\relax}{\endlist}
\newcommand{\libitem}[2]{\hspace{10pt}\verbtt{#1}\vspace{-\topsep}\vspace{-\parskip}\begin{explain}#2\vspace{-\parskip}\end{explain}}
\newcommand{\libitemS}[1]{\libitem{#1}{\mbox{}\vspace{-\topsep}\vspace{-\topsep}}}
Much of the library is inspired by Miranda, and by Bird \& Wadler's "Introduction to Functional Programming". Their descriptions of the functions are better than mine, too: wish I'd included pattern-matching function definitions.

Almost all functions take classical arguments (\verbtt{'a} rather than \verbtt{'*a}). None (except for the absurd case of \verbtt{abandon}) returns a value of a non-classical type.
    
Qtpi doesn't have an \verbtt{int} type, but several of the library functions insist on whole-number arguments: \verbtt{bitand}, \verbtt{drop}, \verbtt{nth}, \verbtt{num2bits}, \verbtt{randbits}, \verbtt{tabulate}, \verbtt{take}. If this causes a problem, use \verbtt{floor}, \verbtt{round} or \verbtt{ceiling} on the arguments.

\subsection{List functions}
\libitem{append: ['a] $->$ ['a] $->$ ['a]}{concatenates its arguments.}
\libitem{concat: [['a]] $->$ ['a]}{concatenates the lists in its first argument.}
\libitem{drop: num $->$ ['a] $->$ ['a]}{$drop\;n\;xs$ returns $xs$ without the leading segment which $take\;n\;xs$ would return.}
\libitem{dropwhile: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$dropwhile\;f\;xs$ returns $xs$ without the leading segment which $takewhile\;f\;$ would return.}
\libitem{exists: ('a $->$ bool) $->$ ['a] $->$ bool}{$exists\;f\;xs$ is true iff there is an element of xs for which $f$ returns true.}
\libitem{filter: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$filter\;f\;xs$ returns $xs$ without those elements for which $f$ returns false.}
\libitem{foldl: ('a $->$ 'b $->$ 'a) $->$ 'a $->$ ['b] $->$ 'a}{$foldl\;f\;z\;[x_{1};\,...\, ;\,x_{n}]$ is $f\;(...\;(f\;(f\;z\;x_{1})\;x_{2})\;...)\;x_{n}$.}
\libitem{foldr: ('a $->$ 'b $->$ 'b) $->$ 'b $->$ ['a] $->$ 'b}{$foldr\;f\;z\;[x_{1};\,...\, ;\,x_{n}]$ is $f\;x_{1}\;(f\;x_{2}(...\,(f\;x_{n}\;z)\,...))$.}
\libitem{forall: ('a $->$ bool) $->$ ['a] $->$ ['a]}{$forall\;f\;xs$ is true iff $f$ returns true for each element of xs.}
\libitem{hd: ['a] $->$ 'a}{$hd\;xs$ returns first element of $xs$; fails if $xs$ is empty.}  
\libitem{iter: ('a $->$ 'b) $->$ ['a] $->$ unit}{not sure this should be in the library.}
\libitem{length: ['a] $->$ num}{$length\;xs$ returns the number of elements in $xs$.}  	
\libitem{map: ('a $->$ 'b) $->$ ['a] $->$ ['b]}{$map\;f\;[x_{1};\,...\, ;\,x_{n}]$ is $[f\;x_{1};\,...\, ;\,f\;x_{n}]$.}
\libitem{mzip: ['a] $->$ ['b] $->$ [('a,'b)]}{turns two lists into a list of pairs; result is the length of the shorter list (as in Miranda).}
\libitem{nth: ['a] $->$ num $->$ 'a}{$nth\;i\;xs$ returns the $i$th element of $xs$ (counting from 0); fails if $i$ is negative, fractional or too large. (As in OCaml.)}
\libitem{rev: ['a] $->$ ['a]}{reverses its argument.}
\libitem{sort: (''a $->$ ''a $->$ num) $->$ [''a] $->$ [''a]}
		{sorts according to order defined by first argument -- 0 for $a=b$, -1 for $a<b$, 1 for $a>b$ (as C/OCaml).}
\libitem{tabulate: num $->$ (num $->$ 'a) $->$ ['a]}{$tabulate\;n\;f$ is $map\;f\;[0..n-1]$.}
\libitem{take: num $->$ ['a] $->$ ['a]}{$take\;n\;xs$ returns the first $n$ elements of $xs$; [] if $n$ is negative or zero; $xs$ if $n$ is too large.}
\libitem{takewhile: ('a $->$ bool) $->$ ['a] $->$ ['a]}{returns the longest initial segment of $xs$ for which $f$ returns true on every element.}
\libitem{tl: ['a] $->$ ['a]}  
	    {returns all but the first element of $xs$; fails if $xs$ is empty.}  
\libitem{unzip: [('a,'b)] $->$ (['a], ['b])}{turns a list of pairs into a pair of lists.}
\libitem{zip: ['a] $->$ ['b] $->$ [('a,'b)]}{turns two lists into a list of pairs; fails if the lists aren't the same length (as in OCaml).}

\subsection{Tuple functions}
\libitem{fst: ('a, 'b) $->$ 'a}{$fst\;(a,b)=a$}
\libitem{snd: ('a, 'b) $->$ 'b}{$snd\;(a,b)=b$}
 
\subsection{Gate and matrix functions}
\libitem{degate: gate $->$ matrix}{simple type conversion.}
\libitem{engate: matrix $->$ gate}{type conversion; fails if argument is not $2^{n}\times2^{n}$ and unitary ($M*M^{\dag}=I^{⊗n}$).}
\libitem{makeC: gate $->$ gate}{makes the `C\_' version of a $2\times2$ gate. $makeC\;X$, for example, is CX.}
\libitem{phi: num $->$ gate}{$phi\;0=I$; $phi\;1=X$; $phi\;2=Z$; $phi\;3=Y$; fails otherwise.}
\libitem{tabulate\_m: num $->$ num $->$ (num $->$ num $->$ sxnum) $->$ matrix}{$tabulate\_m\;r\;c\;f$ builds a matrix with $r$ rows and $c$ columns such that $M_{i,j}=f\;i\;j$.}
\libitem{tabulate\_diag\_m: num $->$ (num $->$ sxnum) $->$ matrix}{$tabulate\_diag\_m\;n\;f$ builds a diagonal $n\times{}n$ matrix such that $M_{i,i}=f\;i$ and off-diagonal elements are 0.}

\subsection{Numerical functions}
\libitem{ceiling: num $->$ num}{$ceiling\;i$ is the smallest integer not less than $i$}
\libitem{floor: num $->$ num}{$floor\;i$ is the largest integer not greater than $i$}
\libitem{max: num $->$ num $->$ num}{maximum}
\libitem{min: num $->$ num $->$ num}{minimum}
\libitem{pi: num}{a constant, approximately $\pi$.}
\libitem{round: num $->$ num}{$round\;i$ is the floor of $i+1/2$, if $i>=0$; the ceiling of $i-1/2$, if $i<0$.}
\libitem{sqrt: num $->$ num}{an approximation to square root; fails if argument is negative.}

\subsection{Bit functions}
\libitem{bitand: num $->$ num $->$ num}{bitwise `\&\&'.}
\libitem{bits2num: [$bit$] $->$ num}{convert to integer.}
\libitem{num2bits: num $->$ [$bit$]}{convert from integer; fail if negative or fractional.}

\subsection{Random functions}
\libitem{randbit: unit $->$ bit}{a single random bit.}
\libitem{randbits: num $->$ [$bit$]}{$randbits\;n$ is a sequence of $n$ random bits; fails if $n$ is negative or fractional.}
\libitem{randbool: unit $->$ bool}{a random boolean.}
\libitem{randp: num $->$ bool}{$randp\;p$ is a random boolean with probability $p$ of being true; fails unless $0\leq{}p\leq{}1$.}

\section{Symbolic-number functions}
\libitem{sx\_cos: angle $->$ sxnum}{$sx\_cos\;a$ is the \verbtt{sxnum} representing $\cos{a}$.}
\libitem{sx\_sqrt: num $->$ sxnum}{$sx\_sqrt\;n$ is the \verbtt{sxnum} representing $\sqrt{n}$.}
\libitem{sx\_sin: angle $->$ sxnum}{$sx\_sin\;a$ is the \verbtt{sxnum} representing $\sin{a}$.}
\libitem{sx\_0: sxnum, sx\_1: sxnum, sx\_i: sxnum}{constants representing 0, 1 and $\sqrt{-1}$.}

\subsection{Input-output functions}
\libitem{read\_alternative: string $->$ string $->$ [(string,'a)] $->$ 'a}
	    {$read\_alternative\;prompt\;sep\;[(s_{0},v_{0});\,(s_{0},v_{0});\,..]$ prints $prompt$ followed by the $s_{i}$s separated by $sep$; it insists that the user inputs one of the $s_{i}$s, and returns the corresponding $v_{i}$.}
\libitem{read\_bool: string $->$ string $->$ string $->$ bool}
	    {$read\_bool\;prompt\;y\;n$ is a version of $read\_alternative$ in which $y$ is the $s_{i}$ which returns \verbtt{true} and $n$ the one which returns \verbtt{false}.}
\libitem{read\_num: string $->$ num}{$read\_num\;prompt$ returns the number which the user inputs (it insists on a number).}
\libitem{read\_string: string $->$ string}{$read\_string\;prompt$ returns the string which the user inputs (an input line, without the newline).}  
\libitem{print\_qubit: qubit $->$ unit}
	    {$print\_qubit\;q$ has the same effect as \verbtt{outq!(qval q)}. (I think it's still possible to use it, but barely so.)}
\libitem{print\_string: string $->$ unit}
	    {$print\_string\;E$ has the same effect as \verbtt{out![E]}.}
\libitem{print\_strings: [string] $->$ unit}
	    {$print\_strings\;Es$ has the same effect as \verbtt{out!Es}.}

\subsection{Miscellaneous}
\libitem{abandon: [string] $->$ '*t}{stops the program, printing its argument, and doesn't return. For typechecking purposes, pretends to returns a value (which might be any type).}
\libitem{compare: ''a $->$ ''a $->$ num}
	{\verbtt{compare a b} returns 0 for $a=b$, -1 for $a<b$, 1 for $a>b$ (as C/OCaml)}
\libitem{const: 'a $->$ 'b $->$ 'a}{$const\; k\; x = k$}
\libitem{memofun: ('a $->$ 'b) $->$ 'a $->$ 'b}{makes a `memo function' of its argument: a function which remembers arguments with which it has been called and avoids recalculation. (Oh dear.)}
\libitem{qval: qubit $->$ qstate}{constructs an opaque value, of type \verbtt{qstate}, which describes the state of a qubit. The only thing you can usefully do with the value is send it down the \verbtt{outq} channel.}
\libitem{qvals: qubits $->$ qstate}{\verbtt{qval} for qubit collections. See \secref{specialio}.}
\libitem{show: '{*}a $->$ string}{converts a value, of arbitrary type, to a string. Gives a deliberately opaque result if applied to a qubit, function, process, channel or qstate. (Actually it's not really a function, more a sort of macro description for a family of functions, one for each type.)} 
\libitem{showf: num $->$ num $->$ string}{$showf\;i\;n$ returns a string representing $n$ as a decimal fraction to $i$ decimal places.} 


\bibliographystyle{plainnat}
\bibliography{quantum} 

\end{document}