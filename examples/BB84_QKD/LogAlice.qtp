
proc LogAlice (reps, verbose, log, done) =
    log?(bs)   .
    log?(vs)   .
    {if verbose then print_strings  ["Alice chose "; string_of_value (length bs);
                                     " pairs: "; string_of_value (zip bs vs); "\n"] else () fi} .
    log?(bAs)         .
    {if verbose then print_strings  ["Alice sent bases "; string_of_value bAs; "\n"] else () fi} .
    log?(bBs)  .
    {if verbose then print_strings  ["Alice received bases "; string_of_value bBs; "\n"] else () fi} .
    log?(rvs)   . 
    {if verbose then print_strings  ["Alice reconciled "; string_of_value (length rvs);
                                    " bits: "; string_of_value rvs; "\n"] else () fi} .
    log?(mask) .
    {if verbose then print_strings  ["Alice received check-bit mask "; string_of_value mask; "\n"] else () fi} .
    log?(cs)  .
    (let nc = length cs)
    {if verbose then print_strings  ["Alice received "; string_of_value nc; 
                                    " check bits: "; string_of_value cs; "\n"] else () fi} .
    log?(boolbits) .
    if bit2bool (hd boolbits) then
      {print_strings  ["interference detected -- "; string_of_value nc; " check bits\n"]} .
      done!true,length bs,nc,reps .
      _0
    else
      {if not verbose then print_string  "\n" else () fi}.
      log?(boolbits) .
      if bit2bool (hd boolbits) then
        log?(code) .
        {if verbose then print_strings  ["Alice's code is "; string_of_value code; "\n"] else () fi} .
        log?(encrypted) .
        {if verbose then print_strings  ["Alice sent encrypted "; string_of_value encrypted; "\n"] else () fi} .
        done!false,length bs,nc,reps .
        _0
      else
        {print_string  "Alice goes round again\n"} .
        LogAlice (reps+1, verbose, log, done)   
      fi
    fi
  
