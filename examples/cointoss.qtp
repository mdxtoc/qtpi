(* given a random qbit (a|0>+b|1>), this may terminate with
   either a|0>+b|1> or a|0>-b|1>. Interesting, eh? Only 
   'really' works if the initial qbit is |0> 
   -- i.e. an unfair coin IMHO.
 *)

proc P(fromQ:^qbit, toQ:^qbit, log) = 
  + fromQ?(y) . toQ!y .         
                log!() .
                _0
  + fromQ?(y) . y>>_X . 
                out!["with a flip; "]. 
                toQ!y .                     
                log!()  . 
                _0
                     
proc Q(q: qbit, toP:^qbit, fromP:^qbit, log) = 
  out!["initially "] . outq!(qval q) . out!["; "] .
  q>>_H . toP!q . fromP?(q') . q'>>_H . 
  out!["finally "] . outq!(qval q') . out!["\n"] .
  log!() . _0 

proc System() = (let k = read_int "number of trials")
                (let bv = read_alternative "basis" "," ["0",|0>; "1",|1>; "+",|+>; "-",|->])
                (let verbose = read_bool "with commentary" "y" "n")
           out!["See output for results -- can print but can't examine qbit state\n"] .
           Logger (k, bv, verbose)

proc Logger (k, bv, verbose) = Run (k, bv, verbose, 0)

proc Run (k, bv, verbose, i) = 
  if i=k then out![show i; " trials\n"] . _0
  else
    (newq q = bv) 
    (new s:^qbit, r:^qbit)
    (new reportP, reportQ)
    | P(s,r,reportP) 
    | Q(q,s,r,reportQ) 
    | reportP?(_) .
      reportQ?(_) .
      Run (k, bv, verbose, i+1)
  fi
